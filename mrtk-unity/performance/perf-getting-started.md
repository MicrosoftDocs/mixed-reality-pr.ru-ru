---
title: Производительность
description: Документация для понимания и настройки предопределения в МРТК.
author: keveleigh
ms.author: kurtie
ms.date: 01/12/2021
keywords: Unity, HoloLens, HoloLens 2, смешанная реальность, разработка, MRTK
ms.openlocfilehash: 6c8e060af585d7994774ea0bb575b6e5172b9558
ms.sourcegitcommit: 912fa204ef79e9b973eab9b862846ba5ed5cd69f
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/16/2021
ms.locfileid: "114281768"
---
# <a name="performance"></a>Производительность

## <a name="getting-started"></a>Начало работы

Самый простой способ рационализировать производительность — это частота кадров или количество раз, когда приложение может отобразить образ в секунду. Важно соблюдать целевую частоту кадров, как описано в целевой платформе (т. е. [Windows Mixed Reality](/windows/mixed-reality/understanding-performance-for-mixed-reality), [окулус](https://developer.oculus.com/documentation/pcsdk/latest/concepts/dg-performance-guidelines/)и т. д.). например, на HoloLens целевая частота кадров составляет 60 кадров/с. Приложения с низкой частотой кадров могут привести к разрушению пользовательских интерфейсов, таких как [голограмма усугубить стабилизации](../performance/hologram-stabilization.md), отслеживание мира, отслеживание вручную и многое другое. чтобы помочь разработчикам в отслеживании и достижении качества кадров, смешанная реальность набор средств предоставляет разнообразные средства и сценарии.

### <a name="visual-profiler"></a>Визуальный профилировщик

Чтобы постоянно контролировать производительность в течение жизненного цикла разработки, настоятельно рекомендуется всегда отображать визуальный элемент частоты кадров во время работы & отладки приложения. набор средств смешанной реальности предоставляет средство диагностики [визуального профилировщика](../features/diagnostics/using-visual-profiler.md) , которое предоставляет сведения в режиме реального времени о текущих кадрах и использовании памяти в представлении приложения. визуальный профилировщик можно настроить с помощью [Параметры системы диагностики](../features/diagnostics/diagnostics-system-getting-started.md) в [инспекторе профилей мртк](../configuration/mixed-reality-configuration-guide.md).

Более того, особенно важно использовать Visual Profiler для наблюдения за частотой кадров при запуске на устройстве, в отличие от работы в редакторе Unity или эмуляторе. Наиболее точные результаты производительности будут показаны при запуске на устройстве с [сборками конфигурации выпуска](/visualstudio/debugger/how-to-set-debug-and-release-configurations?preserve-view=true&view=vs-2019).

> [!NOTE]
> если сборка для Windows Mixed Reality, развертывание с помощью [сборок главной конфигурации](/windows/mixed-reality/exporting-and-building-a-unity-visual-studio-solution#building_and_deploying_a_unity_visual_studio_solution)

![Интерфейс Visual Profiler](../features/images/Diagnostics/VisualProfiler.png)

### <a name="optimize-window"></a>Окно оптимизации

[Окно Оптимизация мртк](../features/tools/optimize-window.md) предлагает средства информации и автоматизации, которые помогут разработчикам смешанной реальности настроить среду для достижения наилучших результатов и определить потенциальные узкие места в их сценах & активы. Определенные ключевые конфигурации в Unity позволяют обеспечить более оптимизированные результаты для проектов смешанной реальности.

Как правило, эти параметры предполагают визуализацию конфигураций, которые идеально подходят для смешанной реальности. Приложения смешанной реальности уникальны по сравнению с традиционной разработкой трехмерной графики в том, что существует два экрана (т. е. два глаза) для отрисовки для всей сцены.

Рекомендуемые параметры, указанные ниже, можно настроить в проекте Unity, используя окно Оптимизация МРТК.

![Параметры оптимизации окна мртк](../features/images/performance/OptimizeWindow_Settings.png)

### <a name="unity-profiler"></a>Профилировщик Unity

[Профилировщик Unity](https://docs.unity3d.com/Manual/ProfilerWindow.html) является полезным средством для анализа сведений о производительности приложения на уровне кадров.

#### <a name="time-spent-on-the-cpu"></a>Время, затраченное на ЦП

![Пример Graphного профилировщика Unity](../features/images/performance/UnityProfilerGraph.png)

Чтобы обеспечить удобную частоту кадров (как правило, 60 кадров в секунду), приложениям необходимо достигнуть максимального времени кадра, равного 16,6 миллисекундам времени ЦП. чтобы определить стоимость функциональности мртк, набор средств Microsoft Mixed Reality содержит маркеры для ветвей кода внутреннего цикла (на кадр). Эти маркеры используют следующий формат для помощи в понимании конкретных используемых функций:

```
[MRTK] className.methodName
```

> [!Note]
> Можно указать дополнительные данные после имени метода. Это позволяет определять условно выполненные, потенциально ресурсоемкие функции, которые могут быть незначительными изменениями в коде приложения.

![Пример иерархии профилировщика Unity](../features/images/performance/UnityProfilerHierarchy.png)

В этом примере иерархия была расширена, чтобы продемонстрировать, что метод Упдатеханддата класса Виндовсмикседреалитяртикулатедханд потребляет 0,44 МС времени ЦП во время анализируемого кадра. Эти данные можно использовать, чтобы определить, связана ли проблема с производительностью с кодом приложения или в других местах системы.

Настоятельно рекомендуется, чтобы разработчики выполняли инструментирование кода приложения подобным образом. Основные аспекты фокусировки для инструментирования кода приложения находятся в обработчиках событий, так как эти методы начисляются в цикле обновления МРТК по мере возникновения событий. Высокая продолжительность кадров в цикле обновления МРТК может указывать на дорогостоящий код в методах обработчика событий.

## <a name="recommended-settings-for-unity"></a>Рекомендуемые параметры для Unity

### <a name="single-pass-instanced-rendering"></a>Single-Passная визуализация

Конфигурация отрисовки по умолчанию для XR в Unity является [многопроходной](https://docs.unity3d.com/ScriptReference/StereoRenderingPath.MultiPass.html). Этот параметр заставляет Unity выполнять весь конвейер отрисовки дважды, по одному разу для каждого взгляда. Это можно оптимизировать, выбрав вместо этого [однопроходную визуализацию с одним экземпляром](https://docs.unity3d.com/Manual/SinglePassInstancing.html) . Эта конфигурация использует [массивы целевых объектов рендеринга](https://en.wikipedia.org/wiki/Multiple_Render_Targets) , чтобы иметь возможность выполнять один вызов Draw, который получит экземпляры в соответствующий [целевой объект рендеринга](https://en.wikipedia.org/wiki/Render_Target) для каждого взгляда. Кроме того, этот режим позволяет выполнять рендеринг в одном выполнении конвейера отрисовки. Таким образом, выбор однопроходного экземпляра отрисовки в качестве пути отрисовки для приложения смешанной реальности может [сэкономить значительное время на цп & GPU](https://blogs.unity3d.com/2017/11/21/how-to-maximize-ar-and-vr-performance-with-advanced-stereo-rendering/) и является рекомендуемой конфигурацией подготовки к просмотру.

Тем не менее, чтобы выполнить один вызов Draw для каждой сетки в каждом глазе, создание [экземпляров GPU](https://docs.unity3d.com/Manual/GPUInstancing.html) должно поддерживаться всеми шейдерами. Создание экземпляров позволяет мультиплексным графическим процессорам осуществлять вызовы рисования по обоим глазам. Встроенные шейдеры Unity, а также [стандартный построитель текстуры мртк](../features/rendering/mrtk-standard-shader.md) по умолчанию содержат необходимые инструкции по созданию экземпляров в коде шейдера. При написании пользовательских шейдеров для Unity, возможно, потребуется обновить эти шейдеры для поддержки отрисовки с однопроходным экземпляром.

#### <a name="example-code-for-custom-shader"></a>[Пример кода для пользовательского шейдера](https://docs.unity3d.com/Manual/SinglePassInstancing.html)

```
struct appdata
{
    float4 vertex : POSITION;
    float2 uv : TEXCOORD0;

    UNITY_VERTEX_INPUT_INSTANCE_ID //Insert
};

struct v2f
{
    float2 uv : TEXCOORD0;
    float4 vertex : SV_POSITION;

    UNITY_VERTEX_OUTPUT_STEREO //Insert
};

v2f vert (appdata v)
{
    v2f o;

    UNITY_SETUP_INSTANCE_ID(v); //Insert
    UNITY_INITIALIZE_OUTPUT(v2f, o); //Insert
    UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o); //Insert

    o.vertex = UnityObjectToClipPos(v.vertex);

    o.uv = v.uv;

    return o;
}
```

### <a name="quality-settings"></a>Параметры качества

Unity предоставляет [предустановки для управления качеством](https://docs.unity3d.com/Manual/class-QualitySettings.html) отрисовки для каждой конечной точки платформы. Эти предустановки определяют, какие графические функции могут быть включены, такие как тени, сглаживание, глобальные освещения и многое другое. Рекомендуется уменьшить эти параметры и оптимизировать количество вычислений, выполненных во время подготовки к просмотру.

*Шаг 1.* Обновление проектов Unity в смешанной реальности для использования параметра *низкого уровня качества*  
**Изменить**  >  **Project Параметры**, выберите категорию **качества** > выберите *низкое качество* для платформы UWP.

*Шаг 2.* Для каждого файла сцены Unity отключите [глобальные освещения в режиме реального времени](https://docs.unity3d.com/Manual/LightMode-Realtime.html) .  
**Окно**  >  **Подготовка к просмотру**  >  **освещение Параметры**  >  [Снять флажок *глобального освещения в режиме реального времени*](https://docs.unity3d.com/Manual/GlobalIllumination.html)

### <a name="depth-buffer-sharing-hololens"></a>Общий доступ к буферу глубины (HoloLens)

если разработка для Windows Mixed Realityной платформы и в определенных HoloLens, включение *общего доступа к буферу глубины* в рамках *XR Параметры* может помочь с [голограммами стабилизации](../performance/hologram-stabilization.md). Однако обработка буфера глубины может повлечь за собой затраты на производительность, особенно если используется [24-разрядный формат глубины](https://docs.unity3d.com/ScriptReference/PlayerSettings.VRWindowsMixedReality-depthBufferFormat.html). Поэтому *настоятельно рекомендуется* настроить для буфера глубины 16-разрядную точность.

Если [z-борьба](https://en.wikipedia.org/wiki/Z-fighting) происходит из-за нижнего формата, убедитесь, что на [дальней плоскости](https://docs.unity3d.com/Manual/class-Camera.html) для всех камер установлено наименьшее возможное значение для приложения. Unity по умолчанию задает FAR плоскость обрезки 1000m. на HoloLens далеко плоскость обрезки 50 млна, как правило, больше, чем достаточно для большинства сценариев приложений.

> [!NOTE]
> Если используется *16-разрядный формат глубины*, требуемые эффекты для буфера набора элементов не будут работать, так как [Unity не создает буфер шаблона](https://docs.unity3d.com/ScriptReference/RenderTexture-depth.html) в этом параметре. Если выбрать *24-разрядный формат глубины* , то, как правило, будет создавать 8-разрядный буфер трафаретов, если это применимо на графической платформе конечной платформы.
>
> При использовании [компонента маски](https://docs.unity3d.com/Manual/script-Mask.html) , для которого требуется буфер шаблона, рассмотрите возможность использования [RectMask2D](https://docs.unity3d.com/Manual/script-RectMask2D.html) вместо того, что не требует буфера шаблона и, таким же, можно использовать в сочетании с *16-разрядным форматом глубины*.

> [!NOTE]
> чтобы быстро определить, какие объекты в сцене не записываются в буфер глубины визуально, можно использовать [служебную программу *буфера глубины визуализации*](../configuration/mixed-reality-configuration-guide.md#editor-utilities) в *редакторе Параметры* в профиле конфигурации мртк.

### <a name="optimize-mesh-data"></a>Оптимизация данных сетки

Параметры [оптимизации сетки данных](https://docs.unity3d.com/ScriptReference/PlayerSettings-stripUnusedMeshComponents.html) попытаются удалить неиспользуемые атрибуты вершин в приложении. Этот параметр выполняет эту операцию, запуская каждый из построителей шейдера каждый материал, который находится на каждой сетке в сборке. Это хорошо подходит для размера данных игры и производительности среды выполнения, но может радикально снизить время сборки.

Рекомендуется отключить этот параметр во время разработки и повторно включить во время создания "главного" сборки. этот параметр можно найти в разделе **изменение**  >  **Project Параметры**  >  **проигрывателе**  >  **другие Параметры**  >  **оптимизировать данные сетки**.

## <a name="general-recommendations"></a>Общие рекомендации

Производительность может быть неоднозначной и постоянно изменяющейся задачей для разработчиков смешанной реальности и спектра знаний, рационализировать производительность. Существует несколько общих рекомендаций, позволяющих понять, как лучше всего подходить к производительности приложения.

Это позволяет упростить выполнение приложения в части, которые выполняются на *ЦП* или *GPU* и тем самым определить, ограничено ли приложение каким-либо компонентом.  Могут существовать узкие места, охватывающие оба единица обработки, и некоторые уникальные сценарии, которые необходимо тщательно исследовать. Однако для начала работы лучше понять, где выполняется приложение в течение всего времени.

### <a name="gpu-bounded"></a>Ограниченный GPU

Поскольку большинство платформ для приложений смешанной реальности используют [визуализацию стереоскопик](https://en.wikipedia.org/wiki/Stereoscopy), очень часто бывает так, что он ограничен графическим процессором из-за особенностей отрисовки экрана "вдвое". фусерморе, такие платформы mobile reality, как HoloLens или окулус, будут ограничены процессором мобильного класса & вычислительной мощности.

При сосредоточении на GPU обычно существует два важных этапа, которые приложение должно выполнить для каждого кадра.

1. Выполнение [шейдера вершин](https://en.wikipedia.org/wiki/Shader#Vertex_shaders)
2. Выполнение [шейдера пикселей](https://en.wikipedia.org/wiki/Shader#Pixel_shaders) (также известного как шейдер фрагментов)

Без глубокого углубления в комплексное поле компьютерной графики & [конвейеров подготовки к просмотру](https://en.wikipedia.org/wiki/Graphics_pipeline)каждый этап шейдера — это программа, которая работает на GPU для получения следующих данных.

1. Шейдеры вершин преобразуют вершины сетки в координаты в пространстве экрана (т. е. код, выполняемый на вершину)
2. Шейдеры пикселей вычисляют цвет для рисования в данном фрагменте пикселя и в сетке (т. е. код выполнения кода на пиксель)

В соответствии с настройкой производительности, как правило, более плодотворный, чтобы сосредоточиться на оптимизации операций в шейдере пикселей. Приложению может потребоваться только нарисовать куб, который будет содержать только 8 вершин. Тем не менее пространство экрана, занимаемое кубом, скорее всего, будет находиться в том же порядке, что и миллионы пикселей. Таким образом, уменьшение кода шейдера, например 10 операций, может значительно увеличить объем работы, если уменьшить построитель текстуры, чем шейдер вершин.

Это одна из основных причин использования [шейдера Мртк Standard](../features/rendering/mrtk-standard-shader.md) , так как этот шейдер обычно выполняет гораздо меньшее количество инструкций на пиксель & вершиной, чем у стандартного шейдера Unity, при достижении сравнимых результатов Aesthetic.

|    Оптимизация ЦП      |             Оптимизация GPU              |
|---------------------------|--------------------------------------------|
| Логика моделирования приложений      | Операции отрисовки |
| Упрощение Физикы          | Сокращение вычислений освещения |
| Упрощение анимации       | Уменьшить число многоугольников & число рисуемых объектов |
| Управление сбором мусора | Уменьшение числа прозрачных объектов |
| Ссылки на кэш          | Избегайте последующей обработки и полноэкранных эффектов  |

### <a name="draw-call-instancing"></a>Создание экземпляров вызова метода Draw

Одна из наиболее распространенных ошибок в Unity, уменьшающая производительность, — клонирование материалов во время выполнения. Если объекты gameobject совместно используют одни и те же материалы и (или) те же сети, их можно оптимизировать в единый вызов Draw с помощью таких методов, как *[статическая пакетирование](https://docs.unity3d.com/Manual/DrawCallBatching.html)*, *[Динамическая пакетирование](https://docs.unity3d.com/Manual/DrawCallBatching.html)* и создание *[экземпляров GPU](https://docs.unity3d.com/Manual/GPUInstancing.html)*. Однако, если разработчик изменяет свойства [материала модуля подготовки](https://docs.unity3d.com/ScriptReference/Renderer-material.html) во время выполнения, Unity создаст копию назначенного материала.

Например, если в сцене есть Кубы 100, разработчику может потребоваться назначить каждому из них уникальный цвет. При доступе модуля [*подготовки отчетов. Material. Color*](https://docs.unity3d.com/ScriptReference/Material-color.html) в C# Unity создает новый материал в памяти для этого конкретного модуля подготовки отчетов или GameObject. Каждый из кубов 100 будет иметь свой собственный материал, поэтому они не могут объединяться в один вызов Draw, а вместо этого будут преобразованы 100, которые вырисуют запросы вызова от ЦП к GPU.

Чтобы преодолеть этот препятствием и по-прежнему назначить уникальный цвет для каждого куба, разработчики должны использовать [материалпропертиблокк](https://docs.unity3d.com/ScriptReference/MaterialPropertyBlock.html).

```c#
private PropertyBlock m_PropertyBlock ;
private Renderer myRenderer;

private void Start()
{
     myRenderer = GetComponent<Renderer>();
     m_PropertyBlock = new MaterialPropertyBlock();
}

private void ChangeColor()
{
    // Creates a copy of the material once for this renderer
    myRenderer.material.color = Color.red;

    // vs.

    // Retains instancing capability for renderer
    m_PropertyBlock.SetColor("_Color", Color.red);
    myRenderer.SetPropertyBlock(m_PropertyBlock);
}
```

## <a name="unity-performance-tools"></a>Средства производительности Unity

Unity предоставляет отличные средства производительности, встроенные в редактор.

- [Профилировщик Unity](https://docs.unity3d.com/Manual//Profiler.html)
- [Отладчик фреймов Unity](https://docs.unity3d.com/Manual/FrameDebugger.html)

При оценке приблизительного компромисса производительности между одним шейдером и другим, полезно скомпилировать каждый шейдер и просмотреть количество операций на каждый этап шейдера. Это можно сделать, выбрав [ресурс шейдера](https://docs.unity3d.com/Manual/class-Shader.html) и нажав кнопку *компилировать и показывать код* . Это приведет к компиляции всех вариантов шейдера и открытию Visual Studio с результатами. Примечание. полученные статистические результаты могут различаться в зависимости от того, какие функции были включены в материалах, использующих заданный шейдер. Unity будет компилировать только варианты шейдера, которые непосредственно используются в текущем проекте.

Пример статистики для стандартного шейдера Unity

![Статистика стандартного шейдера Unity 1](../features/images/performance/UnityStandardShader-Stats.PNG)

Пример статистики стандартного шейдера МРТК

![Статистика МРТК Standard Shader 2](../features/images/performance/MRTKStandardShader-Stats.PNG)

## <a name="see-also"></a>См. также

### <a name="unity"></a>Unity

- [Оптимизация производительности Unity для начинающих](https://www.youtube.com/watch?v=1e5WY2qf600)
- [Учебники по оптимизации производительности Unity](https://unity3d.com/learn/tutorials/topics/performance-optimization)
- [Рекомендации по оптимизации Unity](https://docs.unity3d.com/Documentation/Manual/BestPracticeUnderstandingPerformanceInUnity.html)
- [Оптимизация производительности графики](https://docs.unity3d.com/Manual/OptimizingGraphicsPerformance.html)
- [Практическое руководством по оптимизации мобильных устройств](https://docs.unity3d.com/Manual/MobileOptimizationPracticalGuide.html)

### <a name="windows-mixed-reality"></a>Windows Mixed Reality

- [рекомендуемые Параметры для Unity](/windows/mixed-reality/recommended-settings-for-unity)
- [Основные сведения о производительности смешанной реальности](/windows/mixed-reality/understanding-performance-for-mixed-reality)
- [Рекомендации по производительности для Unity](/windows/mixed-reality/performance-recommendations-for-unity)
- [отслеживание событий для Windowsного руководством Unity](https://docs.unity3d.com/uploads/ExpertGuides/Analyzing_your_game_performance_using_Event_Tracing_for_Windows.pdf)

### <a name="oculus"></a>окулус

- [Рекомендации по производительности](https://developer.oculus.com/documentation/pcsdk/latest/concepts/dg-performance-guidelines/)
- [Средства производительности](https://developer.oculus.com/documentation/pcsdk/latest/concepts/dg-performance-tools/)

### <a name="mesh-optimization"></a>Оптимизация сетки

- [Оптимизация трехмерных моделей](/dynamics365/mixed-reality/import-tool/optimize-models#performance-targets)
- [Рекомендации по преобразованию и оптимизации трехмерных моделей в режиме реального времени](/dynamics365/mixed-reality/import-tool/best-practices)
