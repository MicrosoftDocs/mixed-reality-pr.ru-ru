---
title: Манипулятор объекта
description: Как использовать манипулятор объекта в МРТК
author: thalbern
ms.author: bethalha
ms.date: 01/12/2021
keywords: Unity, HoloLens, HoloLens 2, смешанная реальность, разработка, мртк, управление объектами
ms.openlocfilehash: f9b644c1447d6776389e227bfe49c27f82a3cf31
ms.sourcegitcommit: f338b1f121a10577bcce08a174e462cdc86d5874
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/01/2021
ms.locfileid: "113176654"
---
# <a name="object-manipulator"></a>Манипулятор объекта

![Манипулятор объекта](../images/manipulation-handler/MRTK_Manipulation_Main.png)

*Обжектманипулатор* — это новый компонент для поведения манипуляции, ранее обнаруженный в *манипулатионхандлер*. Манипулятор объекта делает ряд улучшений и упрощений. Этот компонент является заменой обработчика манипуляций, который будет считаться устаревшим.

Сценарий *обжектманипулатор* делает объект перемещаемым, масштабируемым и ротатабле, используя одну или две руки. Манипулятор объекта можно настроить для управления тем, как объект будет отвечать на различные входные данные. сценарий должен работать с большинством видов взаимодействия, например HoloLens 2 с клавиатуры, HoloLens 2 лучами, HoloLens 1 взгляд и жесты, а также ввод впечатляющих контроллеров движения гарнитуры.

> [!VIDEO https://channel9.msdn.com/Shows/Docs-Mixed-Reality/Using-Object-Manipulator-in-Mixed-Reality-Toolkit/player]

## <a name="how-to-use-the-object-manipulator"></a>Использование манипулятора объекта

Чтобы использовать манипулятор объекта, сначала добавьте `ObjectManipulator` компонент скрипта в GameObject. Не забудьте добавить к объекту объект, соответствующий заданным границам.

Чтобы сделать объект ответом на близкие входные данные, добавьте `NearInteractionGrabbable` также скрипт.

Поведение физикы можно включить для манипулятора объекта, добавив компонент RigidBody в объект. Поведение физикы, включенное добавлением этого компонента, подробно описано в разделе [*физика и конфликты*](#physics-and-collisions).

Кроме того, управление может быть ограничено путем добавления [компонентов ограничений манипуляции](constraint-manager.md#transform-constraints) в объект. Это специальные компоненты, которые работают с манипуляцией и изменяют поведение манипуляции каким – либо образом.

![Использование обработчика манипуляции в редакторе Unity](../images/object-manipulator/MRTK_ObjectManipulator_Howto.png)

## <a name="inspector-properties-and-fields"></a>Свойства и поля инспектора

<img src="../images/object-manipulator/MRTK_ObjectManipulator_Structure.png" width="450" alt="Object Manipulator Structure">

### <a name="general-properties"></a>Общие свойства

#### <a name="host-transform"></a>Преобразование узла

Преобразование объекта, которое будет управляться. По умолчанию используется объект компонента.

#### <a name="manipulation-type"></a>Тип манипуляции

Указывает, можно ли манипулировать объектом с помощью одной руки или двух стрелок. Так как это свойство является флагом, можно выбрать оба параметра.

- *Один из них*: включает одну обработанную манипуляцию, если она выбрана.
- *Две руки*: включает две манипуляции, если она выбрана.

#### <a name="allow-far-manipulation"></a>Разрешить далекое манипуляции

Указывает, можно ли выполнять манипуляции с помощью дальнего взаимодействия с указателями.

### <a name="one-handed-manipulation-properties"></a>Одно обработанное свойство манипуляции

#### <a name="one-hand-rotation-mode-near"></a>Режим поворота одного руки рядом с

Указывает, как будет вести себя объект при наличии одной руки рядом с ней. Эти параметры работают только для начеткого руки.

- *Поворот по Object Center*: объект вращается с поворотом руки, а не с точки зрения центра объектов. Объект будет двигаться меньше, чем он поворачивается, но может наблюдаться ощущение несоединения между рукой и объектом. Более полезно для дальнего взаимодействия.
- *Поворот точки захвата*: поворот объекта с помощью руки, посвященной точке захвата между бегунком и указателем пальца. Он должен иметь вид, если объект удерживается рукой.

#### <a name="one-hand-rotation-mode-far"></a>Режим поворота одного руки

Указывает, как будет вести себя объект, когда он помещается с одной рукой на расстояние. Эти параметры работают только для начеткого руки.

- *Повернуть на центр Object Center*: поворот объекта с помощью поворота руки, а также от точки центра объектов. Полезен для проверки на расстоянии без перемещения по центру объектов при повороте объекта.
- *Поворот точки захвата*: поворот объекта с помощью поворота руки, а также о точке попадания в указатель луча. Полезно для проверки.

### <a name="two-handed-manipulation-properties"></a>Два свойства манипуляции с руки

#### <a name="two-handed-manipulation-type"></a>Тип двунаправленной манипуляции

Указывает, как две манипуляции могут преобразовывать объект. Поскольку это свойство является флагом, можно выбрать любое количество параметров.

- *Переместить*: перемещение разрешено, если выбрано.
- *Масштаб*. масштабирование разрешено, если выбрано.
- *Повернуть*: поворот разрешен, если он выбран.

![Обработчик манипуляции](../images/manipulation-handler/MRTK_ManipulationHandler_TwoHanded.jpg)

### <a name="constraints"></a>Ограничения

#### <a name="enable-constraints"></a>Включить ограничения

Этот параметр включит [Диспетчер связанных ограничений](constraint-manager.md). Изменения преобразования будут обработаны ограничениями, зарегистрированными для выбранного [диспетчера ограничений](constraint-manager.md).

#### <a name="constraint-manager"></a>Диспетчер ограничений

В раскрывающемся списке можно выбрать любой из подключенных [диспетчеров ограничений](constraint-manager.md). Манипулятор объекта гарантирует, что [Диспетчер ограничений](constraint-manager.md) подключен всегда.
Обратите внимание, что несколько компонентов одного типа будут отображаться под одним и тем же именем в Unity. Чтобы упростить различение нескольких диспетчеров ограничений для одного и того же объекта, доступные параметры будут показывать указание в конфигурации выбранного диспетчера ограничений (ручной или автоматический выбор ограничений).

#### <a name="go-to-component"></a>Переход к компоненту

Выбор диспетчера ограничений сопровождается кнопкой " *Переход к компоненту* ". Эта кнопка приведет к прокрутке инспектора до выбранного компонента, чтобы его можно было настроить.

### <a name="physics"></a>Физика

Параметры в этом разделе отображаются только в том случае, если объект имеет компонент RigidBody.

#### <a name="release-behavior"></a>Поведение выпуска

Укажите, какие физические свойства должен иметь управляемый объект при выпуске. Так как это свойство является флагом, можно выбрать оба параметра.

- *Скорость сохранения*: при освобождении объекта, если выбран этот параметр, он сохранит линейную скорость.
- *удерживать Angularную скорость*: при освобождении объекта, если выбран этот параметр, его угловая скорость сохраняется.

#### <a name="use-forces-for-near-manipulation"></a>Использовать силы для близкой манипуляции

Используются ли для перемещения объекта физические силы при выполнении практических манипуляций. Если присвоить этому параметру *значение false* , объект будет напрямую подключен к пользователям. Если задать для этого свойства *значение true* , будет соблюдаться масса и инерция объекта, но может показаться, что объект подключен через пружину. Значение по умолчанию — *false*.

### <a name="smoothing"></a>Сглаживание

#### <a name="smoothing-far"></a>Плавное сглаживание

Включено ли независимое сглаживание кадров для дальнего взаимодействия. При этом по умолчанию включается гораздо более гладкое сглаживание.

#### <a name="smoothing-near"></a>Смягчение вблизи

Включено ли независимое сглаживание кадров для практических взаимодействий. Близкое сглаживание отключено по умолчанию, так как результат может считаться "отключенным" от руки.

#### <a name="smoothing-active"></a>Сглаживание активно

Устарело и будет удалено в следующей версии. Приложения должны использовать Смусингфар, Смусингнеар или сочетание этих двух.

#### <a name="move-lerp-time"></a>Переместить время лерп

Объем сглаживания, применяемый к перемещению. Сглаживание 0 означает отсутствие сглаживания. Максимальное значение означает отсутствие изменений в значении.

#### <a name="rotate-lerp-time"></a>Поворот времени лерп

Объем сглаживания, применяемый к повороту. Сглаживание 0 означает отсутствие сглаживания. Максимальное значение означает отсутствие изменений в значении.

#### <a name="scale-lerp-time"></a>Масштабирование лерп времени

Объем сглаживания, применяемый к шкале. Сглаживание 0 означает отсутствие сглаживания. Максимальное значение означает отсутствие изменений в значении.

### <a name="manipulation-events"></a>События манипуляции

Обработчик манипуляции предоставляет следующие события:

- *Онманипулатионстартед*: срабатывает при начале манипуляции.
- *Онманипулатионендед*: активируется по окончании манипуляции.
- *Онховерстартед*: срабатывает, когда рука или контроллер наводит указатель мыши на манипулятор, NEAR или FAR.
- *Онховерендед*: срабатывает, когда рукой или контроллер отменяет наведение указателя мыши на манипулятор, NEAR или FAR.

Порядок запуска событий для манипуляции:

*Онховерстартед*  ->  *Онманипулатионстартед*  ->  *Онманипулатионендед*  ->  *Онховерендед*

Если манипуляции нет, события наведения указателя по-прежнему будут выполняться в следующем порядке:

*Онховерстартед*  ->  *Онховерендед*

## <a name="physics-and-collisions"></a>Физика и конфликты

Поведение физикы можно включить, добавив компонент RigidBody в тот же объект, что и манипулятор объекта. Это позволяет не только включить настройку [поведения выпуска](#release-behavior) , но и конфликты. Без компонента RigidBody конфликт не работает должным образом во время манипуляции:

- Конфликты между управляемым объектом и статическим (т. е. объектом с конфликтующим, но без RigidBody) не работают, управляемый объект передается непосредственно через статический конфликт, не затронутый.
- Конфликты между управляемым объектом и RigidBody (т. е. Объект, имеющий как RigidBody, так и RigidBody, вызывает реагирование на конфликт, но отклики и неестественные ответы отходятся. В управляемом объекте также нет ответа на конфликт.

При добавлении RigidBody конфликты должны работать правильно.

### <a name="without-rigidbody"></a>Без RigidBody

<img src="../images/object-manipulator/MRTK_PhysicsManipulation_NoRigidbody.gif" width="500" alt="No Rigid Body">

### <a name="with-rigidbody"></a>С RigidBody

<img src="../images/object-manipulator/MRTK_PhysicsManipulation_Rigidbody.gif" width="500" alt="Rigid Body">

## <a name="elastics-experimental"></a>Эластичные (экспериментальные)

Эластичные объекты можно использовать при управлении объектами с помощью манипулятора объекта. Обратите внимание, что [система эластичных](../experimental/elastic-system.md) баз данных по-прежнему находится в экспериментальном состоянии. Для включения эластичных баз данных необходимо связать существующий компонент диспетчера эластичных баз данных или создать и связать новый диспетчер эластичных баз данных с помощью `Add Elastics Manager` кнопки.

<img src="../images/bounds-control/MRTK_BoundsControl_Elastics.png" width="450" alt="Bounds Control Elastics">

## <a name="see-also"></a>См. также:

- [Элемент управления Bounds](bounds-control.md)
- [Диспетчер ограничений](constraint-manager.md)
- [Окно миграции](../tools/migration-window.md)
- [Система эластичных БД (экспериментальная)](../experimental/elastic-system.md)
