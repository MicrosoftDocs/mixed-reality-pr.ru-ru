---
title: Обзор решателя
description: Обзор решателей в MRTK
author: CDiaz-MS
ms.author: cadia
ms.date: 01/12/2021
ms.localizationpriority: high
keywords: Unity, HoloLens, HoloLens 2, смешанная реальность, разработка, MRTK, решатели Solver,
ms.openlocfilehash: bf9bbfe578ace576fca8870f038f145037a6838d
ms.sourcegitcommit: f338b1f121a10577bcce08a174e462cdc86d5874
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/01/2021
ms.locfileid: "113176449"
---
# <a name="solver-overview"></a><span data-ttu-id="0a107-104">Обзор решателя</span><span class="sxs-lookup"><span data-stu-id="0a107-104">Solver overview</span></span>

![Решатель — главная](../../images/solver/MRTK_Solver_Main.png)

<span data-ttu-id="0a107-106">Решатели — это компоненты, которые упрощают вычисление положения и ориентации объекта в соответствии с предопределенным алгоритмом.</span><span class="sxs-lookup"><span data-stu-id="0a107-106">Solvers are components that facilitate the means of calculating an object's position & orientation according to a predefined algorithm.</span></span> <span data-ttu-id="0a107-107">Примером использования может быть расположение предмета на поверхности, на которую устремлен взгляд пользователя в конкретный момент.</span><span class="sxs-lookup"><span data-stu-id="0a107-107">An example may be placing an object on the surface the user's gaze raycast currently hits.</span></span>

<span data-ttu-id="0a107-108">Кроме того, система поиска решений детерминированно определяет порядок операций для этих вычислений преобразования, так как другого надежного способа указать для Unity порядок обновления компонентов как не существует.</span><span class="sxs-lookup"><span data-stu-id="0a107-108">Furthermore, the Solver system deterministically defines an order of operations for these transform calculations as there is no reliable way to specify to Unity the update order for components.</span></span>

<span data-ttu-id="0a107-109">Решатели предлагают ряд вариантов поведения для присоединения объектов к другим объектам или системам.</span><span class="sxs-lookup"><span data-stu-id="0a107-109">Solvers offer a range of behaviors to attach objects to other objects or systems.</span></span> <span data-ttu-id="0a107-110">Еще один пример — закрепленный объект, который парит перед пользователем (на основе положения камеры).</span><span class="sxs-lookup"><span data-stu-id="0a107-110">One other example would be a tag-along object that hovers in front of the user (based on the camera).</span></span> <span data-ttu-id="0a107-111">Решатель можно также подключить к контроллеру и объекту, чтобы закрепить объект у контроллера.</span><span class="sxs-lookup"><span data-stu-id="0a107-111">A solver could also be attached to a controller and an object to make the object tag-along the controller.</span></span> <span data-ttu-id="0a107-112">Все решатели можно безопасно собрать вместе, например, закрепление + поверхностный магнетизм + импульс.</span><span class="sxs-lookup"><span data-stu-id="0a107-112">All solvers can be safely stacked, for example a tag-along behavior + surface magnetism + momentum.</span></span>

## <a name="how-to-use-a-solver"></a><span data-ttu-id="0a107-113">Использование решателей</span><span class="sxs-lookup"><span data-stu-id="0a107-113">How to use a solver</span></span>

<span data-ttu-id="0a107-114">Система решателей состоит из трех категорий сценариев:</span><span class="sxs-lookup"><span data-stu-id="0a107-114">The Solver system consists of three categories of scripts:</span></span>

* <span data-ttu-id="0a107-115">[`Solver`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.Solver): базовый абстрактный класс, от которого наследуются все решатели.</span><span class="sxs-lookup"><span data-stu-id="0a107-115">[`Solver`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.Solver): The base abstract class that all solvers derive from.</span></span> <span data-ttu-id="0a107-116">Он обеспечивает отслеживание состояния, параметры сглаживания и их реализацию, автоматическую интеграцию системы решателей и порядок обновления.</span><span class="sxs-lookup"><span data-stu-id="0a107-116">It provides state tracking, smoothing parameters and implementation, automatic solver system integration, and update order.</span></span>
* <span data-ttu-id="0a107-117">[`SolverHandler`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.SolverHandler): задает опорный объект для отслеживания (например: трансформация основной камеры, телекинез и т. д.), обеспечивает сбор компонентов решателя и выполняет их обновление в нужном порядке.</span><span class="sxs-lookup"><span data-stu-id="0a107-117">[`SolverHandler`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.SolverHandler): Sets the reference object to track against (ex: the main camera transform, hand ray, etc.), handles gathering of solver components, and executes updating them in the proper order.</span></span>

<span data-ttu-id="0a107-118">Третья категория — это сам решатель.</span><span class="sxs-lookup"><span data-stu-id="0a107-118">The third category is the solver itself.</span></span> <span data-ttu-id="0a107-119">Стандартные блоки для основного поведения предоставляют следующие решатели:</span><span class="sxs-lookup"><span data-stu-id="0a107-119">The following solvers provide the building blocks for basic behavior:</span></span>

* <span data-ttu-id="0a107-120">[`Orbital`](#orbital): фиксирует определенную позицию и смещение относительно объекта, на который ссылается.</span><span class="sxs-lookup"><span data-stu-id="0a107-120">[`Orbital`](#orbital): Locks to a specified position and offset from the referenced object.</span></span>
* <span data-ttu-id="0a107-121">[`ConstantViewSize`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.ConstantViewSize): масштабируется, чтобы поддерживать постоянный размер относительно вида с объекта, на который ссылается.</span><span class="sxs-lookup"><span data-stu-id="0a107-121">[`ConstantViewSize`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.ConstantViewSize): Scales to maintain a constant size relative to the view of the referenced object.</span></span>
* <span data-ttu-id="0a107-122">[`RadialView`](#radialview): удерживает объект в конусе просмотра объекта, на который ссылается.</span><span class="sxs-lookup"><span data-stu-id="0a107-122">[`RadialView`](#radialview): Keeps the object within a view cone cast by the referenced object.</span></span>
* <span data-ttu-id="0a107-123">[`Follow`](#follow): удерживает объект внутри границ, заданных пользователем, объекта, на который ссылается.</span><span class="sxs-lookup"><span data-stu-id="0a107-123">[`Follow`](#follow): Keeps the object within a set of user defined bounds of the referenced object.</span></span>
* <span data-ttu-id="0a107-124">[`InBetween`](#inbetween): удерживает объект между двумя отслеживаемыми объектами.</span><span class="sxs-lookup"><span data-stu-id="0a107-124">[`InBetween`](#inbetween): Keeps an object in between two tracked objects.</span></span>
* <span data-ttu-id="0a107-125">[`SurfaceMagnetism`](#surfacemagnetism): направляет лучи на поверхности в мире и выравнивает объект по этой поверхности.</span><span class="sxs-lookup"><span data-stu-id="0a107-125">[`SurfaceMagnetism`](#surfacemagnetism): casts rays to surfaces in the world, and align the object to that surface.</span></span>
* <span data-ttu-id="0a107-126">[`DirectionalIndicator`](#directionalindicator): определяет положение и ориентацию объекта как индикатор направления.</span><span class="sxs-lookup"><span data-stu-id="0a107-126">[`DirectionalIndicator`](#directionalindicator): Determines the position and orientation of an object as a directional indicator.</span></span> <span data-ttu-id="0a107-127">С исходной позиции отслеживаемой цели SolverHandler этот индикатор будет ориентироваться на указанное целевое направление DirectionalTarget.</span><span class="sxs-lookup"><span data-stu-id="0a107-127">From the point of reference of the SolverHandler Tracked Target, this indicator will orient towards the DirectionalTarget supplied.</span></span>
* <span data-ttu-id="0a107-128">[`Momentum`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.Momentum): применяет ускорение, скорость или трение для моделирования импульса и упругости для объекта, перемещаемого другими решателями или компонентами.</span><span class="sxs-lookup"><span data-stu-id="0a107-128">[`Momentum`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.Momentum): Applies acceleration/velocity/friction to simulate momentum and springiness for an object being moved by other solvers/components.</span></span>
* <span data-ttu-id="0a107-129">[`HandConstraint`](#hand-menu-with-handconstraint-and-handconstraintpalmup): определяет, что объект должен следовать за руками в области, в которой GameObject и руки не пересекаются.</span><span class="sxs-lookup"><span data-stu-id="0a107-129">[`HandConstraint`](#hand-menu-with-handconstraint-and-handconstraintpalmup): Constrains object to follow hands in a region that doesn't intersect the GameObject with the hands.</span></span> <span data-ttu-id="0a107-130">Это может быть полезно для ограниченного интерактивного содержимого, такого как меню и т. д. Этот решатель предназначен для работы с контроллером [IMixedRealityHand](xref:Microsoft.MixedReality.Toolkit.Input.IMixedRealityHand), но работает и с [IMixedRealityController](xref:Microsoft.MixedReality.Toolkit.Input.IMixedRealityController).</span><span class="sxs-lookup"><span data-stu-id="0a107-130">Useful for hand constrained interactive content such as menus, etc. This solver is intended to work with [IMixedRealityHand](xref:Microsoft.MixedReality.Toolkit.Input.IMixedRealityHand) but also works with [IMixedRealityController](xref:Microsoft.MixedReality.Toolkit.Input.IMixedRealityController).</span></span>
* <span data-ttu-id="0a107-131">[`HandConstraintPalmUp`](#hand-menu-with-handconstraint-and-handconstraintpalmup): является производным от HandConstraint, но включает логику для проверки того, находится ли ладонь напротив пользователя перед активацией.</span><span class="sxs-lookup"><span data-stu-id="0a107-131">[`HandConstraintPalmUp`](#hand-menu-with-handconstraint-and-handconstraintpalmup): Derives from HandConstraint but includes logic to test if the palm is facing the user before activation.</span></span> <span data-ttu-id="0a107-132">Этот решатель работает только с контроллерами [IMixedRealityHand](xref:Microsoft.MixedReality.Toolkit.Input.IMixedRealityHand). С другими типами контроллеров этот решатель будет вести себя так же, как и его базовый класс.</span><span class="sxs-lookup"><span data-stu-id="0a107-132">This solver only works with [IMixedRealityHand](xref:Microsoft.MixedReality.Toolkit.Input.IMixedRealityHand) controllers, with other controller types this solver will behave just like its base class.</span></span>

<span data-ttu-id="0a107-133">Чтобы использовать систему решателей, просто добавьте один из перечисленных выше компонентов в GameObject.</span><span class="sxs-lookup"><span data-stu-id="0a107-133">In order to use the Solver system, simply add one of the components listed above to a GameObject.</span></span> <span data-ttu-id="0a107-134">Так как для всех решателей требуется сценарий [`SolverHandler`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.SolverHandler), он будет создан Unity автоматически.</span><span class="sxs-lookup"><span data-stu-id="0a107-134">Since all Solvers require a [`SolverHandler`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.SolverHandler), one will be created automatically by Unity.</span></span>

> [!NOTE]
> <span data-ttu-id="0a107-135">Примеры использования системы решателей можно найти в файле **SolverExamples.scene**.</span><span class="sxs-lookup"><span data-stu-id="0a107-135">Examples of how to use the Solvers system can be found in the **SolverExamples.scene** file.</span></span>

## <a name="how-to-change-tracking-reference"></a><span data-ttu-id="0a107-136">Изменение ссылки на отслеживание</span><span class="sxs-lookup"><span data-stu-id="0a107-136">How to change tracking reference</span></span>

<span data-ttu-id="0a107-137">Свойство *Tracked Target Type* (Тип отслеживаемой цели) компонента [`SolverHandler`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.SolverHandler) определяет позицию, которую будут использовать все решатели для вычисления своих алгоритмов.</span><span class="sxs-lookup"><span data-stu-id="0a107-137">The *Tracked Target Type* property of the [`SolverHandler`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.SolverHandler) component defines the point of reference all solvers will use to calculate their algorithms.</span></span> <span data-ttu-id="0a107-138">Например, тип значения [`Head`](xref:Microsoft.MixedReality.Toolkit.Utilities.TrackedObjectType.Head) с простым компонентом [`SurfaceMagnetism`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.SurfaceMagnetism) приведет к созданию луча от головы по направлению взгляда пользователя для решения задачи, на какую поверхность луч будет направлен.</span><span class="sxs-lookup"><span data-stu-id="0a107-138">For example, a value type of [`Head`](xref:Microsoft.MixedReality.Toolkit.Utilities.TrackedObjectType.Head) with a simple [`SurfaceMagnetism`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.SurfaceMagnetism) component will result in a raycast from the head and in the direction of the user's gaze for solving what surface is hit.</span></span> <span data-ttu-id="0a107-139">Возможные значения свойства `TrackedTargetType`:</span><span class="sxs-lookup"><span data-stu-id="0a107-139">Potential values for the `TrackedTargetType` property are:</span></span>

* <span data-ttu-id="0a107-140">*Head*: исходная позиция — преобразование основной камеры.</span><span class="sxs-lookup"><span data-stu-id="0a107-140">*Head* : Point of reference is the transform of the main camera</span></span>
* <span data-ttu-id="0a107-141">*ControllerRay*: исходной позицией является преобразование [`LinePointer`](xref:Microsoft.MixedReality.Toolkit.Input.LinePointer) на контроллере (т. е.</span><span class="sxs-lookup"><span data-stu-id="0a107-141">*ControllerRay*: Point of reference is the [`LinePointer`](xref:Microsoft.MixedReality.Toolkit.Input.LinePointer) transform on a controller (i.e</span></span> <span data-ttu-id="0a107-142">источник указателя на контроллере движения или ладони), указывающее направление линии лучей.</span><span class="sxs-lookup"><span data-stu-id="0a107-142">pointer origin on a motion controller or hand controller) pointing in the direction of the line ray</span></span>
  * <span data-ttu-id="0a107-143">Используйте свойство `TrackedHandedness` для выбора руки (т. е.</span><span class="sxs-lookup"><span data-stu-id="0a107-143">Use the `TrackedHandedness` property to select the handedness preference (i.e</span></span> <span data-ttu-id="0a107-144">левая, правая, обе).</span><span class="sxs-lookup"><span data-stu-id="0a107-144">Left, Right, Both)</span></span>
* <span data-ttu-id="0a107-145">*HandJoint*: исходной позицией является преобразование определенного сустава руки.</span><span class="sxs-lookup"><span data-stu-id="0a107-145">*HandJoint*: Point of reference is the transform of a specific hand joint</span></span>
  * <span data-ttu-id="0a107-146">Используйте свойство `TrackedHandedness` для выбора руки (т. е.</span><span class="sxs-lookup"><span data-stu-id="0a107-146">Use the `TrackedHandedness` property to select the handedness preference (i.e</span></span> <span data-ttu-id="0a107-147">левая, правая, обе).</span><span class="sxs-lookup"><span data-stu-id="0a107-147">Left, Right, Both)</span></span>
  * <span data-ttu-id="0a107-148">Используйте свойство `TrackedHandJoint`, чтобы определить, какое преобразование сустава нужно использовать.</span><span class="sxs-lookup"><span data-stu-id="0a107-148">Use the  `TrackedHandJoint` property to determine the joint transform to utilize</span></span>
* <span data-ttu-id="0a107-149">*CustomOverride*: исходная позиция из назначенного свойства `TransformOverride`.</span><span class="sxs-lookup"><span data-stu-id="0a107-149">*CustomOverride*: Point of reference from the assigned `TransformOverride`</span></span>

> [!NOTE]
> <span data-ttu-id="0a107-150">Для типов *ControllerRay* и *HandJoint* решатель сначала попытается обратиться к левому контроллеру или преобразованию руки, а затем к правому, если левая сторона недоступна или если в свойстве `TrackedHandedness` не указано иное.</span><span class="sxs-lookup"><span data-stu-id="0a107-150">For both *ControllerRay* and *HandJoint* types, the solver handler will attempt to provide the left controller/hand transform first and then the right if the former is not available or unless the `TrackedHandedness` property specifies otherwise.</span></span>

<span data-ttu-id="0a107-151">![Объект, отслеживаемый решателем](../../images/solver/TrackedObjectType-Example.gif) 
*Пример различных свойств, связанных с каждым TrackedTargetType*</span><span class="sxs-lookup"><span data-stu-id="0a107-151">![Solver Tracked Object](../../images/solver/TrackedObjectType-Example.gif) 
*Example of various properties associated with each TrackedTargetType*</span></span>

> [!IMPORTANT]
> <span data-ttu-id="0a107-152">Большинство решателей используют вектор, направленный вперед, для отслеживаемой цели преобразования, который предоставляется `SolverHandler`.</span><span class="sxs-lookup"><span data-stu-id="0a107-152">Most solvers use the forward vector of the tracked transform target supplied by the `SolverHandler`.</span></span> <span data-ttu-id="0a107-153">При использовании типа отслеживаемой цели *Hand Joint* вектор суставов ладони может указывать на пальцы, а не сквозь ладонь.</span><span class="sxs-lookup"><span data-stu-id="0a107-153">When using a *Hand Joint* tracked target type, the forward vector of the palm joint may point through the fingers and not through the palm.</span></span> <span data-ttu-id="0a107-154">Это зависит от платформы, предоставляющей данные о суставах руки.</span><span class="sxs-lookup"><span data-stu-id="0a107-154">This depends on the platform supplying the hand joint data.</span></span> <span data-ttu-id="0a107-155">Для симуляции входных данных и Windows Mixed Reality это *вектор вверх*, который указывает сквозь ладонь (т. е.</span><span class="sxs-lookup"><span data-stu-id="0a107-155">For input simulation and Windows Mixed Reality, it is the *up vector* that points up through the palm (i.e</span></span> <span data-ttu-id="0a107-156">зеленый вектор — вверх, синий вектор — вправо).</span><span class="sxs-lookup"><span data-stu-id="0a107-156">green vector is up, blue vector is forward).</span></span>
>
> ![Вектор вперед вверх](../../images/solver/HandJoint_ForwardUpVectors.png)
>
> <span data-ttu-id="0a107-158">Чтобы устранить это, обновите свойство *Additional Rotation* (Дополнительное вращение), указав значение `SolverHandler` **<90; 0; 0>** .</span><span class="sxs-lookup"><span data-stu-id="0a107-158">To overcome this, update the *Additional Rotation* property on the `SolverHandler` to **<90, 0, 0>**.</span></span> <span data-ttu-id="0a107-159">Это обеспечит направление вектора, подаваемого решателям, вперед через ладонь и обратно от руки.</span><span class="sxs-lookup"><span data-stu-id="0a107-159">This will ensure the forward vector supplied to solvers is pointing through the palm and outward away from the hand.</span></span>
>
> ![Дополнительное вращение](../../images/solver/SolverHandler_AdditionalRotation.png)
>
> <span data-ttu-id="0a107-161">Кроме того, можно использовать тип отслеживаемой цели *Controller Ray*, чтобы получить аналогичное поведение при указании направления с помощью рук.</span><span class="sxs-lookup"><span data-stu-id="0a107-161">Alternatively, use the *Controller Ray* tracked target type to get similar behavior for pointing with hands.</span></span>

## <a name="how-to-chain-solvers"></a><span data-ttu-id="0a107-162">Создание цепочки решателей</span><span class="sxs-lookup"><span data-stu-id="0a107-162">How to chain solvers</span></span>

<span data-ttu-id="0a107-163">Можно добавить несколько компонентов `Solver` в один и тот же GameObject, чтобы связать их алгоритмы.</span><span class="sxs-lookup"><span data-stu-id="0a107-163">It is possible to add multiple `Solver` components to the same GameObject thus chaining their algorithms.</span></span> <span data-ttu-id="0a107-164">Компоненты `SolverHandler` обрабатывают обновление всех решателей в одном GameObject.</span><span class="sxs-lookup"><span data-stu-id="0a107-164">The `SolverHandler` components handles updating all solvers on the same GameObject.</span></span> <span data-ttu-id="0a107-165">По умолчанию `SolverHandler` вызывает `GetComponents<Solver>()` при запуске, что будет возвращать решатели в том порядке, в котором они отображаются в инспекторе.</span><span class="sxs-lookup"><span data-stu-id="0a107-165">By default the `SolverHandler` calls `GetComponents<Solver>()` on Start which will return the Solvers in the order that they appear in the inspector.</span></span>

<span data-ttu-id="0a107-166">Более того, значение True для свойства *Updated Linked Transform* позволит `Solver` сохранить вычисленное положение, ориентацию и масштаб в промежуточную переменную, доступную всем решателям (т. е.</span><span class="sxs-lookup"><span data-stu-id="0a107-166">Furthermore, setting the *Updated Linked Transform* property to true will instruct that `Solver` to save its calculated position, orientation, & scale to an intermediary variable accessible by all Solvers (i.e</span></span> <span data-ttu-id="0a107-167">`GoalPosition`).</span><span class="sxs-lookup"><span data-stu-id="0a107-167">`GoalPosition`).</span></span> <span data-ttu-id="0a107-168">Если значение равно False, `Solver` обновляет преобразование GameObject напрямую.</span><span class="sxs-lookup"><span data-stu-id="0a107-168">When false, the `Solver` will update the GameObject's transform directly.</span></span> <span data-ttu-id="0a107-169">При сохранении свойств преобразования в промежуточном расположении другие решатели могут выполнять вычисления, начиная с промежуточной переменной.</span><span class="sxs-lookup"><span data-stu-id="0a107-169">By saving the transform properties to an intermediary location, other Solvers are able to perform their calculations starting from the intermediary variable.</span></span> <span data-ttu-id="0a107-170">Это обусловлено тем, что Unity не допускает обновления gameObject.Transform в стеке внутри одного кадра.</span><span class="sxs-lookup"><span data-stu-id="0a107-170">This is because Unity does not allow updates to gameObject.transform to stack within the same frame.</span></span>

> [!NOTE]
> <span data-ttu-id="0a107-171">Разработчики могут изменить порядок выполнения решателей, задав свойство `SolverHandler.Solvers` напрямую.</span><span class="sxs-lookup"><span data-stu-id="0a107-171">Developers can modify the order of execution of Solvers by setting the `SolverHandler.Solvers` property directly.</span></span>

## <a name="how-to-create-a-new-solver"></a><span data-ttu-id="0a107-172">Создание решателя</span><span class="sxs-lookup"><span data-stu-id="0a107-172">How to create a new solver</span></span>

<span data-ttu-id="0a107-173">Все решатели должны наследоваться от абстрактного базового класса [`Solver`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.Solver).</span><span class="sxs-lookup"><span data-stu-id="0a107-173">All solvers must inherit from the abstract base class, [`Solver`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.Solver).</span></span> <span data-ttu-id="0a107-174">Основные требования расширения решателей включают переопределение метода `SolverUpdate`.</span><span class="sxs-lookup"><span data-stu-id="0a107-174">The primary requirements of a Solver extension involves overriding the `SolverUpdate` method.</span></span> <span data-ttu-id="0a107-175">В этом методе разработчики должны обновить унаследованные свойства `GoalPosition`, `GoalRotation` и `GoalScale` до нужных значений.</span><span class="sxs-lookup"><span data-stu-id="0a107-175">In this method, developers should update the inherited `GoalPosition`, `GoalRotation` and `GoalScale` properties to the desired values.</span></span> <span data-ttu-id="0a107-176">Более того, обычно полезно использовать `SolverHandler.TransformTarget` в качестве системы отсчета, необходимой клиенту.</span><span class="sxs-lookup"><span data-stu-id="0a107-176">Furthermore, it is generally valuable to leverage `SolverHandler.TransformTarget` as the frame of reference desired by the consumer.</span></span>

<span data-ttu-id="0a107-177">Приведенный ниже код содержит пример нового компонента решателя `InFront`, который помещает присоединенный объект на 2 метра вперед от `SolverHandler.TransformTarget`.</span><span class="sxs-lookup"><span data-stu-id="0a107-177">The code provided below gives an example of a new Solver component called `InFront` that places the attached object 2m in front of the `SolverHandler.TransformTarget`.</span></span> <span data-ttu-id="0a107-178">Если объект `SolverHandler.TrackedTargetType` задан клиентом как [`Head`](xref:Microsoft.MixedReality.Toolkit.Utilities.TrackedObjectType.Head), тогда `SolverHandler.TransformTarget` будет преобразованием камеры, а этот решатель разместит присоединенный GameObject на расстоянии 2 м перед каждым кадром.</span><span class="sxs-lookup"><span data-stu-id="0a107-178">If the `SolverHandler.TrackedTargetType` is set by the consumer as [`Head`](xref:Microsoft.MixedReality.Toolkit.Utilities.TrackedObjectType.Head), then the `SolverHandler.TransformTarget` will be the camera transform and thus this Solver will place the attached GameObject 2m in front of the users' gaze every frame.</span></span>

```c#
/// <summary>
/// InFront solver positions an object 2m in front of the tracked transform target
/// </summary>
public class InFront : Solver
{
    ...

    public override void SolverUpdate()
    {
        if (SolverHandler != null && SolverHandler.TransformTarget != null)
        {
            var target = SolverHandler.TransformTarget;
            GoalPosition = target.position + target.forward * 2.0f;
        }
    }
}
```

## <a name="solver-implementation-guides"></a><span data-ttu-id="0a107-179">Руководства по реализации решателей</span><span class="sxs-lookup"><span data-stu-id="0a107-179">Solver implementation guides</span></span>

### <a name="common-solver-properties"></a><span data-ttu-id="0a107-180">Общие свойства решателей</span><span class="sxs-lookup"><span data-stu-id="0a107-180">Common solver properties</span></span>

<span data-ttu-id="0a107-181">Каждый компонент решателя имеет основной набор идентичных свойств, управляющих основным поведением решателя.</span><span class="sxs-lookup"><span data-stu-id="0a107-181">Every Solver component has a core-set of identical properties that control the core Solver behavior.</span></span>

<span data-ttu-id="0a107-182">Если включен параметр *Smoothing*, решатель постепенно обновит преобразование GameObject с учетом вычисленных значений.</span><span class="sxs-lookup"><span data-stu-id="0a107-182">If *Smoothing* is enabled, then the Solver will gradually update the transform of the GameObject over time to the calculated values.</span></span> <span data-ttu-id="0a107-183">Скорость этого изменения определяется свойством *LerpTime* каждого компонента преобразования.</span><span class="sxs-lookup"><span data-stu-id="0a107-183">The speed of this change is determined by every transform component's *LerpTime* property.</span></span> <span data-ttu-id="0a107-184">Например, более высокое значение *MoveLerpTime* приведет к более медленному приращению движения между кадрами.</span><span class="sxs-lookup"><span data-stu-id="0a107-184">For example, a higher *MoveLerpTime* value will result in slower increments in movement between frames.</span></span>

<span data-ttu-id="0a107-185">Если включен параметр *MaintainScale*, то решатель будет использовать локальный масштаб GameObject по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="0a107-185">If *MaintainScale* is enabled, then the Solver will utilize the GameObject's default local scale.</span></span>

<span data-ttu-id="0a107-186">![Основные свойства решателей](../../images/solver/GeneralSolverProperties.png)</span><span class="sxs-lookup"><span data-stu-id="0a107-186">![Core Solver Properties](../../images/solver/GeneralSolverProperties.png)</span></span>  
<span data-ttu-id="0a107-187">*Общие свойства, унаследованные всеми компонентами решателей*</span><span class="sxs-lookup"><span data-stu-id="0a107-187">*Common properties inherited by all Solver components*</span></span>

### <a name="orbital"></a><span data-ttu-id="0a107-188">Orbital</span><span class="sxs-lookup"><span data-stu-id="0a107-188">Orbital</span></span>

<span data-ttu-id="0a107-189">Класс [`Orbital`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.Orbital) является компонентом закрепления, который ведет себя как планеты в солнечной системе.</span><span class="sxs-lookup"><span data-stu-id="0a107-189">The [`Orbital`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.Orbital) class is a tag-along component that behaves like planets in a solar system.</span></span> <span data-ttu-id="0a107-190">Этот решатель обеспечит для присоединенных GameObject перемещение по орбите вокруг отслеживаемых преобразований.</span><span class="sxs-lookup"><span data-stu-id="0a107-190">This Solver will ensure the attached GameObject orbits around the tracked transform.</span></span> <span data-ttu-id="0a107-191">Таким образом, если для *типа отслеживаемой цели* [`SolverHandler`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.SolverHandler) задано значение [`Head`](xref:Microsoft.MixedReality.Toolkit.Utilities.TrackedObjectType.Head), то GameObject будет перемещаться по орбите вокруг головы пользователя с фиксированным смещением.</span><span class="sxs-lookup"><span data-stu-id="0a107-191">Thus, if the *Tracked Target Type* of the [`SolverHandler`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.SolverHandler) is set to [`Head`](xref:Microsoft.MixedReality.Toolkit.Utilities.TrackedObjectType.Head), then the GameObject will orbit around the user's head with a fixed offset applied.</span></span>

<span data-ttu-id="0a107-192">Разработчики могут изменить это фиксированное смещение для сохранения меню и других компонентов сцены на уровне взгляда или пояса и т. д. вокруг пользователя.</span><span class="sxs-lookup"><span data-stu-id="0a107-192">Developers can modify this fixed offset to keep menus or other scene components at eye-level or at waist level etc. around a user.</span></span> <span data-ttu-id="0a107-193">Это можно сделать, изменив свойства локального смещения *Local Offset* и смещения мира *World Offset*.</span><span class="sxs-lookup"><span data-stu-id="0a107-193">This is done by modifying the *Local Offset* and *World Offset* properties.</span></span> <span data-ttu-id="0a107-194">Свойство типа ориентации *Orientation Type* определяет поворот, применяемый к объекту: должен ли всегда сохраняться начальный поворот, поворот в камеру либо поворот на любой объект, определяемый преобразованием.</span><span class="sxs-lookup"><span data-stu-id="0a107-194">The *Orientation Type* property determines the rotation applied to the object if it should maintain its original rotation or always face the camera or face whatever transform is driving its position etc.</span></span>

<span data-ttu-id="0a107-195">![Пример Orbital](../../images/solver/OrbitalExample.png)</span><span class="sxs-lookup"><span data-stu-id="0a107-195">![Orbital Example](../../images/solver/OrbitalExample.png)</span></span>  
<span data-ttu-id="0a107-196">*Пример Orbital*</span><span class="sxs-lookup"><span data-stu-id="0a107-196">*Orbital example*</span></span>

### <a name="radialview"></a><span data-ttu-id="0a107-197">RadialView</span><span class="sxs-lookup"><span data-stu-id="0a107-197">RadialView</span></span>

<span data-ttu-id="0a107-198">[`RadialView`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.RadialView) — это еще один компонент с закреплением, который хранит определенную часть GameObject в усеченном конусе обзора пользователя.</span><span class="sxs-lookup"><span data-stu-id="0a107-198">The [`RadialView`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.RadialView) is another tag-along component that keeps a particular portion of a GameObject within the frustum of the user's view.</span></span>

<span data-ttu-id="0a107-199">Свойства *Min & Max View Degrees* (минимальный и максимальный угол обзора) определяют, как большая часть GameObject всегда отображается в представлении.</span><span class="sxs-lookup"><span data-stu-id="0a107-199">The *Min & Max View Degrees* properties determines how large of a portion of the GameObject must always be in view.</span></span>

<span data-ttu-id="0a107-200">Свойства *Min & Max Distance* (минимальное и максимальное расстояние) определяют, насколько далеко должен находиться объект GameObject от пользователя.</span><span class="sxs-lookup"><span data-stu-id="0a107-200">The *Min & Max Distance* properties determines how far the GameObject should be kept from the user.</span></span> <span data-ttu-id="0a107-201">Например, если подойти к объекту GameObject на расстояние *Min Distance* в 1 м, то GameObject будет отталкиваться от камеры, потому что он не должен приближаться к пользователю ближе, чем на 1 м.</span><span class="sxs-lookup"><span data-stu-id="0a107-201">For example, walking towards the GameObject with a *Min Distance* of 1m will push the GameObject away to ensure it is never closer than 1m to the user.</span></span>

<span data-ttu-id="0a107-202">Как правило, [`RadialView`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.RadialView) используется в сочетании с *типом отслеживаемой цели* [`Head`](xref:Microsoft.MixedReality.Toolkit.Utilities.TrackedObjectType.Head), чтобы компонент следовал за взглядом пользователя.</span><span class="sxs-lookup"><span data-stu-id="0a107-202">Generally, the [`RadialView`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.RadialView) is used in conjunction with *Tracked Target Type* set to [`Head`](xref:Microsoft.MixedReality.Toolkit.Utilities.TrackedObjectType.Head) so that the component follows the user's gaze.</span></span> <span data-ttu-id="0a107-203">Однако этот компонент может сохраняться в *представлении* любого *типа отслеживаемой цели*.</span><span class="sxs-lookup"><span data-stu-id="0a107-203">However, this component can function to be kept in *"view"* of any *Tracked Target Type*.</span></span>

<span data-ttu-id="0a107-204">![Пример RadialView](../../images/solver/RadialViewExample.png)</span><span class="sxs-lookup"><span data-stu-id="0a107-204">![RadialView Example](../../images/solver/RadialViewExample.png)</span></span>  
<span data-ttu-id="0a107-205">*Пример RadialView*</span><span class="sxs-lookup"><span data-stu-id="0a107-205">*RadialView example*</span></span>

### <a name="follow"></a><span data-ttu-id="0a107-206">Follow</span><span class="sxs-lookup"><span data-stu-id="0a107-206">Follow</span></span>

<span data-ttu-id="0a107-207">Класс [`Follow`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.Follow) размещает элемент перед отслеживаемой целью относительно ее локальной оси вперед.</span><span class="sxs-lookup"><span data-stu-id="0a107-207">The [`Follow`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.Follow) class positions an element in front of the of the tracked target relative to its local forward axis.</span></span> <span data-ttu-id="0a107-208">Элемент может быть слабо ограничен (то есть</span><span class="sxs-lookup"><span data-stu-id="0a107-208">The element can be loosely constrained (a.k.a.</span></span> <span data-ttu-id="0a107-209">закреплен), чтобы он не следовал за целью, пока она не переместится за пределы, указанные пользователем.</span><span class="sxs-lookup"><span data-stu-id="0a107-209">tag-along) so that it doesn't follow until the tracked target moves beyond user defined bounds.</span></span>

<span data-ttu-id="0a107-210">Он работает аналогично решателю RadialView и обладает дополнительными элементами для управления *максимальным горизонтальным и вертикальным углом* и механизмами изменения *ориентации* объекта.</span><span class="sxs-lookup"><span data-stu-id="0a107-210">It works similarly to the RadialView solver, with additional controls to manage *Max Horizontal & Vertical View Degrees*, and mechanisms to alter the *Orientation* of the object.</span></span>

<span data-ttu-id="0a107-211">![Свойства следования](../../images/solver/FollowExample.png)</span><span class="sxs-lookup"><span data-stu-id="0a107-211">![Follow properties](../../images/solver/FollowExample.png)</span></span>  
<span data-ttu-id="0a107-212">*Свойства следования*</span><span class="sxs-lookup"><span data-stu-id="0a107-212">*Follow properties*</span></span>

<span data-ttu-id="0a107-213">![Сцена с примером следования](../../images/solver/FollowExampleScene.gif)</span><span class="sxs-lookup"><span data-stu-id="0a107-213">![Follow example scene](../../images/solver/FollowExampleScene.gif)</span></span>  
<span data-ttu-id="0a107-214">*Сцена с примером следования (Assets/MRTK/Examples/Demos/Solvers/Scenes/FollowSolverExample.unity)*</span><span class="sxs-lookup"><span data-stu-id="0a107-214">*Follow Example Scene (Assets/MRTK/Examples/Demos/Solvers/Scenes/FollowSolverExample.unity)*</span></span>

### <a name="inbetween"></a><span data-ttu-id="0a107-215">InBetween</span><span class="sxs-lookup"><span data-stu-id="0a107-215">InBetween</span></span>

<span data-ttu-id="0a107-216">Класс [`InBetween`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.InBetween) удерживает присоединенный GameObject между двумя преобразованиями.</span><span class="sxs-lookup"><span data-stu-id="0a107-216">The [`InBetween`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.InBetween) class will keep the attached GameObject between two transforms.</span></span> <span data-ttu-id="0a107-217">Эти две конечные точки преобразования определяются *типом отслеживаемой цели* [`SolverHandler`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.SolverHandler) объекта GameObject и свойством *Second Tracked Target Type* (Тип второй отслеживаемой цели) компонента [`InBetween`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.InBetween).</span><span class="sxs-lookup"><span data-stu-id="0a107-217">These two transform endpoints are defined by the GameObject's own [`SolverHandler`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.SolverHandler) *Tracked Target Type* and the [`InBetween`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.InBetween) component's *Second Tracked Target Type* property.</span></span> <span data-ttu-id="0a107-218">Как правило, оба типа будут иметь значение [`CustomOverride`](xref:Microsoft.MixedReality.Toolkit.Utilities.TrackedObjectType.CustomOverride), а результирующие значения `SolverHandler.TransformOverride` и `InBetween.SecondTransformOverride` задаются для двух отслеживаемых конечных точек.</span><span class="sxs-lookup"><span data-stu-id="0a107-218">Generally, both types will be set to [`CustomOverride`](xref:Microsoft.MixedReality.Toolkit.Utilities.TrackedObjectType.CustomOverride) and the resulting `SolverHandler.TransformOverride` and `InBetween.SecondTransformOverride` values set to the two tracked endpoints.</span></span>

<span data-ttu-id="0a107-219">Во время выполнения компонент [`InBetween`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.InBetween) создаст другой компонент [`SolverHandler`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.SolverHandler) на основе *Second Tracked Target Type* и свойства *Second Transform Override*.</span><span class="sxs-lookup"><span data-stu-id="0a107-219">At runtime, the [`InBetween`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.InBetween) component will create another [`SolverHandler`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.SolverHandler) component based on the *Second Tracked Target Type* and *Second Transform Override* properties.</span></span>

<span data-ttu-id="0a107-220">`PartwayOffset` определяет, где на линии между двумя преобразованиями должен располагаться объект: 0,5 на половине пути, 1,0 на первом преобразовании и 0,0 на втором преобразовании.</span><span class="sxs-lookup"><span data-stu-id="0a107-220">The `PartwayOffset` defines where along the line between two transforms the object shall be placed with 0.5 as halfway, 1.0 at the first transform, and 0.0 at the second transform.</span></span>

<span data-ttu-id="0a107-221">![Пример InBetween](../../images/solver/InBetweenExample.png)</span><span class="sxs-lookup"><span data-stu-id="0a107-221">![InBetween Example](../../images/solver/InBetweenExample.png)</span></span>  
<span data-ttu-id="0a107-222">*Пример использования решателя InBetween для сохранения объекта между двумя преобразованиями*</span><span class="sxs-lookup"><span data-stu-id="0a107-222">*Example of using InBetween solver to keep object between two transforms*</span></span>

### <a name="surfacemagnetism"></a><span data-ttu-id="0a107-223">SurfaceMagnetism</span><span class="sxs-lookup"><span data-stu-id="0a107-223">SurfaceMagnetism</span></span>

<span data-ttu-id="0a107-224">[`SurfaceMagnetism`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.SurfaceMagnetism) работает путем создания луча на поверхностях, заданных LayerMask, и размещения GameObject в точке контакта.</span><span class="sxs-lookup"><span data-stu-id="0a107-224">The [`SurfaceMagnetism`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.SurfaceMagnetism) works by performing a raycast against a set LayerMask of surfaces and placing the GameObject at that point of contact.</span></span>

<span data-ttu-id="0a107-225">*Surface Normal Offset* (Смещение нормали поверхности) помещает GameObject на заданное расстояние на расстоянии в метрах от поверхности в направлении нормали в точке попадания на поверхности.</span><span class="sxs-lookup"><span data-stu-id="0a107-225">The *Surface Normal Offset* will place the GameObject a set distance in meters away from the surface in the direction of the normal at the hit point on the surface.</span></span>

<span data-ttu-id="0a107-226">И наоборот, *Surface Ray Offset* (Смещение луча поверхности) помещает GameObject на заданное расстояние в метрах от поверхности, но в противоположном направлении создания луча.</span><span class="sxs-lookup"><span data-stu-id="0a107-226">Conversely, the *Surface Ray Offset* will place the GameObject a set distance in meters away from the surface but in the opposite direction of the raycast performed.</span></span> <span data-ttu-id="0a107-227">Таким образом, если луч создается по взгляду пользователя, то GameObject будет передвигаться ближе к линии от точки попадания на поверхности в камеру.</span><span class="sxs-lookup"><span data-stu-id="0a107-227">Thus, if the raycast is the user's gaze, then the GameObject will move closer along the line from the hit point on the surface to the camera.</span></span>

<span data-ttu-id="0a107-228">*Orientation Mode* (Режим ориентации) определяет тип поворота, который необходимо применить к нормали на поверхности.</span><span class="sxs-lookup"><span data-stu-id="0a107-228">The *Orientation Mode* determines the type of rotation to apply in relation to the normal on the surface.</span></span>

* <span data-ttu-id="0a107-229">*None* — поворот не применяется.</span><span class="sxs-lookup"><span data-stu-id="0a107-229">*None* - No rotation applied</span></span>
* <span data-ttu-id="0a107-230">*TrackedTarget* — объект будет обращен к отслеживаемому преобразованию, движущему луч.</span><span class="sxs-lookup"><span data-stu-id="0a107-230">*TrackedTarget* - Object will face the tracked transform driving the raycast</span></span>
* <span data-ttu-id="0a107-231">*SurfaceNormal* — объект будет выравниваться по нормали в точке попадания на поверхности.</span><span class="sxs-lookup"><span data-stu-id="0a107-231">*SurfaceNormal* - Object will align based on normal at hit point on surface</span></span>
* <span data-ttu-id="0a107-232">*Blended* — объект будет выравниваться на основе нормали в точке попадания на поверхности и на основе обращения к отслеживаемому преобразованию.</span><span class="sxs-lookup"><span data-stu-id="0a107-232">*Blended* - Object will align based on normal at hit point on surface AND based on facing the tracked transform.</span></span>

<span data-ttu-id="0a107-233">Чтобы заставить связанный объект GameObject оставаться в вертикальном положении в любом режиме, кроме *None*, включите параметр *Keep Orientation Vertical* (Сохранять вертикальную ориентацию).</span><span class="sxs-lookup"><span data-stu-id="0a107-233">To force the associated GameObject to stay vertical in any mode other than *None*, enable *Keep Orientation Vertical*.</span></span>

> [!NOTE]
> <span data-ttu-id="0a107-234">Свойство *Orientation Blend* (Смешение ориентации) используется для управления балансом между факторами поворота, если *Orientation Mode* (Режим ориентации) установлен в значение *Blended* (Смешанная).</span><span class="sxs-lookup"><span data-stu-id="0a107-234">Use the *Orientation Blend* property to control the balance between rotation factors when *Orientation Mode* is set to *Blended*.</span></span> <span data-ttu-id="0a107-235">При значении 0,0 ориентация будет полностью управляться режимом *TrackedTarget*, а при значении 1,0 — режимом *SurfaceNormal*.</span><span class="sxs-lookup"><span data-stu-id="0a107-235">A value of 0.0 will have orientation entirely driven by *TrackedTarget* mode and a value of 1.0 will have orientation driven entirely by *SurfaceNormal*.</span></span>

![Пример SurfaceMagnetism](../../images/solver/SurfaceMagExample.png)

#### <a name="determining-what-surfaces-can-be-hit"></a><span data-ttu-id="0a107-237">Определение достигаемых поверхностей</span><span class="sxs-lookup"><span data-stu-id="0a107-237">Determining what surfaces can be hit</span></span>

<span data-ttu-id="0a107-238">При добавлении компонента [`SurfaceMagnetism`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.SurfaceMagnetism) в GameObject важно рассмотреть слой GameObject и его дочерних элементов, если они есть.</span><span class="sxs-lookup"><span data-stu-id="0a107-238">When adding a [`SurfaceMagnetism`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.SurfaceMagnetism) component to a GameObject, it is important to consider the layer of the GameObject and its children, if any have colliders.</span></span> <span data-ttu-id="0a107-239">Компонент работает, выполняя различные типы пускания лучей, чтобы определить, к какой поверхности они должны "примагнититься".</span><span class="sxs-lookup"><span data-stu-id="0a107-239">The component works by performing various types of raycasts to determine what surface to "magnet" itself against.</span></span> <span data-ttu-id="0a107-240">Если решатель GameObject имеет конфликт на одном из слоев, перечисленных в свойстве `MagneticSurfaces` `SurfaceMagnetism`, то луч, скорее всего, будет направлен сам на себя, в результате чего GameObject присоединится к своей собственной точке.</span><span class="sxs-lookup"><span data-stu-id="0a107-240">If the solver GameObject has a collider on one of the layers listed in the `MagneticSurfaces` property of `SurfaceMagnetism`, then the raycast will likely hit itself resulting in the GameObject attaching to its own collider point.</span></span> <span data-ttu-id="0a107-241">Такого поведения можно избежать, задав для основного GameObject и всех дочерних элементов слой *Ignore Raycast* (Игнорирование луча) или изменив массив `MagneticSurfaces` в LayerMask соответствующим образом.</span><span class="sxs-lookup"><span data-stu-id="0a107-241">This odd behavior can be avoided by setting the main GameObject and all children to the *Ignore Raycast* layer or modifying the `MagneticSurfaces` LayerMask array appropriately.</span></span>

<span data-ttu-id="0a107-242">И наоборот, [`SurfaceMagnetism`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.SurfaceMagnetism) GameObject не будет конфликтовать с областями на слое, не перечисленными в свойстве `MagneticSurfaces`.</span><span class="sxs-lookup"><span data-stu-id="0a107-242">Conversely, a [`SurfaceMagnetism`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.SurfaceMagnetism) GameObject will not collide with surfaces on a layer not listed in the `MagneticSurfaces` property.</span></span> <span data-ttu-id="0a107-243">Обычно рекомендуется размещать все нужные поверхности на выделенном слое (т. е.</span><span class="sxs-lookup"><span data-stu-id="0a107-243">It is generally recommended to place all desired surfaces on a dedicated layer (i.e</span></span> <span data-ttu-id="0a107-244">*Surfaces*) и присваивать свойству `MagneticSurfaces` значения только этого слоя.</span><span class="sxs-lookup"><span data-stu-id="0a107-244">*Surfaces*) and setting the `MagneticSurfaces` property to just this layer.</span></span>  <span data-ttu-id="0a107-245">Использование значений *default* (по умолчанию) или *everything* (все) может привести к тому, что компоненты пользовательского интерфейса или курсоры будут влиять на решатель.</span><span class="sxs-lookup"><span data-stu-id="0a107-245">Using *default* or *everything* may result in UI components or cursors contributing to the solver.</span></span>

<span data-ttu-id="0a107-246">Наконец, поверхности, расположенные дальше, чем указано в значении свойства `MaxRaycastDistance`, будут игнорироваться лучами `SurfaceMagnetism`.</span><span class="sxs-lookup"><span data-stu-id="0a107-246">Finally, surfaces farther than the `MaxRaycastDistance` property setting will be ignored by the `SurfaceMagnetism` raycasts.</span></span>

### <a name="directionalindicator"></a><span data-ttu-id="0a107-247">DirectionalIndicator</span><span class="sxs-lookup"><span data-stu-id="0a107-247">DirectionalIndicator</span></span>

<span data-ttu-id="0a107-248">Класс [`DirectionalIndicator`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.DirectionalIndicator) является компонентом закрепления, который ориентируется в направлении нужной точки в пространстве.</span><span class="sxs-lookup"><span data-stu-id="0a107-248">The [`DirectionalIndicator`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.DirectionalIndicator) class is a tag-along component that orients itself to the direction of a desired point in space.</span></span>

<span data-ttu-id="0a107-249">Он чаще всего используется, если для *типа отслеживаемой цели* [`SolverHandler`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.SolverHandler) задано значение [`Head`](xref:Microsoft.MixedReality.Toolkit.Utilities.TrackedObjectType.Head).</span><span class="sxs-lookup"><span data-stu-id="0a107-249">Most commonly used when the *Tracked Target Type* of the [`SolverHandler`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.SolverHandler) is set to [`Head`](xref:Microsoft.MixedReality.Toolkit.Utilities.TrackedObjectType.Head).</span></span> <span data-ttu-id="0a107-250">Таким образом, компонент UX с решателем [`DirectionalIndicator`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.DirectionalIndicator) будет направлять пользователя на нужную точку в пространстве.</span><span class="sxs-lookup"><span data-stu-id="0a107-250">In this fashion, a UX component with the [`DirectionalIndicator`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.DirectionalIndicator)  solver will direct a user to look at the desired point in space.</span></span>

<span data-ttu-id="0a107-251">Требуемая точка в пространстве определяется с помощью свойства *Directional Target* (Целевое направление).</span><span class="sxs-lookup"><span data-stu-id="0a107-251">The desired point in space is determined via the *Directional Target* property.</span></span>

<span data-ttu-id="0a107-252">Если целевое направление доступно для просмотра пользователю или в [`SolverHandler`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.SolverHandler) установлен какой-либо кадр позиции, решатель отключит все компоненты [`Renderer`](https://docs.unity3d.com/ScriptReference/Renderer.html) под ним.</span><span class="sxs-lookup"><span data-stu-id="0a107-252">If the directional target is viewable by the user, or whatever frame of reference is set in the [`SolverHandler`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.SolverHandler), then this solver will disable all [`Renderer`](https://docs.unity3d.com/ScriptReference/Renderer.html) components underneath it.</span></span> <span data-ttu-id="0a107-253">Если направление не отображается, на индикаторе будет включено все.</span><span class="sxs-lookup"><span data-stu-id="0a107-253">If not viewable, then everything will be enabled on the indicator.</span></span>

<span data-ttu-id="0a107-254">Чем ближе пользователь будет к появлению *точки целевого направления* в поле зрения, тем меньше будет индикатор.</span><span class="sxs-lookup"><span data-stu-id="0a107-254">The size of the indicator will shrink the closer the user is to capturing the *Directional Target* in their FOV.</span></span>

* <span data-ttu-id="0a107-255">*Min Indicator Scale* — минимальный масштаб для объекта индикатора.</span><span class="sxs-lookup"><span data-stu-id="0a107-255">*Min Indicator Scale* - The minimum scale for the indicator object</span></span>
* <span data-ttu-id="0a107-256">*Max Indicator Scale* — максимальный масштаб для объекта индикатора.</span><span class="sxs-lookup"><span data-stu-id="0a107-256">*Max Indicator Scale* - The maximum scale for the indicator object</span></span>

* <span data-ttu-id="0a107-257">*Visibility Scale Factor* — множитель для увеличения или уменьшения поля зрения, который определяет, где становится доступна точка *целевого направления*.</span><span class="sxs-lookup"><span data-stu-id="0a107-257">*Visibility Scale Factor* - Multiplier to increase or decrease the FOV that determines if the *Directional Target* point is viewable or not</span></span>
* <span data-ttu-id="0a107-258">*View Offset* — с точки зрения кадра позиции (т. е.</span><span class="sxs-lookup"><span data-stu-id="0a107-258">*View Offset* - From the viewpoint of the frame of reference (i.e</span></span> <span data-ttu-id="0a107-259">возможно, самой камеры) это свойство определяет, насколько далеко в направлении индикатора должен находиться объект из центра окна просмотра.</span><span class="sxs-lookup"><span data-stu-id="0a107-259">camera possibly), this property defines how far in the indicator direction should the object be from the center of the viewport.</span></span>

<span data-ttu-id="0a107-260">![Свойства индикатора направления](../../images/solver/DirectionalIndicatorExample.png)</span><span class="sxs-lookup"><span data-stu-id="0a107-260">![Directional Indicator properties](../../images/solver/DirectionalIndicatorExample.png)</span></span>  
<span data-ttu-id="0a107-261">*Свойства индикатора направления*</span><span class="sxs-lookup"><span data-stu-id="0a107-261">*Directional Indicator properties*</span></span>

<span data-ttu-id="0a107-262">![Сцена с примером индикатора направления](../../images/solver/DirectionalIndicatorExampleScene.gif)</span><span class="sxs-lookup"><span data-stu-id="0a107-262">![Directional Indicator example scene](../../images/solver/DirectionalIndicatorExampleScene.gif)</span></span>  
<span data-ttu-id="0a107-263">*Сцена с примером индикатора направления (Assets/MRTK/Examples/Demos/Solvers/Scenes/DirectionalIndicatorSolverExample.unity)*</span><span class="sxs-lookup"><span data-stu-id="0a107-263">*Directional Indicator Example Scene (Assets/MRTK/Examples/Demos/Solvers/Scenes/DirectionalIndicatorSolverExample.unity)*</span></span>

### <a name="hand-menu-with-handconstraint-and-handconstraintpalmup"></a><span data-ttu-id="0a107-264">Меню руки с HandConstraint и HandConstraintPalmUp</span><span class="sxs-lookup"><span data-stu-id="0a107-264">Hand menu with HandConstraint and HandConstraintPalmUp</span></span>

![Пример интерфейса меню руки](../../images/solver/MRTK_UX_HandMenu.png)

<span data-ttu-id="0a107-266">[`HandConstraint`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.HandConstraint) предоставляет решатель, который ограничивает отслеживаемый объект областью, безопасной для содержимого, ограничиваемого руками (например, пользовательский интерфейс, меню и т. д.).</span><span class="sxs-lookup"><span data-stu-id="0a107-266">The [`HandConstraint`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.HandConstraint) behavior provides a solver that constrains the tracked object to a region safe for hand constrained content (such as hand UI, menus, etc).</span></span> <span data-ttu-id="0a107-267">Безопасными считаются области, которые не пересекаются с рукой.</span><span class="sxs-lookup"><span data-stu-id="0a107-267">Safe regions are considered areas that don't intersect with the hand.</span></span> <span data-ttu-id="0a107-268">Производный класс [`HandConstraint`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.HandConstraint), вызываемый [`HandConstraintPalmUp`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.HandConstraintPalmUp), также включен для демонстрации общего поведения активации объекта, отслеживаемого решателем, когда ладонь обращена к пользователю.</span><span class="sxs-lookup"><span data-stu-id="0a107-268">A derived class of [`HandConstraint`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.HandConstraint) called [`HandConstraintPalmUp`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.HandConstraintPalmUp) is also included to demonstrate a common behavior of activating the solver tracked object when the palm is facing the user.</span></span>

<span data-ttu-id="0a107-269">[См. страницу меню руки Hand Menu](../hand-menu.md), на которой приведены примеры использования решателей для ограничения руки (Hand Constraint) для создания меню.</span><span class="sxs-lookup"><span data-stu-id="0a107-269">[Please see Hand Menu page](../hand-menu.md) for the examples of using Hand Constraint solver to create hand menus.</span></span>

## <a name="see-also"></a><span data-ttu-id="0a107-270">См. также</span><span class="sxs-lookup"><span data-stu-id="0a107-270">See also</span></span>

* [<span data-ttu-id="0a107-271">Отслеживание рук</span><span class="sxs-lookup"><span data-stu-id="0a107-271">Hand Tracking</span></span>](../../input/hand-tracking.md)
* [<span data-ttu-id="0a107-272">Взгляд</span><span class="sxs-lookup"><span data-stu-id="0a107-272">Gaze</span></span>](../../input/gaze.md)
