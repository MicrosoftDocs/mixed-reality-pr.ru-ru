---
title: Критические изменения
description: Политика в отношении критических изменений в МРТК.
author: polar-kev
ms.author: kesemple
ms.date: 01/12/2021
keywords: Unity, HoloLens, HoloLens 2, смешанная реальность, разработка, MRTK
ms.openlocfilehash: 713cb5a0965d713c7073004059218ab2ab37201d
ms.sourcegitcommit: 8b4c2b1aac83bc8adf46acfd92b564f899ef7735
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 06/30/2021
ms.locfileid: "113121552"
---
# <a name="breaking-changes"></a>Критические изменения

Потребители МРТК зависят от наличия стабильной поверхности API выпуска в выпуске, чтобы они могли получать обновления для МРТК, не требуя при этом значительных критических изменений.

На этой странице описывается текущая политика, относящаяся к критическим изменениям в МРТК, а также некоторые более продолжительные цели, позволяющие лучше управлять компромиссом между поддержанием критических изменений и возможностью внесения верных технических изменений в код.

## <a name="what-is-a-breaking-change"></a>Что такое критическое изменение?

Изменение является критическим изменением, если оно удовлетворяет любому из условий в [списке a](#list-a) и удовлетворяет всем условиям в [списке б](#list-b) .

### <a name="list-a"></a>Список A

- Добавление, удаление или обновление любого члена или функции любого интерфейса (или удаление или переименование всего интерфейса).
- Удаление, обновление (изменение типа/определения, создание закрытого или внутреннего) любого защищенного или открытого члена или функции класса. (или удаление или переименование всего класса).
- Изменение в порядке событий, инициированных классом.
- Переименование любых частных Сериализедфиелд (без соответствующего тега Формерлисериализедас) или общего свойства в Скриптаблеобжект (особенно изменения в профилях).
- Изменение типа поля в Скриптаблеобжект (особенно изменения в профилях).
- Обновляет пространство имен или асмдефс любого класса или интерфейса.
- Удаление любого prefab или удаление скрипта в объекте верхнего уровня prefab.

### <a name="list-b"></a>Список B

- Рассматриваемый ресурс находится в основном пакете (т. е. Он находится в одной из следующих папок):

  - МРТК/Core
  - МРТК/providers/
  - МРТК/Services/
  - МРТК/SDK/
  - МРТК и расширения

- Рассматриваемый ресурс не принадлежит экспериментальному пространству имен.

> [!IMPORTANT]
> Любой ресурс, находящийся в пакете примеров (т. е. часть МРТК/examples/Folder), может быть изменен в любое время, так как ресурсы, предназначенные для копирования и просмотра потребителями в качестве эталонных реализаций, но не являются частью основного набора API-интерфейсов и ресурсов. Ресурсы в экспериментальном пространстве имен (или более общедоступные функции, помеченные как экспериментальные) — это те, которые публикуются перед выполнением комплексной экспертизы (т. е. тесты, итерации UX, документация) и публикуются раньше, чтобы получать отзывы быстрее.  Тем не менее, поскольку у них нет тестов и документации, и, так как мы, скорее всего, не заполагали все взаимодействия и разработки, мы публикуем их в состоянии, где общедоступная версия должна предположить, что они могут и изменяться (т. е. будут изменены, полностью удалены и т. д.).
>
> Дополнительные сведения см. в разделе [экспериментальные функции](../contributing/experimental-features.md) .

Так как контактная зона для критических изменений очень велика, важно отметить, что наличие абсолютного правила, в котором указано «без критических изменений», может быть невозможным — могут возникнуть проблемы, которые могут быть устранены только в разумномм случае путем внесения критических изменений. Чтобы разместить другой способ, единственным способом, который можно было бы получить без критических изменений, является отсутствие изменений.

Наша политика заключается в том, чтобы избежать внесения критических изменений, если это возможно, и сделать это только в том случае, если изменение начисляется значительным значением долгосрочного клиента или инфраструктуры.

## <a name="what-to-do-about-breaking-changes"></a>Что делать с критическими изменениями

Если вы можете выполнить что-то без критического изменения и без ущерба для долгосрочной структуры и жизнеспособности этой функции, не следует выполнять критические изменения. Если других способов нет, то текущая политика должна оценивать каждое отдельное коренное изменение, чтобы понять, что преимущество от изменения приводит к увеличению затрат на потребителя при внесении изменений. Спор о том, что стоит делать, а что обычно не происходит с самим рассказом о вопросе или выпуске.

Что может произойти в нескольких контейнерах:

### <a name="the-breaking-change-adds-value-but-could-be-written-in-a-way-that-isnt-breaking"></a>Критическое изменение добавляет значение, но может быть записано способом, который не является критическим

Например, при [добавлении новой](https://github.com/microsoft/MixedRealityToolkit-Unity/pull/4882) функции, которая изначально была написана с нарушением, он изменил существующий интерфейс, но затем перезаписался, когда функция была разбивается как на свой собственный интерфейс. Как правило, это наилучший результат. Не пытайтесь принудительно внести изменения в неразрывную форму, если это нарушит долгосрочную жизнеспособность или структуру функции.

### <a name="the-breaking-change-adds-sufficient-value-to-the-customer-that-its-worth-doing"></a>Критическое изменение добавляет достаточное значение к клиенту, что стоит делать.

Задокументируйте, что такое критические изменения, и предоставьте лучшие решения по устранению (т. е. инструкции по переносу или более качественные средства, которые будут автоматически перенесены для клиента). В каждом выпуске может содержаться небольшой объем незавершенных изменений — они всегда должны быть документированы в документах, как это было сделано в [этом](https://github.com/microsoft/MixedRealityToolkit-Unity/pull/4858)запросе. Если у вас уже есть инструкция по миграции 2. x. x → 2. x +1. x + 1, добавьте инструкции или инструментарий в этот документ. Если он не существует, создайте его.

### <a name="the-breaking-change-adds-value-but-the-customer-pain-would-be-too-high"></a>Критическое изменение увеличивает значение, но клиент может быть слишком высоким.

Не все типы критических изменений создаются одинаково — некоторые из них значительно более сложны, чем другие, в зависимости от нашего опыта и опыта работы с клиентами. Например, изменения в интерфейсах могут оказаться непростыми, но если критически важное изменение является одним из тех, в котором клиент вряд ли будет расширен или реализован в прошлом (например, в системе диагностического представления), фактические затраты, скорее всего, не будут. Однако если изменение является типом поля в Скриптаблеобжект (например, в одном из основных профилей МРТК), это, скорее всего, приведет к значительному сбою клиента. Клиенты уже выполнили клонирование профиля по умолчанию, возможность слияния и обновления профилей может быть очень трудной для ручного выполнения (т. е. через текстовый редактор во время слияния), а повторное копирование профиля по умолчанию и перенастройки всех вручную может привести к сложному отладке регрессий.

Эти изменения необходимо вернуть в полку до тех пор, пока не будет создана ветвь, которая позволит значительно радикально внести изменения (вместе с существенным значением, которое предоставит клиентам причину обновления). Такая ветвь в настоящее время не существует. В будущих собраниях по планированию итераций мы рассмотрим набор изменений и проблем, которые оказались слишком недостаточными, чтобы узнать, не был ли достигнут важный объем, чтобы сделать все более разумными. Обратите внимание, что небезопасно выработать ветвь "все разрешено" без комплексной экспертизы из-за ограниченных ресурсов проектирования, и тот факт, что нам пришлось бы разделить тестирование и проверку на этих двух. Должна быть четко назначенная и хорошо связанная Дата начала и окончания такой ветви, когда она существует.

## <a name="long-term-management-of-breaking-changes"></a>Долгосрочное управление критическими изменениями

В долгосрочной перспективе следует попытаться уменьшить область действия, что является критическим изменением, увеличив набор условий в [списке б](#list-b). Пересылка набора объектов в [списке A](#list-a) всегда будет полностью прерываться для набора файлов и ресурсов, которые мы считали общедоступной поверхностью API. Способ, который мы можем сделать более удобной для итерации (т. е. изменяя сведения о внутренней реализации, позволяя упростить рефакторинг и совместное использование кода между несколькими классами и т. д.), — более явное обсуждение того, какие части кода являются официальной поверхностью, а не сведения о реализации.

Еще одна вещь, которую мы уже сделали, — это понятие «экспериментального» (оно принадлежит экспериментальному пространству имен), оно может не иметь тестов или документации и открыто, но может быть удалено и Обновлено без предупреждения. Это дает возможность добавить новые функции раньше, чтобы получить более раннюю обратную связь, но не быть немедленно привязана к своей поверхности API (так как мы не можем полностью представить поверхность API).

### <a name="other-examples-of-things-that-could-help-in-the-future"></a>Другие примеры действий, которые могут помочь в будущем

- Использование [ключевого слова Internal](/dotnet/csharp/language-reference/keywords/internal).
  Это позволит нам использовать общий код в собственных сборках (для сокращения дублирования кода), не делая их общедоступными для внешних потребителей.
- Создание "внутреннего" пространства имен (т. е. Microsoft. Микседреалити. Toolkit. internal. Utilities), в котором мы публично задокументированы, что все, что содержится в этом внутреннем пространстве имен, может быть изменено в любое время, а также удалять и т. д. Это похоже на то, как библиотеки заголовков C++ будут использовать пространства имен:: Internal для скрытия сведений о реализации.