---
title: Системы координат в Unity
description: Узнайте, как создавать смешанные, приработающие, масштабируемые и масштабируемые возможности в Unity.
author: thetuvix
ms.author: alexturn
ms.date: 02/24/2019
ms.topic: article
keywords: система координат, пространственный система координат, только ориентация, установленный масштаб, фиксированный масштаб, комната. масштабирование, мировое масштабирование, 360 градусов, помещение, размещение, помещение, мир, масштабирование, положение, ориентация, Unity, привязка, пространственное привязку, прикрепление, блокировка мира, блокировка по всему миру, блокировки текста, Блокировка текста, блокировка в мире, с потерей данных, локатабилити, границы, перецентрирование, гарнитура смешанной реальности, головной телефон
ms.openlocfilehash: 91b1adf6dcf1c54d0d29a02bfb97ac4674a87c88
ms.sourcegitcommit: 3e36b2fbbcc250c49aaf8ca1b6133cf0e9db69fa
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/16/2021
ms.locfileid: "107528747"
---
# <a name="coordinate-systems-in-unity"></a>Системы координат в Unity

Windows Mixed Reality поддерживает приложения в различных масштабах, начиная с приложений с ориентацией на страницы и до крупномасштабных приложений. В HoloLens вы можете создавать приложения для мирового уровня, которые позволяют пользователям проходить более чем за 5 метров, изучая целый ряд здания и выходят за рамки.

Первым шагом в создании смешанной реальности в Unity является понимание [систем координат и выбор масштаба работы](../../design/coordinate-systems.md) приложения.

## <a name="building-an-orientation-only-or-seated-scale-experience"></a>Создание интерфейса, поддерживающего только ориентацию, или с возможностями масштабирования

**Пространство имен:** *UnityEngine. XR*<br>
**Тип:** *ксрдевице*

Чтобы создать **интерфейс с горизонтальной** **ориентацией** или с возможностями масштабирования, необходимо задать Unity как стационарный тип пространства отслеживания. Стационарное пространство отслеживания. устанавливает мировую систему координат Unity для отслеживания [стационарной рамки ссылки](../../design/coordinate-systems.md#spatial-coordinate-systems). В режиме нестационарного отслеживания содержимое, помещенное в редактор непосредственно перед расположением по умолчанию камеры (переадресация — Z), будет отображаться перед пользователем при запуске приложения.

```cs
XRDevice.SetTrackingSpaceType(TrackingSpaceType.Stationary);
```

**Пространство имен:** *UnityEngine. XR*<br>
**Тип:** *инпуттраккинг*

Для чистой **ориентации** , такой как видео-средство просмотра 360 (если позиционированные головные обновления насмарку иллюзию), можно установить [XR. Инпуттраккинг. Дисаблепоситионалтраккинг](https://docs.unity3d.com/ScriptReference/XR.InputTracking-disablePositionalTracking.html) имеет значение true:

```cs
InputTracking.disablePositionalTracking = true;
```

Для **работы с возможностями масштабирования**, чтобы пользователь мог позже изменить центр исходного места, можно вызвать [XR. Метод Инпуттраккинг. recenter](https://docs.unity3d.com/ScriptReference/XR.InputTracking.Recenter.html) :

```cs
InputTracking.Recenter();
```

## <a name="building-a-standing-scale-or-room-scale-experience"></a>Создание фиксированного масштаба или возможностей для масштабирования комнаты

**Пространство имен:** *UnityEngine. XR*<br>
**Тип:** *ксрдевице*

Для работы с фиксированным **масштабированием** или **комнатным масштабированием** необходимо разместить содержимое относительно основания. Вы указываете на этаж пользователя с помощью **[пространственного этапа](../../design/coordinate-systems.md#spatial-coordinate-systems)**, который представляет определенное пользователем происхождение на уровне пола и дополнительную границу комнаты, настраивается во время первого запуска.

Чтобы обеспечить работу Unity с своей мировой системой координат на уровне пола, можно установить и проверить, что Unity использует тип пространства отслеживания Румскале:

```cs
if (XRDevice.SetTrackingSpaceType(TrackingSpaceType.RoomScale))
{
    // RoomScale mode was set successfully.  App can now assume that y=0 in Unity world coordinate represents the floor.
}
else
{
    // RoomScale mode was not set successfully.  App cannot make assumptions about where the floor plane is.
}
```
* Если Сеттраккингспацетипе возвращает значение true, Unity успешно переключил свою систему координат мира для мониторинга [промежуточного кадра ссылки](../../design/coordinate-systems.md#spatial-coordinate-systems).
* Если Сеттраккингспацетипе возвращает значение false, Unity не смог переключиться на промежуточный кадр ссылки, скорее всего потому, что пользователь не настроил этаж в своей среде. Хотя возвращаемое значение false не является распространенным, оно может произойти, если этап настраивается в другой комнате, и устройство перемещается в текущую комнату без настройки нового этапа пользователем.

После того как приложение успешно установит тип пространства отслеживания Румскале, на этаж будут отображаться содержимое, помещенное на плоскости y = 0. Источник 0, 0, 0 будет определять конкретное место в этаже, где пользователь стояли во время настройки комнаты, с параметром-Z, который соответствует направлению вперед во время установки.

**Пространство имен:** *UnityEngine. ЭКСПЕРИМЕНТАЛЬно. XR*<br>
**Тип:** *граница*

В коде скрипта можно вызвать метод Трижетжеометри для типа UnityEngine. экспериментального. XR. граница, чтобы получить границу границы, указав тип границы Траккедареа. Если пользователь определил границу (вы получаете список вершин), вы можете легко предоставить пользователю **возможности масштабирования комнаты** , где они могут пройти по создаваемой сцене.

> [!NOTE]
> Система автоматически визуализирует границу, когда пользователь его приближает. Приложению не нужно использовать этот многоугольник для отрисовки самой границы. Тем не менее можно выбрать размещение объектов сцены с помощью этого многоугольника, чтобы гарантировать, что пользователь сможет физически достичь этих объектов без переноса.

```cs
var vertices = new List<Vector3>();
if (UnityEngine.Experimental.XR.Boundary.TryGetGeometry(vertices, Boundary.Type.TrackedArea))
{
    // Lay out your app's content within the boundary polygon, to ensure that users can reach it without teleporting.
}
```

## <a name="building-a-world-scale-experience"></a>Создание возможностей для мирового масштабирования

**Пространство имен:** *UnityEngine. XR. WSA*<br>
**Тип:** *ворлданчор*

Для полноценного **крупномасштабного взаимодействия** в HoloLens, который позволяет пользователям рыскающего более 5 метров, вам потребуются новые методы, кроме тех, которые используются для работы с масштабом комнаты. Одной из ключевых методик, которую вы будете использовать, является создание [пространственной привязки](../../design/coordinate-systems.md#spatial-anchors) для блокировки кластера голограмм, точно на месте физического мира, независимо от того, на каком расстояние перемещен пользователь, а затем [снова находит эти голограммы в последующих сеансах](../../design/coordinate-systems.md#spatial-anchor-persistence).

В Unity вы создаете пространственное привязку, добавив компонент Unity **ворлданчор** в GameObject.

### <a name="adding-a-world-anchor"></a>Добавление универсальной привязки

Чтобы добавить привязку к мировому объекту, вызовите метод AddComponent <WorldAnchor> () для игрового объекта с преобразованием, которое необходимо привязать в реальном мире.

```cs
WorldAnchor anchor = gameObject.AddComponent<WorldAnchor>();
```

Вот и все! Этот объект игры теперь будет привязан к его текущему расположению в физическом мире. Вы можете увидеть, что его координаты Unity могут немного измениться с течением времени, чтобы обеспечить физическое выравнивание. Используйте [сохраняемость](persistence-in-unity.md) для повторного нахождения этого привязанного расположения в следующем сеансе приложения.

### <a name="removing-a-world-anchor"></a>Удаление универсальной привязки

Если вы больше не хотите, чтобы GameObject заблокировались в физическом расположении и не планировали перемещать его, то можно просто вызвать Destroy в компоненте «Универсальная привязка».

```cs
Destroy(gameObject.GetComponent<WorldAnchor>());
```

Если вы хотите переместить GameObject этот кадр, необходимо вызвать Дестройиммедиате.

```cs
DestroyImmediate(gameObject.GetComponent<WorldAnchor>());
```

### <a name="moving-a-world-anchored-gameobject"></a>Перемещение привязанного GameObject по всему миру

GameObject нельзя переместить, пока на нем есть универсальная привязка. Если вам нужно переместить GameObject этот кадр, сделайте следующее:
1. Дестройиммедиате компонент «мировая привязка»
2. Перемещение GameObject
3. Добавьте новый компонент универсальной привязки к GameObject.

```cs
DestroyImmediate(gameObject.GetComponent<WorldAnchor>());
gameObject.transform.position = new Vector3(0, 0, 2);
WorldAnchor anchor = gameObject.AddComponent<WorldAnchor>();
```

### <a name="handling-locatability-changes"></a>Обработка изменений Локатабилити

Ворлданчор не может быть размещаемые в физическом мире на момент времени. В таком случае Unity не будет обновлять преобразование привязанного объекта. Это также можно изменить во время работы приложения. Сбой при обработке изменения в локатабилити приведет к тому, что объект не будет отображаться в правильном физическом расположении в мире.

Чтобы получать уведомления об изменениях локатабилити:
1. Подпишитесь на событие Онтраккингчанжед
2. Обработайте событие

Событие **онтраккингчанжед** будет вызываться при каждом изменении базовой пространственной привязки между состояниями размещаемые и not размещаемые.

```cs
anchor.OnTrackingChanged += Anchor_OnTrackingChanged;
```

Затем обработайте событие:

```cs
private void Anchor_OnTrackingChanged(WorldAnchor self, bool located)
{
    // This simply activates/deactivates this object and all children when tracking changes
    self.gameObject.SetActiveRecursively(located);
}
```

Иногда привязки размещаются немедленно. В этом случае для этого свойства объекта привязки будет задано значение true, если функция AddComponent <WorldAnchor> () возвращает. В результате событие Онтраккингчанжед не будет запущено. Чистый шаблон будет вызывать обработчик Онтраккингчанжед с начальным состоянием после присоединения привязки.

```cs
Anchor_OnTrackingChanged(anchor, anchor.isLocated);
```

## <a name="sharing-anchors-across-devices"></a>Совместное использование привязок на разных устройствах

Используйте <a href="/azure/spatial-anchors/overview" target="_blank">Пространственные привязки Azure</a> , чтобы создать устойчивую облачную привязку на основе локальной ворлданчор, которую приложение может затем разместить на нескольких устройствах HoloLens, iOS и Android.  При совместном использовании общей пространственной привязки на нескольких устройствах каждый пользователь может видеть содержимое, отображаемое относительно этой привязки в том же физическом расположении.  Это позволяет обмениваться опытом в режиме реального времени.

Чтобы приступить к созданию общих интерфейсов в Unity, ознакомьтесь с пошаговыми руководствами Unity по 5-минутной <a href="/azure/spatial-anchors/unity-overview" target="_blank">пространственной привязке Azure</a>.

После завершения работы с пространственными привязками Azure можно <a href="/azure/spatial-anchors/concepts/create-locate-anchors-unity" target="_blank">создавать и искать привязки в Unity</a>.

## <a name="next-development-checkpoint"></a>Следующий этап разработки

Если вы используете точку контрольной точки разработки Unity, которую мы собрали, то можете изучить стандартные блоки в смешанной реальности. Отсюда вы можете перейти к следующему стандартному блоку:

> [!div class="nextstepaction"]
> [Взгляд](gaze-in-unity.md)

Или перейдите к возможностям и API платформы смешанной реальности:

> [!div class="nextstepaction"]
> [общие возможности](shared-experiences-in-unity.md);

Вы можете в любой момент вернуться к [этапам разработки для Unity](unity-development-overview.md#2-core-building-blocks).

## <a name="see-also"></a>См. также
* [Масштабирование работы](../../design/coordinate-systems.md#mixed-reality-experience-scales)
* [Пространственный этап](../../design/coordinate-systems.md#stage-frame-of-reference)
* [Потеря слежения в Unity](tracking-loss-in-unity.md)
* [Пространственные привязки](../../design/spatial-anchors.md)
* [Сохраняемость в Unity](persistence-in-unity.md)
* [Общий доступ в Unity](shared-experiences-in-unity.md)
* <a href="/azure/spatial-anchors" target="_blank">Пространственные привязки Azure.</a>
* <a href="/dotnet/api/Microsoft.Azure.SpatialAnchors" target="_blank">Пакет SDK для пространственных привязок Azure для Unity</a>