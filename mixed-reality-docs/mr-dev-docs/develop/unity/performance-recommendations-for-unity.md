---
title: Рекомендации по производительности для Unity
description: Советы для платформы Unity по повышению производительности приложений смешанной реальности.
author: hferrone
ms.author: v-hferrone
ms.date: 03/26/2019
ms.topic: article
keywords: графика, ЦП, GPU, преобразование для просмотра, сборка мусора, hololens
ms.localizationpriority: high
ms.openlocfilehash: 2c5a459f673889dd4c52043f9b9df6a3fe43a93a
ms.sourcegitcommit: 09599b4034be825e4536eeb9566968afd021d5f3
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/03/2020
ms.locfileid: "91699760"
---
# <a name="performance-recommendations-for-unity"></a>Рекомендации по производительности для Unity

Эта статья основана на обсуждении, начатом в [рекомендациях по производительности для смешанной реальности](../platform-capabilities-and-apis/understanding-performance-for-mixed-reality.md), но посвящена более узким вопросам, имеющим отношение к среде подсистемы Unity.

## <a name="use-recommended-unity-project-settings"></a>Использование рекомендуемых параметров проекта Unity

Самый важный шаг при оптимизации производительности приложений смешанной реальности в Unity — использовать [рекомендуемые параметры среды для Unity](recommended-settings-for-unity.md). В этой статье содержится информация о самых важных конфигурациях сцены для создания производительных приложений смешанной реальности. Некоторые из этих рекомендаций отдельно выделены ниже.

## <a name="how-to-profile-with-unity"></a>Профилирование с помощью Unity

В Unity доступен встроенный **[профилировщик Unity](https://docs.unity3d.com/Manual/Profiler.html)** , который служит отличным инструментом для сбора ценных сведений о производительности для конкретного приложения. Этот профилировщик можно запустить прямо в редакторе, но метрики не будут отражать условия в реальной среде выполнения, поэтому полученные таким образом результаты следует использовать с осторожностью. Мы рекомендуем выполнять дистанционное профилирование приложения, работающего на реальном устройстве, чтобы получить наиболее точные и применимые результаты. Еще одним мощным и ценным инструментом для работы является отладчик [Frame Debugger](https://docs.unity3d.com/Manual/FrameDebugger.html) в Unity.

Для Unity доступна замечательная документация по следующим темам:
1) [Удаленное подключение профилировщика Unity к приложениям UWP](https://docs.unity3d.com/Manual/windowsstore-profiler.html)
2) [Эффективная диагностика проблем с производительностью с помощью профилировщика Unity](https://unity3d.com/learn/tutorials/temas/performance-optimization/diagnosing-performance-problems-using-profiler-window)

>[!NOTE]
> Подключив профилировщик Unity и добавив профилировщик GPU с помощью действия *Add Profiler* (Добавить профилировщик) в верхнем правом углу, в средней области профилировщика вы увидите, сколько времени тратится на работу центрального и графического процессоров. Это позволяет разработчику быстро получить приближенные сведения о требованиях приложения к ЦП или GPU.
>
> ![ЦП и GPU в Unity](images/unity-profiler-cpu-gpu.png)

## <a name="cpu-performance-recommendations"></a>Рекомендации по производительности ЦП

Ниже приводятся более подробные рекомендации по производительности, которые особенно касаются разработки на C# в Unity.

#### <a name="cache-references"></a>Кэширование ссылок

Мы рекомендуем при инициализации кэшировать ссылки на все используемые компоненты и игровые объекты. Это обусловлено тем, что повторяющиеся вызовы *[GetComponent\<T>()](https://docs.unity3d.com/ScriptReference/GameObject.GetComponent.html)* и аналогичных функций требуют намного больше памяти, чем используемая память для хранения указателя. Это также относится к часто используемому объекту [Camera.main](https://docs.unity3d.com/ScriptReference/Camera-main.html). По сути *Camera.main* просто использует *[FindGameObjectsWithTag()](https://docs.unity3d.com/ScriptReference/GameObject.FindGameObjectsWithTag.html)* для выполнения дорогостоящего поиска объекта камеры в графе сцены по тегу *MainCamera* .

```CS
using UnityEngine;
using System.Collections;

public class ExampleClass : MonoBehaviour
{
    private Camera cam;
    private CustomComponent comp;

    void Start() 
    {
        cam = Camera.main;
        comp = GetComponent<CustomComponent>();
    }

    void Update()
    {
        // Good
        this.transform.position = cam.transform.position + cam.transform.forward * 10.0f;

        // Bad
        this.transform.position = Camera.main.transform.position + Camera.main.transform.forward * 10.0f;

        // Good
        comp.DoSomethingAwesome();

        // Bad
        GetComponent<CustomComponent>().DoSomethingAwesome();
    }
}
```

>[!NOTE] 
> Отказ от использования GetComponent(string) <br/>
> При использовании *[GetComponent()](https://docs.unity3d.com/ScriptReference/GameObject.GetComponent.html)* существует несколько разных перегрузок. Важно всегда использовать реализации на основе конкретных типов, но не перегрузку поиска на основе строк. Поиск по строке в сцене значительно дороже, чем поиск по типу. <br/>
> (Хорошо) Component GetComponent(Type type) <br/>
> (Хорошо) T GetComponent\<T>() <br/>
> (Плохо) Component GetComponent(string) <br/>

#### <a name="avoid-expensive-operations"></a>Отказ от дорогостоящих операций

1) **Отказ от использования [LINQ](https://docs.microsoft.com/dotnet/csharp/programming-guide/concepts/linq/getting-started-with-linq)**

    Благодаря чистоте код LINQ проще читать и писать, но он требует гораздо больше вычислительных ресурсов и особенно выделенной памяти, чем написанный вручную алгоритм.

    ```CS
    // Example Code
    using System.Linq;

    List<int> data = new List<int>();
    data.Any(x => x > 10);

    var result = from x in data
                 where x > 10
                 select x;
    ```

2) **Распространенные API Unity**

    Некоторые API Unity при всей очевидной пользе могут быть очень ресурсоемкими. Большинство из них выполняют поиск соответствующих игровых объектов по всему графу сцены. Обычно этих операций можно избежать, кэшируя ссылки или создав компонент управления нужными игровыми объектами для отслеживания ссылок во время выполнения.

    ```csharp
        GameObject.SendMessage()
        GameObject.BroadcastMessage()
        UnityEngine.Object.Find()
        UnityEngine.Object.FindWithTag()
        UnityEngine.Object.FindObjectOfType()
        UnityEngine.Object.FindObjectsOfType()
        UnityEngine.Object.FindGameObjectsWithTag()
        UnityEngine.Object.FindGameObjectsWithTag()
    ```

>[!NOTE]
> Удалите все *[SendMessage()](https://docs.unity3d.com/ScriptReference/GameObject.SendMessage.html)* и *[BroadcastMessage()](https://docs.unity3d.com/ScriptReference/GameObject.BroadcastMessage.html)* любой ценой. Эти функции работают на три порядка медленнее, чем прямые вызовы функций.

3) **Остерегайтесь упаковки-преобразования**

    Концепция [упаковки-преобразования](https://docs.microsoft.com/dotnet/csharp/programming-guide/types/boxing-and-unboxing) очень важна в языке и среде выполнения C#. Так называют процесс создания переменных со ссылочным типом в виде оболочек для переменных со значениями типа, такими как char, int, bool и т. д. Если переменная со значением типа "упакована", она помещается в объект System.Object, который хранится в управляемой куче. Это означает, что для нее выделяется память и ее нужно обрабатывать сборщиком мусора после освобождения. Такие процессы выделения и освобождения ресурсов приводят к снижению производительности, а во многих случаях их можно убрать или легко заменить на менее дорогостоящую альтернативу.

    Одной из наиболее распространенных форм упаковки-преобразования является использование [типов значений, допускающих значение NULL](https://docs.microsoft.com//dotnet/csharp/programming-guide/nullable-types/). Часто вам нужно, чтобы функция могла возвращать значение NULL для типа значения, особенно если операция не всегда может получить нужное значение. Потенциальная проблема этого подхода заключается в том, что выделение памяти выполняется из кучи и должно затем обрабатываться сборщиком мусора.

    **Пример упаковки-преобразования в C#**

    ```csharp
    // boolean value type is boxed into object boxedMyVar on the heap
    bool myVar = true;
    object boxedMyVar = myVar;
    ```

    **Пример проблемной упаковки-преобразования в типы значений, допускающие значения NULL**

    В этом коде демонстрируется фиктивный класс частиц, который можно создать в проекте Unity. Вызов `TryGetSpeed()` приведет к выделению объекта из кучи, которое позднее придется обработать сборщиком мусора. Этот пример особенно проблематичен, так как в сцене может быть несколько тысяч частиц, каждая из которых опрашивается для получения их текущей скорости. Это означает, что придется выделить и впоследствии освободить несколько тысяч объектов для каждого кадра, что значительно снизит производительность. Переписав эту функцию так, чтобы в случае ошибки она возвращала отрицательное значение (например, –1), мы сможем избежать этой проблемы и сохранить выделение памяти из стека.

    ```csharp
        public class MyParticle
        {
            // Example of function returning nullable value type
            public int? TryGetSpeed()
            {
                // Returns current speed int value or null if fails
            }
        }
    ```

#### <a name="repeating-code-paths"></a>Повторяющиеся пути кода

Любые повторяющиеся функции обратного вызова в Unity (например, Update), которые выполняются много раз каждую секунду и (или) для каждого кадра, следует обдумывать очень тщательно. Любые дорогостоящие операции в этом коде будут иметь огромное и стабильное влияние на производительность.

1) **Пустые функции обратного вызова**

    Несмотря на внешнюю безобидность приведенного ниже кода, эти пустые обратные вызовы могут быть очень ресурсоемкими, особенно учитывая, что каждый скрипт Unity выполняет автоматическую инициализацию с помощью этого блока кода. Unity придется постоянно переключаться между неуправляемой и управляемой частью кода, то есть между кодом UnityEngine и кодом приложения. Такое переключение контекста на этой границе требует много ресурсов, даже если не выполняется никаких действий. Это особенно проблематично, если приложение использует сотни игровых объектов, компоненты которых имеют повторяющиеся пустые обратные вызовы Unity.

    ```CS
    void Update()
    {
    }
    ```

>[!NOTE]
> Update() служит самым ярким примером этой проблемы с производительностью, но некоторые другие повторяющиеся обратные вызовы Unity могут оказаться не менее или даже более серьезными, как например следующие: FixedUpdate(), LateUpdate(), OnPostRender(), OnPreRender(), OnRenderImage() и т. п. 

2) **Однократное выполнение операций для каждого кадра**

    Следующие API Unity содержат операции, типичные для многих голографических приложений. Хотя и не всегда, результаты таких функций часто можно вычислять один раз за кадр и повторно использовать в приложении для всего этого кадра.

    а) Как общее правило, мы рекомендуем выделить один класс или службу Singleton, чтобы обработать Raycast для взгляда на сцену и повторно использовать полученный результат во всех остальных компонентах сцены, не повторяя по сути идентичные операции Raycast для каждого компонента. Разумеется, в некоторых приложениях нужно выполнять Raycast из разных позиций или с разными [LayerMask](https://docs.unity3d.com/ScriptReference/LayerMask.html).
    
    ```csharp
        UnityEngine.Physics.Raycast()
        UnityEngine.Physics.RaycastAll()
    ```

    б) Избегайте операций с методом GetComponent() в повторяющихся обратных вызовах Unity, таких как Update(), используя [кэширование ссылок](#cache-references) в Start () или Awake().
    
    ```csharp
        UnityEngine.Object.GetComponent()
    ```

    в) Мы рекомендуем по возможности создавать экземпляры всех объектов при инициализации и применять [пулы объектов](#object-pooling) для повторного использования игровых объектов на протяжении всей работы приложения.

    ```csharp
        UnityEngine.Object.Instantiate()
    ```

3) **Отказ от использования интерфейсов и виртуальных конструкций**

    Вызов функций через интерфейсы вместо прямого обращения к объектам либо вызов виртуальных функций часто будет гораздо более затратным, чем использование прямых конструкций или прямых вызовов функций. Если виртуальная функция или интерфейс являются необязательными, их следует удалить. Однако для этих подходов ухудшение производительности часто будет хорошим компромиссом, если их применение упрощает совместную работу, повышает удобочитаемость или удобство поддержки кода.

    В общем случае мы рекомендуем не объявлять поля и функции виртуальными, если нет четкого понимания, что этот элемент придется перезаписывать. Разработчикам нужно быть особенно осторожными в путях кода с высокой частотой исполнения, то есть вызываемых один и более раз для каждого кадра, таких как метод `UpdateUI()`.

4) **Отказ от передачи структур по значению**

    В отличие от классов, для структуры типы определяются значением, и при прямой передаче в функцию их содержимое копируется в только что созданный экземпляр. Эта копия повышает нагрузку на ЦП и требует дополнительной памяти из стека. Влияние небольших структур обычно минимально и может считаться приемлемым. Но для тех функций, которые несколько раз вызываются для каждого кадра и (или) принимают крупные структуры, по возможности измените определение функции так, чтобы передавать им ссылку. [Дополнительные сведения см. здесь](https://docs.microsoft.com/dotnet/csharp/programming-guide/classes-and-structs/how-to-know-the-difference-passing-a-struct-and-passing-a-class-to-a-method)

#### <a name="miscellaneous"></a>Прочее

1) **Физика**

    а) Как правило, для улучшения обработки физики следует ограничить количество времени или количество итераций в секунду, затрачиваемых на ее обработку. Разумеется, это снизит точность имитации. См. документацию по [TimeManager](https://docs.unity3d.com/Manual/class-TimeManager.html) в Unity.

    б) Тип коллайдера в Unity может иметь очень разные характеристики производительности. В приведенном ниже списке коллайдеры перечислены в порядке уменьшения производительности, слева направо. Важнее всего избегать коллайдеров сетки, которые значительно дороже коллайдеров примитивов.

    Сфера < Капсула < Коробка <<< Сетка (выпуклая) < Сетка (невыпуклая)

    Дополнительные сведения см. в статье [с рекомендациями по обработке физики в Unity](https://unity3d.com/learn/tutorials/topics/physics/physics-best-practices).

2) **Анимации**

    Избавьтесь от анимации простоя, отключив компонент Animator (отключение объекта Game не дает такого эффекта). Избегайте шаблонов разработки, в которых аниматор в цикле постоянно присваивает значение одному параметру. Такая техника влечет значительные издержки без видимого эффекта в приложении. [Дополнительные сведения доступны здесь.](https://docs.unity3d.com/Manual/MecanimPeformanceandOptimization.html)

3) **Сложные алгоритмы**

    Если приложение использует сложные алгоритмы, такие как обратная кинематика, поиск пути и т. д., попробуйте найти более простой подход или оптимизируйте соответствующие параметры по производительности.

## <a name="cpu-to-gpu-performance-recommendations"></a>Рекомендации по производительности взаимодействия ЦП с GPU

Как правило, производительность взаимодействия ЦП с GPU упирается в **вызовы отрисовки** , передаваемые на графическую плату. Чтобы повысить эту производительность, вызовы отрисовки следует стратегически **уменьшать** и (или) **реструктуризовать** до достижения оптимальных результатов. Поскольку вызовы отрисовки сами по себе требуют много ресурсов, снижение их количества позволит сократить общий объем работы. Кроме того, изменения состояния между вызовами отрисовки требуют дорогостоящих операций по проверке и переводу в графическом драйвере, а значит реструктуризация вызовов отрисовки в приложении для ограничения изменений состояния (т. е. разных материалов и т. д.) может повысить производительность.

В документации по Unity есть отличная статья с обзорным и подробным описанием пакетной обработки вызовов на этой платформе.
- [Пакетная обработка вызовов отрисовки в Unity](https://docs.unity3d.com/Manual/DrawCallBatching.html)

#### <a name="single-pass-instanced-rendering"></a>Однопроходная отрисовка экземпляра

Однопроходная отрисовка экземпляра в Unity позволяет уменьшить число вызовов отрисовки для каждого глаза до одного экземпляра. Благодаря согласованности кэша между двумя вызовами отрисовки будет заметно и некоторое улучшение производительности GPU.

Включение этой функции в проекте Unity
1)  Откройте **Player XR Settings** (Параметры XR проигрывателя), выбрав элементы **Edit** > **Project Settings** > **Player** > **XR Settings** (Редактирование > Параметры проекта > Проигрыватель > Параметры XR)
2) Выберите **Single Pass Instanced** (Однопроходный с экземпляром) в раскрывающемся меню **Stereo Rendering Method** (Метод стереоскопической отрисовки), установив также флажок **Virtual Reality Supported** (Поддержка виртуальной реальности)

Ознакомьтесь со следующими статьями Unity, чтобы получить подробные сведения об этом подходе к отрисовке.
- [Максимизация производительности дополненной реальности и виртуальной реальности с помощью расширенной стереоскопической отрисовки](https://blogs.unity3d.com/2017/11/21/how-to-maximize-ar-and-vr-performance-with-advanced-stereo-rendering/)
- [Однопроходная отрисовка экземпляра](https://docs.unity3d.com/Manual/SinglePassInstancing.html) 

>[!NOTE]
> Одна из распространенных проблем при однопроходной отрисовке с использованием экземпляра возникает в тех случаях, если уже существующие пользовательские шейдеры не поддерживают создание экземпляра. После включения этой возможности разработчики заметят, что некоторые игровые объекты отрисовываются только для одного глаза. Это связано с тем, что соответствующие пользовательские шейдеры не имеют нужных свойств для создания экземпляров.
>
> Действия для решения этой проблемы описаны в документе Unity [об однопроходной стереоскопической отрисовке для HoloLens](https://docs.unity3d.com/Manual/SinglePassStereoRenderingHoloLens.html).

#### <a name="static-batching"></a>Пакетная обработка статических объектов

Unity поддерживает создание пакетов из нескольких статических объектов, что позволяет снизить число вызовов отрисовки для GPU. Пакетная обработка статических объектов будет нормально работать в Unity для большинства объектов [Renderer](https://docs.unity3d.com/ScriptReference/Renderer.html), которые **имеют одинаковый материал** и **имеют атрибут *Static*** (чтобы присвоить его, выберите объект в Unity и щелкните флажок в верхней правой части окна инспектора). Игровые объекты, имеющие атрибут *Static* , не могут перемещаться на протяжении всего периода работы приложения. Это означает, что пакетную обработку статических объектов трудно применить для HoloLens, поскольку здесь почти каждый объект должен быть перемещаемым, масштабируемым и т. д. Для иммерсивных гарнитур пакетная обработка статических объектов позволяет значительно сократить число вызовов отрисовки, а значит и повысить производительность.

Дополнительные сведения см. в разделе *о пакетной обработке статических объектов* в статье [Пакетная обработка вызовов отрисовки в Unity](https://docs.unity3d.com/Manual/DrawCallBatching.html).

#### <a name="dynamic-batching"></a>Пакетная обработка динамических объектов

Поскольку при разработке для HoloLens будет затруднительно объявлять объекты *статическими* , компенсировать этот недостаток можно применением пакетной обработки динамических объектов. Конечно же, это будет работать и для иммерсивных гарнитур. Однако пакетная обработка динамических объектов в Unity может быть сложной, поскольку игровые объекты должны иметь **одинаковые материалы** и **соответствовать множеству других критериев** .

Полный список этих требований см. в разделе *о пакетной обработке динамических объектов* в статье [Пакетная обработка вызовов отрисовки в Unity](https://docs.unity3d.com/Manual/DrawCallBatching.html). Чаще всего игровые объекты не удается объединить в пакет, поскольку для такой обработки данные о сетке не могут содержать более 300 вершин.

#### <a name="other-techniques"></a>Другие методики

Пакетная обработка возможна только в том случае, если несколько игровых объектов имеют один и тот же материал. Обычно это невозможно из-за того, что для каждого игрового объекта нужна уникальная текстура соответствующего материала. Существует метод [текстурного атласа](https://en.wikipedia.org/wiki/Texture_atlas), в котором несколько текстур объединяются в одну большую текстуру.

Более того, во всех случаях, где это возможно и оправдано, лучше объединять несколько сеток в один игровой объект. Каждый отрисовщик в Unity будет использовать собственные вызовы отрисовки, и этого можно избежать при одном отрисовщике для объединенной сетки.

>[!NOTE]
> Изменение свойств в Renderer.material во время выполнения приводит к созданию копии материала, что может нарушить возможность пакетной обработки. Используйте Renderer.sharedMaterial для изменения свойств общего материала для нескольких игровых объектов.

## <a name="gpu-performance-recommendations"></a>Рекомендации по производительности GPU

Дополнительные сведения об оптимизации отрисовки графических объектов в Unity см. [здесь](https://unity3d.com/learn/tutorials/temas/performance-optimization/optimizing-graphics-rendering-unity-games).

### <a name="optimize-depth-buffer-sharing"></a>Оптимизация совместного использования буфера глубины

Обычно лучше включить параметр **Depth buffer sharing** (Совместное использование буфера глубины) в разделе **Player XR Settings** (Параметры XR проигрывателя) для повышения [стабильности голограммы](../platform-capabilities-and-apis/Hologram-stability.md). Но при включении повторного проецирования на поздней стадии на основе глубины, если задан этот параметр, мы рекомендуем выбрать **16-разрядный формат глубины** , а не **24-разрядный** . 16-разрядные буферы глубины существенно снизят нагрузку на пропускную способность (передачу данных) для буфера глубины, а значит и энергопотребление. Это позволит одновременно снизить энергопотребление и повысить производительность. Но использование *16-разрядного формата глубины* может иметь два неприятных последствия.

**Z-конфликт**

Снижение четкости по глубине при 16-разрядном буфере повышает вероятность [Z-конфликтов](https://en.wikipedia.org/wiki/Z-fighting) по сравнению с 24-разрядными буферами. Чтобы избежать таких артефактов, измените ближнюю и дальнюю отсекающие плоскости для [камеры Unity](https://docs.unity3d.com/Manual/class-Camera.html) с учетом снижения разрешения. Для приложений на основе HoloLens дальняя отсекающая плоскость в 50 м вместо стандартного для Unity значения 1000 м обычно полностью устраняет Z-конфликты.

**Отключение буфера трафаретов**

Если Unity создает [текстуру отрисовки с 16-разрядной глубиной](https://docs.unity3d.com/ScriptReference/RenderTexture-depth.html), буфер трафаретов не создается. Согласно документации по Unity, выбор 24-разрядного формата глубины приводит к созданию 24-разрядного z-буфера и 8-разрядного буфера трафаретов (https://docs.unity3d.com/Manual/SL-Stencil.html) (если на устройстве применим 32-разрядный формат, что обычно справедливо для устройств HoloLens).

### <a name="avoid-full-screen-effects"></a>Отказ от полноэкранных эффектов

Некоторые техники для полного экрана могут быть достаточно дорогими из-за того, что их работа в каждом кадре исчисляется миллионами операций. Поэтому мы рекомендуем отказаться от [эффектов постобработки](https://docs.unity3d.com/Manual/PostProcessingOverview.html), таких как сглаживание, свечение и т. п.

### <a name="optimal-lighting-settings"></a>Оптимальные параметры освещения

[Глобальное освещение в реальном времени](https://docs.unity3d.com/Manual/GIIntro.html) в Unity дает потрясающие визуальные результаты, но требует довольно дорогих вычислений. Мы рекомендуем отключать глобальное освещение в реальном времени для всех сцен Unity. Для этого нужно в разделе **Window** > **Rendering** > **Lighting Settings** (Окно > Отрисовка > Параметры освещения) снять флажок **Real-time Global Illumination** (Глобальное освещение в реальном времени).

Более того, мы рекомендуем отключить все тени, так как они создают дополнительные дорогие вызовы GPU из сцены Unity. Тени можно отключать отдельно для каждого источника света или глобально через параметры качества.

Выберите **Edit** > **Project Settings** (Редактировать > Свойства проекта), затем категорию **Quality** (Качество) и укажите вариант **Low Quality** (Низкое качество) для платформы UWP. Можно также отдельно указать для свойства **Shadows** (Тени) значение **Disable Shadows** (Отключить тени).

С моделями в Unity рекомендуется использовать просчитанное освещение (baked lighting).

### <a name="reduce-poly-count"></a>Уменьшение количества многоугольников

Количество многоугольников можно снизить следующими способами:
1) Удаление объектов из сцены.
2) Прореживание ресурсов, которое позволяет снизить количество многоугольников для некоторой сетки.
3) Внедрение в приложение [системы уровня детализации](https://docs.unity3d.com/Manual/LevelOfDetail.html), которая отрисовывает более далекие объекты в виде той же геометрической фигуры с меньшим числом многоугольников.

### <a name="understanding-shaders-in-unity"></a>Общие сведения о шейдерах в Unity

Для сравнения производительности шейдеров можно использовать упрощенную оценку среднего числа операций, выполняемых каждым из них в среде выполнения. В Unity это выполнить очень легко.

1) Выберите нужный ресурс шейдера или материал, затем в верхнем правом углу окна Inspector (Инспектор) выберите значок шестеренки и действие **Select Shader** (Выбрать шейдер).

    ![Выбор шейдера в Unity](images/Select-shader-unity.png)
2) После выбора ресурса шейдера нажмите кнопку **Compile and show code** (Компилировать и показать код) в окне Inspector (Инспектор).

    ![Компиляция кода шейдера в Unity](images/compile-shader-code-unity.PNG)

3) После компиляции найдите раздел статистики в области результатов, где отображается число разных операций для вершинных и пиксельных шейдеров (учтите, что пиксельные шейдеры часто называют фрагментными).

    ![Работа стандартного шейдера Unity](images/unity-standard-shader-compilation.png)

#### <a name="optimize-pixel-shaders"></a>Оптимизация пиксельных шейдеров

Изучая результаты статистики, полученные описанным выше методом, вы можете заметить, что [фрагментный шейдер](https://en.wikipedia.org/wiki/Shader#Pixel_shaders) в среднем выполняет больше операций, чем [вершинный шейдер](https://en.wikipedia.org/wiki/Shader#Vertex_shaders). Фрагментный шейдер, также именуемый пиксельным шейдером, выполняется отдельно для каждого пикселя на экране, а вершинный шейдер выполняется только для вершин всех сеток, отрисовываемых на экране. 

Таким образом, фрагментные шейдеры не только выполняют больше операций, чем вершинные (из-за сложных вычислений освещения) но и почти всегда применяются к более крупному набору данных. Например, при размере экрана 2000 на 2000 пикселей фрагментный шейдер будет выполнен 2000 × 2000 = 4 000 000 раз. При отрисовке для двух глаз это число удваивается, так как работают сразу два экрана. Если приложение смешанной реальности использует несколько проходов, полноэкранные эффекты постобработки или отрисовку нескольких сеток в пределах одного пикселя, это количество еще значительно увеличится. 

Таким образом, снижение числа операций во фрагментных шейдерах обычно значительно больше влияет на производительность, чем аналогичная оптимизация в вершинном шейдере.

#### <a name="unity-standard-shader-alternatives"></a>Альтернативы стандартному шейдеру Unity

Вместо отрисовки на основе физических параметров или другого шейдера высокого качества, попробуйте применить более производительный и более дешевый шейдер. В [наборе средств для смешанной реальности](https://github.com/Microsoft/MixedRealityToolkit-Unity) предоставляется [стандартный шейдер MRTK](https://microsoft.github.io/MixedRealityToolkit-Unity/Documentation/README_MRTKStandardShader.html), который оптимизирован для проектов смешанной реальности.

В Unity также доступны упрощенные версии шейдеров (без освещенности, с освещенностью вершин, диффузный и т. д.), которые работают значительно быстрее стандартного шейдера Unity. Дополнительные сведения см. в статье об [использовании и производительности встроенных шейдеров](https://docs.unity3d.com/Manual/shader-Performance.html).

#### <a name="shader-preloading"></a>Предварительная загрузка шейдера

*Предварительная загрузка шейдера* и некоторые другие приемы позволяют оптимизировать [время загрузки шейдера](https://docs.unity3d.com/Manual/OptimizingShaderLoadTime.html). В частности, предварительная загрузка шейдера позволяет избежать задержек, связанных с компиляцией шейдера во время выполнения.

### <a name="limit-overdraw"></a>Ограничение перерисовки

В Unity можно отобразить перерисовку сцены, переключившись на [**меню режима отрисовки**](https://docs.unity3d.com/Manual/ViewModes.html) в верхнем левом углу **представления сцены** и выбрав параметр **Overdraw** (Перерисовка).

Обычно перерисовка устраняется предварительным выбором объектов до того, как они будут отправлены в GPU. Unity предоставляет подробные сведения о реализации [отбрасывания загораживаемых объектов](https://docs.unity3d.com/Manual/OcclusionCulling.html) для этой платформы.

## <a name="memory-recommendations"></a>Рекомендации по использованию памяти

Операции выделения и освобождения памяти в больших объемах могут значительно снижать производительность голографического приложения, что приведет к нестабильному поведению, замиранию кадров и другим неприятным эффектам. При разработке в Unity особенно важно понимать особенности использования памяти, так как управление памятью здесь реализовано через сборщик мусора.

#### <a name="garbage-collection"></a>Сбор мусора

Голографические приложения тратят вычислительное время процессора на сбор мусора, когда он активируется для анализа объектов, вышедших из поля зрения в процессе выполнения и требующих удаления из памяти, чтобы использовать ее повторно. Постоянные операции выделения и освобождения памяти обычно требуют более частого вызова сборщика мусора, что ухудшает производительность и взаимодействие с пользователем.

Unity предоставляет отличный ресурс, на котором подробно описана работа сборщика мусора и собраны рекомендации по повышению эффективности работы с памятью в коде.
- [Оптимизация сбора мусора в играх на Unity](https://unity3d.com/learn/tutorials/topics/performance-optimization/optimizing-garbage-collection-unity-games?playlist=44069)

При разработке в Unity одной из самых распространенных ошибок, которые приводят к избыточному сбору мусора, является отсутствие кэша для ссылок на компоненты и классы. Все ссылки следует собирать в методе Start() или Awake() и всегда использовать повторно из кэша в функциях Update() и LateUpdate().

Еще немного советов.
- Используйте класс C# [StringBuilder](https://docs.microsoft.com/dotnet/api/system.text.stringbuilder) для динамического создания сложных строк в процессе выполнения.
- Удалите все вызовы Debug.Log(), когда в них отпадет необходимость, иначе они будут по-прежнему выполняться в рабочих версиях приложения.
- Если голографическое приложение часто требует большого объема памяти, попробуйте вызывать [_**System.GC.Collect()**_](https://docs.microsoft.com/dotnet/api/system.gc.collect) на этапах загрузки, например при отображении экрана загрузки или перехода между сценами.

#### <a name="object-pooling"></a>Использование пулов объектов

Использование пулов объектов — это распространенный метод для снижения затрат на постоянное выделение или освобождение памяти для объектов. Для этого выделяется большой пул идентичных объектов, из которого извлекаются для повторного использования доступные и неактивные экземпляры. Это эффективнее, чем постоянный процесс создания и уничтожения объектов. Пулы объектов отлично подходят для многократно используемых компонентов с переменными периодами жизни в приложении.

- [Руководство по использованию пулов объектов в Unity](https://unity3d.com/learn/tutorials/topics/scripting/object-pooling) 

## <a name="startup-performance"></a>Производительность при запуске

Возможно, вам лучше начать работу приложения с небольшой сцены, а затем загружать остальную часть с помощью *[SceneManager.LoadSceneAsync](https://docs.unity3d.com/ScriptReference/SceneManagement.SceneManager.LoadSceneAsync.html)* . Это позволит приложению максимально быстро перейти к интерактивному состоянию. Учитывайте, что при активации новой сцены создается пиковая нагрузка на ЦП, что может привести к задержкам или дрожанию отображаемого содержимого. Для обхода этой проблемы можно установить для параметра загружаемой сцены AsyncOperation.allowSceneActivation значение False, затем дождаться полной загрузки сцены, очистить экран и вернуть этому параметру значение True для завершения активации сцены.

Не забывайте, что в процессе загрузки сцены пользователю будет отображаться голографический стартовый экран.

## <a name="see-also"></a>См. также статью
- [Оптимизация отрисовки графических объектов в играх на Unity](https://unity3d.com/learn/tutorials/temas/performance-optimization/optimizing-graphics-rendering-unity-games?playlist=44069)
- [Оптимизация сбора мусора в играх на Unity](https://unity3d.com/learn/tutorials/topics/performance-optimization/optimizing-garbage-collection-unity-games?playlist=44069)
- [Советы и рекомендации по физике (Unity)](https://unity3d.com/learn/tutorials/topics/physics/physics-best-practices)
- [Оптимизация скриптов (Unity)](https://docs.unity3d.com/Manual/MobileOptimizationPracticalScriptingOptimizations.html)
