---
title: Рекомендации по производительности для Unity
description: Советы для платформы Unity по повышению производительности приложений смешанной реальности.
author: hferrone
ms.author: v-hferrone
ms.date: 03/26/2019
ms.topic: article
keywords: графика, ЦП, GPU, преобразование для просмотра, сборка мусора, hololens
ms.localizationpriority: high
ms.openlocfilehash: 1a0509e656b7a6bf0d8d1f0b5d381b2fbdb39c2d
ms.sourcegitcommit: 87b54c75044f433cfadda68ca71c1165608e2f4b
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 12/10/2020
ms.locfileid: "97010485"
---
# <a name="performance-recommendations-for-unity"></a><span data-ttu-id="d5a76-104">Рекомендации по производительности для Unity</span><span class="sxs-lookup"><span data-stu-id="d5a76-104">Performance recommendations for Unity</span></span>

<span data-ttu-id="d5a76-105">Эта статья продолжает статью о [рекомендациях по оптимизации производительности для смешанной реальности](../platform-capabilities-and-apis/understanding-performance-for-mixed-reality.md), но посвящена улучшениям для Unity.</span><span class="sxs-lookup"><span data-stu-id="d5a76-105">This article builds on the [performance recommendations for mixed reality](../platform-capabilities-and-apis/understanding-performance-for-mixed-reality.md), but focuses on Unity-specific improvements.</span></span>

## <a name="use-recommended-unity-project-settings"></a><span data-ttu-id="d5a76-106">Использование рекомендуемых параметров проекта Unity</span><span class="sxs-lookup"><span data-stu-id="d5a76-106">Use recommended Unity project settings</span></span>

<span data-ttu-id="d5a76-107">Самый важный шаг при оптимизации производительности приложений смешанной реальности в Unity — использовать [рекомендуемые параметры среды для Unity](recommended-settings-for-unity.md).</span><span class="sxs-lookup"><span data-stu-id="d5a76-107">The most important first step when optimizing performance of mixed reality apps in Unity is to be sure you're using the [recommended environment settings for Unity](recommended-settings-for-unity.md).</span></span> <span data-ttu-id="d5a76-108">В этой статье содержится информация о самых важных конфигурациях сцены для создания производительных приложений смешанной реальности.</span><span class="sxs-lookup"><span data-stu-id="d5a76-108">That article contains content with some of the most important scene configurations for building performant Mixed Reality apps.</span></span> <span data-ttu-id="d5a76-109">Некоторые из этих рекомендаций отдельно выделены ниже.</span><span class="sxs-lookup"><span data-stu-id="d5a76-109">Some of these recommended settings are highlighted below, as well.</span></span>

## <a name="how-to-profile-with-unity"></a><span data-ttu-id="d5a76-110">Профилирование с помощью Unity</span><span class="sxs-lookup"><span data-stu-id="d5a76-110">How to profile with Unity</span></span>

<span data-ttu-id="d5a76-111">В Unity доступен встроенный **[профилировщик Unity](https://docs.unity3d.com/Manual/Profiler.html)** , который служит отличным инструментом для сбора ценных сведений о производительности для конкретного приложения.</span><span class="sxs-lookup"><span data-stu-id="d5a76-111">Unity provides the **[Unity Profiler](https://docs.unity3d.com/Manual/Profiler.html)** built-in, which is a great resource to gather valuable performance insights for your particular app.</span></span> <span data-ttu-id="d5a76-112">Этот профилировщик можно запустить прямо в редакторе, но метрики не будут отражать условия в реальной среде выполнения, поэтому полученные таким образом результаты следует использовать с осторожностью.</span><span class="sxs-lookup"><span data-stu-id="d5a76-112">Although you can run the profiler in-editor, these metrics don't represent the true runtime environment so results should be used cautiously.</span></span> <span data-ttu-id="d5a76-113">Мы рекомендуем выполнять дистанционное профилирование приложения, работающего на реальном устройстве, чтобы получить наиболее точные и применимые результаты.</span><span class="sxs-lookup"><span data-stu-id="d5a76-113">We recommended remotely profiling your application while running on device for most accurate and actionable insights.</span></span> <span data-ttu-id="d5a76-114">Еще одним мощным и ценным инструментом для работы является отладчик [Frame Debugger](https://docs.unity3d.com/Manual/FrameDebugger.html) в Unity.</span><span class="sxs-lookup"><span data-stu-id="d5a76-114">Further, Unity's [Frame Debugger](https://docs.unity3d.com/Manual/FrameDebugger.html) is also a powerful and insight tool to use.</span></span>

<span data-ttu-id="d5a76-115">Для Unity доступна замечательная документация по следующим темам:</span><span class="sxs-lookup"><span data-stu-id="d5a76-115">Unity provides great documentation for:</span></span>
1) <span data-ttu-id="d5a76-116">[Удаленное подключение профилировщика Unity к приложениям UWP](https://docs.unity3d.com/Manual/windowsstore-profiler.html)</span><span class="sxs-lookup"><span data-stu-id="d5a76-116">How to connect the [Unity profiler to UWP applications remotely](https://docs.unity3d.com/Manual/windowsstore-profiler.html)</span></span>
2) <span data-ttu-id="d5a76-117">[Эффективная диагностика проблем с производительностью с помощью профилировщика Unity](https://unity3d.com/learn/tutorials/temas/performance-optimization/diagnosing-performance-problems-using-profiler-window)</span><span class="sxs-lookup"><span data-stu-id="d5a76-117">How to effectively [diagnose performance problems with the Unity Profiler](https://unity3d.com/learn/tutorials/temas/performance-optimization/diagnosing-performance-problems-using-profiler-window)</span></span>

>[!NOTE]
> <span data-ttu-id="d5a76-118">Подключив профилировщик Unity и добавив профилировщик GPU с помощью действия *Add Profiler* (Добавить профилировщик) в верхнем правом углу, в средней области профилировщика вы увидите, сколько времени тратится на работу центрального и графического процессоров.</span><span class="sxs-lookup"><span data-stu-id="d5a76-118">With the Unity Profiler connected and after adding the GPU profiler (see *Add Profiler* in top right corner), one can see how much time is being spent on the CPU & GPU respectively in the middle of the profiler.</span></span> <span data-ttu-id="d5a76-119">Это позволяет разработчику быстро получить приближенные сведения о требованиях приложения к ЦП или GPU.</span><span class="sxs-lookup"><span data-stu-id="d5a76-119">This allows the developer to get a quick approximation if their application is CPU or GPU bounded.</span></span>
>
> ![ЦП и GPU в Unity](images/unity-profiler-cpu-gpu.png)

## <a name="cpu-performance-recommendations"></a><span data-ttu-id="d5a76-121">Рекомендации по производительности ЦП</span><span class="sxs-lookup"><span data-stu-id="d5a76-121">CPU performance recommendations</span></span>

<span data-ttu-id="d5a76-122">Ниже приводятся более подробные рекомендации по производительности, которые особенно касаются разработки на C# в Unity.</span><span class="sxs-lookup"><span data-stu-id="d5a76-122">The content below covers more in-depth performance practices, especially targeted for Unity & C# development.</span></span>

#### <a name="cache-references"></a><span data-ttu-id="d5a76-123">Кэширование ссылок</span><span class="sxs-lookup"><span data-stu-id="d5a76-123">Cache references</span></span>

<span data-ttu-id="d5a76-124">Мы рекомендуем кэшировать ссылки на все важные компоненты и игровые объекты во время инициализации, так как повтор вызовов функций, например *[GetComponent\<T>()](https://docs.unity3d.com/ScriptReference/GameObject.GetComponent.html)* и [Camera.main](https://docs.unity3d.com/ScriptReference/Camera-main.html), требует больше ресурсов памяти чем хранение указателя.</span><span class="sxs-lookup"><span data-stu-id="d5a76-124">We recommend caching references to all relevant components and GameObjects at initialization because repeating function calls such as *[GetComponent\<T>()](https://docs.unity3d.com/ScriptReference/GameObject.GetComponent.html)* and [Camera.main](https://docs.unity3d.com/ScriptReference/Camera-main.html) are more expensive relative to the memory cost to store a pointer.</span></span> <span data-ttu-id="d5a76-125">.</span><span class="sxs-lookup"><span data-stu-id="d5a76-125">.</span></span> <span data-ttu-id="d5a76-126">*Camera.main* фактически использует *[FindGameObjectsWithTag()](https://docs.unity3d.com/ScriptReference/GameObject.FindGameObjectsWithTag.html)* для выполнения ресурсоемкого поиска объекта камеры в графе сцены по тегу *MainCamera*.</span><span class="sxs-lookup"><span data-stu-id="d5a76-126">*Camera.main* just uses *[FindGameObjectsWithTag()](https://docs.unity3d.com/ScriptReference/GameObject.FindGameObjectsWithTag.html)* underneath, which expensively searches your scene graph for a camera object with the *"MainCamera"* tag.</span></span>

```CS
using UnityEngine;
using System.Collections;

public class ExampleClass : MonoBehaviour
{
    private Camera cam;
    private CustomComponent comp;

    void Start() 
    {
        cam = Camera.main;
        comp = GetComponent<CustomComponent>();
    }

    void Update()
    {
        // Good
        this.transform.position = cam.transform.position + cam.transform.forward * 10.0f;

        // Bad
        this.transform.position = Camera.main.transform.position + Camera.main.transform.forward * 10.0f;

        // Good
        comp.DoSomethingAwesome();

        // Bad
        GetComponent<CustomComponent>().DoSomethingAwesome();
    }
}
```

>[!NOTE] 
> <span data-ttu-id="d5a76-127">Отказ от использования GetComponent(string)</span><span class="sxs-lookup"><span data-stu-id="d5a76-127">Avoid GetComponent(string)</span></span> <br/>
> <span data-ttu-id="d5a76-128">При использовании *[GetComponent()](https://docs.unity3d.com/ScriptReference/GameObject.GetComponent.html)* существует несколько разных перегрузок.</span><span class="sxs-lookup"><span data-stu-id="d5a76-128">When using *[GetComponent()](https://docs.unity3d.com/ScriptReference/GameObject.GetComponent.html)*, there are a handful of different overloads.</span></span> <span data-ttu-id="d5a76-129">Важно всегда использовать реализации на основе конкретных типов, но не перегрузку поиска на основе строк.</span><span class="sxs-lookup"><span data-stu-id="d5a76-129">It is important to always use the Type-based implementations and never the string-based searching overload.</span></span> <span data-ttu-id="d5a76-130">Поиск по строке в сцене значительно дороже, чем поиск по типу.</span><span class="sxs-lookup"><span data-stu-id="d5a76-130">Searching by string in your scene is significantly more costly than searching by Type.</span></span> <br/>
> <span data-ttu-id="d5a76-131">(Хорошо) Component GetComponent(Type type)</span><span class="sxs-lookup"><span data-stu-id="d5a76-131">(Good) Component GetComponent(Type type)</span></span> <br/>
> <span data-ttu-id="d5a76-132">(Хорошо) T GetComponent\<T>()</span><span class="sxs-lookup"><span data-stu-id="d5a76-132">(Good) T GetComponent\<T>()</span></span> <br/>
> <span data-ttu-id="d5a76-133">(Плохо) Component GetComponent(string)</span><span class="sxs-lookup"><span data-stu-id="d5a76-133">(Bad) Component GetComponent(string)></span></span> <br/>

#### <a name="avoid-expensive-operations"></a><span data-ttu-id="d5a76-134">Отказ от дорогостоящих операций</span><span class="sxs-lookup"><span data-stu-id="d5a76-134">Avoid expensive operations</span></span>

1) <span data-ttu-id="d5a76-135">**Отказ от использования [LINQ](https://docs.microsoft.com/dotnet/csharp/programming-guide/concepts/linq/getting-started-with-linq)**</span><span class="sxs-lookup"><span data-stu-id="d5a76-135">**Avoid use of [LINQ](https://docs.microsoft.com/dotnet/csharp/programming-guide/concepts/linq/getting-started-with-linq)**</span></span>

    <span data-ttu-id="d5a76-136">Хотя запросы LINQ могут быть очень понятыми и простыми для чтения и записи, обычно они требуют больше ресурсов для вычислений и хранения по сравнению с использованием написанных вручную алгоритмов.</span><span class="sxs-lookup"><span data-stu-id="d5a76-136">Although LINQ can be clean and easy to read and write, it generally requires more computation and memory than if you wrote the algorithm manually.</span></span>

    ```CS
    // Example Code
    using System.Linq;

    List<int> data = new List<int>();
    data.Any(x => x > 10);

    var result = from x in data
                 where x > 10
                 select x;
    ```

2) <span data-ttu-id="d5a76-137">**Распространенные API Unity**</span><span class="sxs-lookup"><span data-stu-id="d5a76-137">**Common Unity APIs**</span></span>

    <span data-ttu-id="d5a76-138">Некоторые API Unity при всей очевидной пользе могут быть достаточно ресурсоемкими.</span><span class="sxs-lookup"><span data-stu-id="d5a76-138">Certain Unity APIs, although useful, can be expensive to execute.</span></span> <span data-ttu-id="d5a76-139">Большинство из них выполняют поиск соответствующих игровых объектов по всему графу сцены.</span><span class="sxs-lookup"><span data-stu-id="d5a76-139">Most of these involve searching your entire scene graph for some matching list of GameObjects.</span></span> <span data-ttu-id="d5a76-140">Обычно этих операций можно избежать, кэшируя ссылки или создав компонент управления игровыми объектами для отслеживания ссылок во время выполнения.</span><span class="sxs-lookup"><span data-stu-id="d5a76-140">These operations can generally be avoided by caching references or implementing a manager component for the GameObjects to track the references at runtime.</span></span>

    ```csharp
        GameObject.SendMessage()
        GameObject.BroadcastMessage()
        UnityEngine.Object.Find()
        UnityEngine.Object.FindWithTag()
        UnityEngine.Object.FindObjectOfType()
        UnityEngine.Object.FindObjectsOfType()
        UnityEngine.Object.FindGameObjectsWithTag()
        UnityEngine.Object.FindGameObjectsWithTag()
    ```

>[!NOTE]
> <span data-ttu-id="d5a76-141">Удалите все *[SendMessage()](https://docs.unity3d.com/ScriptReference/GameObject.SendMessage.html)* и *[BroadcastMessage()](https://docs.unity3d.com/ScriptReference/GameObject.BroadcastMessage.html)* любой ценой.</span><span class="sxs-lookup"><span data-stu-id="d5a76-141">*[SendMessage()](https://docs.unity3d.com/ScriptReference/GameObject.SendMessage.html)* and *[BroadcastMessage()](https://docs.unity3d.com/ScriptReference/GameObject.BroadcastMessage.html)* should be eliminated at all costs.</span></span> <span data-ttu-id="d5a76-142">Эти функции работают на три порядка медленнее, чем прямые вызовы функций.</span><span class="sxs-lookup"><span data-stu-id="d5a76-142">These functions can be on the order of 1000x slower than direct function calls.</span></span>

3) <span data-ttu-id="d5a76-143">**Остерегайтесь упаковки-преобразования**</span><span class="sxs-lookup"><span data-stu-id="d5a76-143">**Beware of boxing**</span></span>

    <span data-ttu-id="d5a76-144">Концепция [упаковки-преобразования](https://docs.microsoft.com/dotnet/csharp/programming-guide/types/boxing-and-unboxing) очень важна в языке и среде выполнения C#.</span><span class="sxs-lookup"><span data-stu-id="d5a76-144">[Boxing](https://docs.microsoft.com/dotnet/csharp/programming-guide/types/boxing-and-unboxing) is a core concept of the C# language and runtime.</span></span> <span data-ttu-id="d5a76-145">Так называют процесс создания переменных со ссылочным типом в виде оболочек для переменных со значениями типа, такими как `char`, `int`, `bool` и т. д.</span><span class="sxs-lookup"><span data-stu-id="d5a76-145">It's the process of wrapping value-typed variables such as `char`, `int`, `bool`, etc. into reference-typed variables.</span></span> <span data-ttu-id="d5a76-146">Если переменная со значением типа "упакована", она помещается в объект `System.Object`, который хранится в управляемой куче.</span><span class="sxs-lookup"><span data-stu-id="d5a76-146">When a value-typed variable is "boxed", it's wrapped in a `System.Object`, which is stored on the managed heap.</span></span> <span data-ttu-id="d5a76-147">Для нее выделяется память и ее нужно обрабатывать сборщиком мусора после освобождения.</span><span class="sxs-lookup"><span data-stu-id="d5a76-147">Memory is allocated and eventually when disposed must be processed by the garbage collector.</span></span> <span data-ttu-id="d5a76-148">Такие процессы выделения и освобождения ресурсов приводят к снижению производительности, а во многих случаях их можно убрать или легко заменить на менее дорогостоящую альтернативу.</span><span class="sxs-lookup"><span data-stu-id="d5a76-148">These allocations and deallocations incur a performance cost and in many scenarios are unnecessary or can be easily replaced by a less expensive alternative.</span></span>

    <span data-ttu-id="d5a76-149">Чтобы избежать упаковки, убедитесь, что переменные, поля и свойства, в которых хранятся числовые типы и структуры (включая `Nullable<T>`), строго типизированы как конкретные типы, такие как `int`, `float?` или `MyStruct`, вместо использования объекта.</span><span class="sxs-lookup"><span data-stu-id="d5a76-149">To avoid boxing, be sure that the variables, fields, and properties in which you store numeric types and structs (including `Nullable<T>`) are strongly typed as specific types such as `int`, `float?` or `MyStruct`, instead of using object.</span></span>  <span data-ttu-id="d5a76-150">Если эти объекты помещаются в список, обязательно используйте строго типизированный список, например `List<int>`, а не `List<object>` или `ArrayList`.</span><span class="sxs-lookup"><span data-stu-id="d5a76-150">If putting these objects into a list, be sure to use a strongly typed list such as `List<int>` rather than `List<object>` or `ArrayList`.</span></span>

    <span data-ttu-id="d5a76-151">**Пример упаковки-преобразования в C#**</span><span class="sxs-lookup"><span data-stu-id="d5a76-151">**Example of boxing in C#**</span></span>

    ```csharp
    // boolean value type is boxed into object boxedMyVar on the heap
    bool myVar = true;
    object boxedMyVar = myVar;
    ```

#### <a name="repeating-code-paths"></a><span data-ttu-id="d5a76-152">Повторяющиеся пути кода</span><span class="sxs-lookup"><span data-stu-id="d5a76-152">Repeating code paths</span></span>

<span data-ttu-id="d5a76-153">Любые повторяющиеся функции обратного вызова в Unity (например,</span><span class="sxs-lookup"><span data-stu-id="d5a76-153">Any repeating Unity callback functions (i.e</span></span> <span data-ttu-id="d5a76-154">Update), которые выполняются много раз каждую секунду и (или) для каждого кадра, следует обдумывать тщательно.</span><span class="sxs-lookup"><span data-stu-id="d5a76-154">Update) that are executed many times per second and/or frame should be written carefully.</span></span> <span data-ttu-id="d5a76-155">Любые дорогостоящие операции в этом коде будут иметь огромное и стабильное влияние на производительность.</span><span class="sxs-lookup"><span data-stu-id="d5a76-155">Any expensive operations here will have huge and consistent impact on performance.</span></span>

1) <span data-ttu-id="d5a76-156">**Пустые функции обратного вызова**</span><span class="sxs-lookup"><span data-stu-id="d5a76-156">**Empty callback functions**</span></span>

    <span data-ttu-id="d5a76-157">Несмотря на внешнюю безобидность приведенного ниже кода приложения, эти пустые обратные вызовы могут быть очень ресурсоемкими, особенно учитывая, что каждый скрипт Unity выполняет автоматическую инициализацию с помощью метода Update.</span><span class="sxs-lookup"><span data-stu-id="d5a76-157">Although the code below may seem innocent to leave in your application, especially since every Unity script auto-initializes with an Update method, these empty callbacks can become expensive.</span></span> <span data-ttu-id="d5a76-158">Unity придется постоянно переключаться между неуправляемой и управляемой частью кода, то есть между кодом UnityEngine и кодом приложения.</span><span class="sxs-lookup"><span data-stu-id="d5a76-158">Unity operates back and forth between an unmanaged and managed code boundary, between UnityEngine code and your application code.</span></span> <span data-ttu-id="d5a76-159">Такое переключение контекста на этой границе требует много ресурсов, даже если не выполняется никаких действий.</span><span class="sxs-lookup"><span data-stu-id="d5a76-159">Context switching over this bridge is fairly expensive, even if there's nothing to execute.</span></span> <span data-ttu-id="d5a76-160">Это особенно проблематично, если приложение использует сотни игровых объектов, компоненты которых имеют повторяющиеся пустые обратные вызовы Unity.</span><span class="sxs-lookup"><span data-stu-id="d5a76-160">This becomes especially problematic if your app has 100s of GameObjects with components that have empty repeating Unity callbacks.</span></span>

    ```CS
    void Update()
    {
    }
    ```

>[!NOTE]
> <span data-ttu-id="d5a76-161">Update() служит самым ярким примером этой проблемы с производительностью, но некоторые другие повторяющиеся обратные вызовы Unity могут оказаться не менее или даже более серьезными, как например следующие: FixedUpdate(), LateUpdate(), OnPostRender(), OnPreRender(), OnRenderImage() и т. п.</span><span class="sxs-lookup"><span data-stu-id="d5a76-161">Update() is the most common manifestation of this performance issue but other repeating Unity callbacks, such as the following can be equally as bad, if not worse: FixedUpdate(), LateUpdate(), OnPostRender", OnPreRender(), OnRenderImage(), etc.</span></span> 

2) <span data-ttu-id="d5a76-162">**Однократное выполнение операций для каждого кадра**</span><span class="sxs-lookup"><span data-stu-id="d5a76-162">**Operations to favor running once per frame**</span></span>

    <span data-ttu-id="d5a76-163">Следующие API Unity содержат операции, типичные для многих голографических приложений.</span><span class="sxs-lookup"><span data-stu-id="d5a76-163">The following Unity APIs are common operations for many Holographic Apps.</span></span> <span data-ttu-id="d5a76-164">Хотя и не всегда, результаты таких функций часто можно вычислять один раз за кадр и повторно использовать в приложении для всего этого кадра.</span><span class="sxs-lookup"><span data-stu-id="d5a76-164">Although not always possible, the results from these functions can commonly be computed once and the results reutilized across the application for a given frame.</span></span>

    <span data-ttu-id="d5a76-165">а) Мы рекомендуем выделить один отдельный класс или службу, чтобы обработать Raycast для взгляда на сцену и повторно использовать полученный результат во всех остальных компонентах сцены, не повторяя идентичные операции Raycast для каждого компонента.</span><span class="sxs-lookup"><span data-stu-id="d5a76-165">a) It's good practice to have a dedicated Singleton class or service to handle your gaze Raycast into the scene and then reuse this result in all other scene components, instead of making repeated and identical Raycast operations by each component.</span></span> <span data-ttu-id="d5a76-166">В некоторых приложениях нужно выполнять Raycast из разных позиций или с разными [LayerMask](https://docs.unity3d.com/ScriptReference/LayerMask.html).</span><span class="sxs-lookup"><span data-stu-id="d5a76-166">Some applications may require raycasts from different origins or against different [LayerMasks](https://docs.unity3d.com/ScriptReference/LayerMask.html).</span></span>
    
    ```csharp
        UnityEngine.Physics.Raycast()
        UnityEngine.Physics.RaycastAll()
    ```

    <span data-ttu-id="d5a76-167">б) Избегайте операций с методом GetComponent() в повторяющихся обратных вызовах Unity, таких как Update(), используя [кэширование ссылок](#cache-references) в Start () или Awake().</span><span class="sxs-lookup"><span data-stu-id="d5a76-167">b) Avoid GetComponent() operations in repeated Unity callbacks like Update() by [caching references](#cache-references) in Start() or Awake()</span></span>
    
    ```csharp
        UnityEngine.Object.GetComponent()
    ```

    <span data-ttu-id="d5a76-168">в) Мы рекомендуем по возможности создавать экземпляры всех объектов при инициализации и применять [пулы объектов](#object-pooling) для повторного использования игровых объектов в ходе работы приложения.</span><span class="sxs-lookup"><span data-stu-id="d5a76-168">c) It's good practice to instantiate all objects, if possible, at initialization and use [object pooling](#object-pooling) to recycle and reuse GameObjects throughout runtime of your application</span></span>

    ```csharp
        UnityEngine.Object.Instantiate()
    ```

3) <span data-ttu-id="d5a76-169">**Отказ от использования интерфейсов и виртуальных конструкций**</span><span class="sxs-lookup"><span data-stu-id="d5a76-169">**Avoid interfaces and virtual constructs**</span></span>

    <span data-ttu-id="d5a76-170">Вызов функций через интерфейсы вместо прямого обращения к объектам либо вызов виртуальных функций часто будут гораздо более ресурсоемкими, чем использование прямых конструкций или прямых вызовов функций.</span><span class="sxs-lookup"><span data-stu-id="d5a76-170">Invoking function calls through interfaces vs direct objects or calling virtual functions can often be much more expensive than using direct constructs or direct function calls.</span></span> <span data-ttu-id="d5a76-171">Если виртуальная функция или интерфейс являются необязательными, их следует удалить.</span><span class="sxs-lookup"><span data-stu-id="d5a76-171">If the virtual function or interface is unnecessary, then it should be removed.</span></span> <span data-ttu-id="d5a76-172">Однако для этих подходов ухудшение производительности будет хорошим компромиссом, если их применение упрощает совместную разработку, повышает удобочитаемость или удобство поддержки кода.</span><span class="sxs-lookup"><span data-stu-id="d5a76-172">However, the performance hit for these approaches is worth the trade-off if using them simplifies development collaboration, code readability, and code maintainability.</span></span>

    <span data-ttu-id="d5a76-173">В общем случае мы не рекомендуем объявлять поля и функции виртуальными, если нет четкого понимания, что этот элемент придется перезаписывать.</span><span class="sxs-lookup"><span data-stu-id="d5a76-173">Generally, the recommendation is to not mark fields and functions as virtual unless there's a clear expectation that this member needs to be overwritten.</span></span> <span data-ttu-id="d5a76-174">Разработчикам нужно быть особенно осторожными в путях кода с высокой частотой исполнения, то есть вызываемых один и более раз для каждого кадра, таких как метод `UpdateUI()`.</span><span class="sxs-lookup"><span data-stu-id="d5a76-174">One should be especially careful around high-frequency code paths that are called many times per frame or even once per frame such as an `UpdateUI()` method.</span></span>

4) <span data-ttu-id="d5a76-175">**Отказ от передачи структур по значению**</span><span class="sxs-lookup"><span data-stu-id="d5a76-175">**Avoid passing structs by value**</span></span>

    <span data-ttu-id="d5a76-176">В отличие от классов, для структуры типы определяются значением, и при прямой передаче в функцию их содержимое копируется в только что созданный экземпляр.</span><span class="sxs-lookup"><span data-stu-id="d5a76-176">Unlike classes, structs are value-types and when passed directly to a function, their contents are copied into a newly created instance.</span></span> <span data-ttu-id="d5a76-177">Эта копия повышает нагрузку на ЦП и требует дополнительной памяти из стека.</span><span class="sxs-lookup"><span data-stu-id="d5a76-177">This copy adds CPU cost, as well as additional memory on the stack.</span></span> <span data-ttu-id="d5a76-178">Нагрузка небольших структур на ресурсы обычно минимальна и может считаться приемлемой.</span><span class="sxs-lookup"><span data-stu-id="d5a76-178">For small structs, the effect is minimal and thus acceptable.</span></span> <span data-ttu-id="d5a76-179">Но для тех функций, которые несколько раз вызываются для каждого кадра и (или) принимают крупные структуры, по возможности измените определение функции так, чтобы передавать им ссылку.</span><span class="sxs-lookup"><span data-stu-id="d5a76-179">However, for functions repeatedly invoked every frame as well as functions taking large structs, if possible modify the function definition to pass by reference.</span></span> [<span data-ttu-id="d5a76-180">Дополнительные сведения см. здесь</span><span class="sxs-lookup"><span data-stu-id="d5a76-180">Learn more here</span></span>](https://docs.microsoft.com/dotnet/csharp/programming-guide/classes-and-structs/how-to-know-the-difference-passing-a-struct-and-passing-a-class-to-a-method)

#### <a name="miscellaneous"></a><span data-ttu-id="d5a76-181">Прочее</span><span class="sxs-lookup"><span data-stu-id="d5a76-181">Miscellaneous</span></span>

1) <span data-ttu-id="d5a76-182">**Физика**</span><span class="sxs-lookup"><span data-stu-id="d5a76-182">**Physics**</span></span>

    <span data-ttu-id="d5a76-183">а) Как правило, для улучшения обработки физики следует ограничить количество времени или количество итераций в секунду, затрачиваемых на ее обработку.</span><span class="sxs-lookup"><span data-stu-id="d5a76-183">a) Generally, the easiest way to improve physics is to limit the amount of time spent on Physics or the number of iterations per second.</span></span> <span data-ttu-id="d5a76-184">Это снизит точность имитации.</span><span class="sxs-lookup"><span data-stu-id="d5a76-184">This will reduce simulation accuracy.</span></span> <span data-ttu-id="d5a76-185">См. документацию по [TimeManager](https://docs.unity3d.com/Manual/class-TimeManager.html) в Unity.</span><span class="sxs-lookup"><span data-stu-id="d5a76-185">See [TimeManager](https://docs.unity3d.com/Manual/class-TimeManager.html) in Unity</span></span>

    <span data-ttu-id="d5a76-186">б) Типы коллайдеров в Unity могут иметь очень разные характеристики производительности.</span><span class="sxs-lookup"><span data-stu-id="d5a76-186">b) The types of colliders in Unity have widely different performance characteristics.</span></span> <span data-ttu-id="d5a76-187">В приведенном ниже списке коллайдеры перечислены в порядке уменьшения производительности, слева направо.</span><span class="sxs-lookup"><span data-stu-id="d5a76-187">The order below lists the most performant colliders to least performant colliders from left to right.</span></span> <span data-ttu-id="d5a76-188">Важнее всего избегать коллайдеров сетки, которые значительно требовательнее к ресурсам, чем коллайдеры примитивов.</span><span class="sxs-lookup"><span data-stu-id="d5a76-188">It's important to avoid Mesh Colliders, which are substantially more expensive than the primitive colliders.</span></span>

    <span data-ttu-id="d5a76-189">Сфера < Капсула < Коробка <<< Сетка (выпуклая) < Сетка (невыпуклая)</span><span class="sxs-lookup"><span data-stu-id="d5a76-189">Sphere < Capsule < Box <<< Mesh (Convex) < Mesh (non-Convex)</span></span>

    <span data-ttu-id="d5a76-190">Дополнительные сведения см. в статье [с рекомендациями по обработке физики в Unity](https://unity3d.com/learn/tutorials/topics/physics/physics-best-practices).</span><span class="sxs-lookup"><span data-stu-id="d5a76-190">See [Unity Physics Best Practices](https://unity3d.com/learn/tutorials/topics/physics/physics-best-practices) for more info</span></span>

2) <span data-ttu-id="d5a76-191">**Анимации**</span><span class="sxs-lookup"><span data-stu-id="d5a76-191">**Animations**</span></span>

    <span data-ttu-id="d5a76-192">Избавьтесь от анимации простоя, отключив компонент Animator (отключение объекта Game не дает такого эффекта).</span><span class="sxs-lookup"><span data-stu-id="d5a76-192">Disable idle animations by disabling the Animator component (disabling the game object won't have the same effect).</span></span> <span data-ttu-id="d5a76-193">Избегайте шаблонов разработки, в которых аниматор в цикле постоянно присваивает значение одному параметру.</span><span class="sxs-lookup"><span data-stu-id="d5a76-193">Avoid design patterns where an animator sits in a loop setting a value to the same thing.</span></span> <span data-ttu-id="d5a76-194">Такой метод создает значительную нагрузку на ресурсы без видимого эффекта в приложении.</span><span class="sxs-lookup"><span data-stu-id="d5a76-194">There's considerable overhead for this technique, with no effect on the application.</span></span> [<span data-ttu-id="d5a76-195">Дополнительные сведения доступны здесь.</span><span class="sxs-lookup"><span data-stu-id="d5a76-195">Learn more here.</span></span>](https://docs.unity3d.com/Manual/MecanimPeformanceandOptimization.html)

3) <span data-ttu-id="d5a76-196">**Сложные алгоритмы**</span><span class="sxs-lookup"><span data-stu-id="d5a76-196">**Complex algorithms**</span></span>

    <span data-ttu-id="d5a76-197">Если приложение использует сложные алгоритмы, такие как обратная кинематика, поиск пути и т. д., попробуйте найти более простой подход или оптимизируйте соответствующие параметры по производительности.</span><span class="sxs-lookup"><span data-stu-id="d5a76-197">If your application is using complex algorithms such as inverse kinematics, path finding, etc, look to find a simpler approach or adjust relevant settings for their performance</span></span>

## <a name="cpu-to-gpu-performance-recommendations"></a><span data-ttu-id="d5a76-198">Рекомендации по производительности взаимодействия ЦП с GPU</span><span class="sxs-lookup"><span data-stu-id="d5a76-198">CPU-to-GPU performance recommendations</span></span>

<span data-ttu-id="d5a76-199">Как правило, производительность взаимодействия ЦП с GPU упирается в **вызовы отрисовки**, передаваемые на графическую плату.</span><span class="sxs-lookup"><span data-stu-id="d5a76-199">Generally, CPU-to-GPU performance comes down to the **draw calls** submitted to the graphics card.</span></span> <span data-ttu-id="d5a76-200">Чтобы повысить эту производительность, вызовы отрисовки следует стратегически **уменьшать** и (или) **реструктуризовать** до достижения оптимальных результатов.</span><span class="sxs-lookup"><span data-stu-id="d5a76-200">To improve performance, draw calls need to be strategically **a) reduced** or **b) restructured** for optimal results.</span></span> <span data-ttu-id="d5a76-201">Поскольку вызовы отрисовки сами по себе требуют много ресурсов, снижение их количества позволит сократить общий объем работы.</span><span class="sxs-lookup"><span data-stu-id="d5a76-201">Since draw calls themselves are resource-intensive, reducing them will reduce overall work required.</span></span> <span data-ttu-id="d5a76-202">Кроме того, изменения состояния между вызовами отрисовки требуют ресурсоемких операций по проверке и переводу в графическом драйвере, а значит реструктуризация вызовов отрисовки в приложении для ограничения изменений состояния (т. е.</span><span class="sxs-lookup"><span data-stu-id="d5a76-202">Further, state changes between draw calls require costly validation and translation steps in the graphics driver and thus, restructuring of your application's draw calls to limit state changes (i.e</span></span> <span data-ttu-id="d5a76-203">разных материалов и т. д.) может повысить производительность.</span><span class="sxs-lookup"><span data-stu-id="d5a76-203">different materials, etc) can boost performance.</span></span>

<span data-ttu-id="d5a76-204">В документации по Unity есть отличная статья с обзорным и подробным описанием пакетной обработки вызовов на этой платформе.</span><span class="sxs-lookup"><span data-stu-id="d5a76-204">Unity has a great article that gives an overview and dives into batching draw calls for their platform.</span></span>
- [<span data-ttu-id="d5a76-205">Пакетная обработка вызовов отрисовки в Unity</span><span class="sxs-lookup"><span data-stu-id="d5a76-205">Unity Draw Call Batching</span></span>](https://docs.unity3d.com/Manual/DrawCallBatching.html)

#### <a name="single-pass-instanced-rendering"></a><span data-ttu-id="d5a76-206">Однопроходная отрисовка экземпляра</span><span class="sxs-lookup"><span data-stu-id="d5a76-206">Single pass instanced rendering</span></span>

<span data-ttu-id="d5a76-207">Однопроходная отрисовка экземпляра в Unity позволяет уменьшить число вызовов отрисовки для каждого глаза до одного экземпляра.</span><span class="sxs-lookup"><span data-stu-id="d5a76-207">Single Pass Instanced Rendering in Unity allows for draw calls for each eye to be reduced down to one instanced draw call.</span></span> <span data-ttu-id="d5a76-208">Благодаря согласованности кэша между двумя вызовами отрисовки будет заметно и некоторое улучшение производительности GPU.</span><span class="sxs-lookup"><span data-stu-id="d5a76-208">Because of cache coherency between two draw calls, there's also some performance improvement on the GPU as well.</span></span>

<span data-ttu-id="d5a76-209">Включение этой функции в проекте Unity</span><span class="sxs-lookup"><span data-stu-id="d5a76-209">To enable this feature in your Unity Project</span></span>
1)  <span data-ttu-id="d5a76-210">Откройте **Player XR Settings** (Параметры XR проигрывателя), выбрав элементы **Edit** > **Project Settings** > **Player** > **XR Settings** (Редактирование > Параметры проекта > Проигрыватель > Параметры XR)</span><span class="sxs-lookup"><span data-stu-id="d5a76-210">Open **Player XR Settings** (go to **Edit** > **Project Settings** > **Player** > **XR Settings**)</span></span>
2) <span data-ttu-id="d5a76-211">Выберите **Single Pass Instanced** (Однопроходный с экземпляром) в раскрывающемся меню **Stereo Rendering Method** (Метод стереоскопической отрисовки), установив также флажок **Virtual Reality Supported** (Поддержка виртуальной реальности)</span><span class="sxs-lookup"><span data-stu-id="d5a76-211">Select **Single Pass Instanced** from the **Stereo Rendering Method** drop-down menu (**Virtual Reality Supported** checkbox must be checked)</span></span>

<span data-ttu-id="d5a76-212">Ознакомьтесь со следующими статьями Unity, чтобы получить подробные сведения об этом подходе к отрисовке.</span><span class="sxs-lookup"><span data-stu-id="d5a76-212">Read the following articles from Unity for details with this rendering approach.</span></span>
- [<span data-ttu-id="d5a76-213">Максимизация производительности дополненной реальности и виртуальной реальности с помощью расширенной стереоскопической отрисовки</span><span class="sxs-lookup"><span data-stu-id="d5a76-213">How to maximize AR and VR performance with advanced stereo rendering</span></span>](https://blogs.unity3d.com/2017/11/21/how-to-maximize-ar-and-vr-performance-with-advanced-stereo-rendering/)
- [<span data-ttu-id="d5a76-214">Однопроходная отрисовка экземпляра</span><span class="sxs-lookup"><span data-stu-id="d5a76-214">Single Pass Instancing</span></span>](https://docs.unity3d.com/Manual/SinglePassInstancing.html) 

>[!NOTE]
> <span data-ttu-id="d5a76-215">Одна из распространенных проблем при однопроходной отрисовке с использованием экземпляра возникает в тех случаях, если уже существующие пользовательские шейдеры не поддерживают создание экземпляра.</span><span class="sxs-lookup"><span data-stu-id="d5a76-215">One common issue with Single Pass Instanced Rendering occurs if developers already have existing custom shaders not written for instancing.</span></span> <span data-ttu-id="d5a76-216">После включения этой возможности разработчики заметят, что некоторые игровые объекты отрисовываются только для одного глаза.</span><span class="sxs-lookup"><span data-stu-id="d5a76-216">After enabling this feature, developers may notice some GameObjects only render in one eye.</span></span> <span data-ttu-id="d5a76-217">Это связано с тем, что соответствующие пользовательские шейдеры не имеют нужных свойств для создания экземпляров.</span><span class="sxs-lookup"><span data-stu-id="d5a76-217">This is because the associated custom shaders do not have the appropriate properties for instancing.</span></span>
>
> <span data-ttu-id="d5a76-218">Действия для решения этой проблемы описаны в документе Unity [об однопроходной стереоскопической отрисовке для HoloLens](https://docs.unity3d.com/Manual/SinglePassStereoRenderingHoloLens.html).</span><span class="sxs-lookup"><span data-stu-id="d5a76-218">See [Single Pass Stereo Rendering for HoloLens](https://docs.unity3d.com/Manual/SinglePassStereoRenderingHoloLens.html) from Unity for how to address this problem</span></span>

#### <a name="static-batching"></a><span data-ttu-id="d5a76-219">Пакетная обработка статических объектов</span><span class="sxs-lookup"><span data-stu-id="d5a76-219">Static batching</span></span>

<span data-ttu-id="d5a76-220">Unity поддерживает создание пакетов из нескольких статических объектов, что позволяет снизить число вызовов отрисовки для GPU.</span><span class="sxs-lookup"><span data-stu-id="d5a76-220">Unity is able to batch many static objects to reduce draw calls to the GPU.</span></span> <span data-ttu-id="d5a76-221">Пакетная обработка статических объектов будет нормально работать в Unity для большинства объектов [Renderer](https://docs.unity3d.com/ScriptReference/Renderer.html), которые **имеют одинаковый материал** и **имеют атрибут *Static*** (чтобы присвоить его, выберите объект в Unity и щелкните флажок в верхней правой части окна инспектора).</span><span class="sxs-lookup"><span data-stu-id="d5a76-221">Static Batching works for most [Renderer](https://docs.unity3d.com/ScriptReference/Renderer.html) objects in Unity that **1) share the same material** and **2) are all marked as *Static*** (Select an object in Unity and select the checkbox in the top right of the inspector).</span></span> <span data-ttu-id="d5a76-222">Игровые объекты, имеющие атрибут *Static*, не могут перемещаться на протяжении всего периода работы приложения.</span><span class="sxs-lookup"><span data-stu-id="d5a76-222">GameObjects marked as *Static* cannot be moved throughout your application's runtime.</span></span> <span data-ttu-id="d5a76-223">Это означает, что пакетную обработку статических объектов трудно применить для HoloLens, поскольку здесь почти каждый объект должен быть перемещаемым, масштабируемым и т. д. Для иммерсивных гарнитур пакетная обработка статических объектов позволяет значительно сократить число вызовов отрисовки, а значит и повысить производительность.</span><span class="sxs-lookup"><span data-stu-id="d5a76-223">Thus, static batching can be difficult to leverage on HoloLens where virtually every object needs to be placed, moved, scaled, etc. For immersive headsets, static batching can dramatically reduce draw calls and thus improve performance.</span></span>

<span data-ttu-id="d5a76-224">Дополнительные сведения см. в разделе *о пакетной обработке статических объектов* в статье [Пакетная обработка вызовов отрисовки в Unity](https://docs.unity3d.com/Manual/DrawCallBatching.html).</span><span class="sxs-lookup"><span data-stu-id="d5a76-224">Read *Static Batching* under [Draw Call Batching in Unity](https://docs.unity3d.com/Manual/DrawCallBatching.html) for more details.</span></span>

#### <a name="dynamic-batching"></a><span data-ttu-id="d5a76-225">Пакетная обработка динамических объектов</span><span class="sxs-lookup"><span data-stu-id="d5a76-225">Dynamic batching</span></span>

<span data-ttu-id="d5a76-226">Поскольку при разработке для HoloLens будет затруднительно объявлять объекты *статическими*, компенсировать этот недостаток можно применением пакетной обработки динамических объектов.</span><span class="sxs-lookup"><span data-stu-id="d5a76-226">Since it's problematic to mark objects as *Static* for HoloLens development, dynamic batching can be a great tool to compensate for this lacking feature.</span></span> <span data-ttu-id="d5a76-227">Это будет работать и для иммерсивных гарнитур.</span><span class="sxs-lookup"><span data-stu-id="d5a76-227">It can also be useful on immersive headsets, as well.</span></span> <span data-ttu-id="d5a76-228">Однако пакетная обработка динамических объектов в Unity может быть сложной, поскольку игровые объекты должны иметь **одинаковые материалы** и **соответствовать множеству других критериев**.</span><span class="sxs-lookup"><span data-stu-id="d5a76-228">However, dynamic batching in Unity can be difficult to enable because GameObjects must **a) share the same Material** and **b) meet a long list of other criteria**.</span></span>

<span data-ttu-id="d5a76-229">Полный список этих требований см. в разделе *о пакетной обработке динамических объектов* в статье [Пакетная обработка вызовов отрисовки в Unity](https://docs.unity3d.com/Manual/DrawCallBatching.html).</span><span class="sxs-lookup"><span data-stu-id="d5a76-229">Read *Dynamic Batching* under [Draw Call Batching in Unity](https://docs.unity3d.com/Manual/DrawCallBatching.html) for the full list.</span></span> <span data-ttu-id="d5a76-230">Чаще всего игровые объекты не удается объединить в пакет, поскольку для такой обработки данные о сетке не могут содержать более 300 вершин.</span><span class="sxs-lookup"><span data-stu-id="d5a76-230">Most commonly, GameObjects become invalid to be batched dynamically, because the associated mesh data can be no more than 300 vertices.</span></span>

#### <a name="other-techniques"></a><span data-ttu-id="d5a76-231">Другие методики</span><span class="sxs-lookup"><span data-stu-id="d5a76-231">Other techniques</span></span>

<span data-ttu-id="d5a76-232">Пакетная обработка возможна только в том случае, если несколько игровых объектов имеют один и тот же материал.</span><span class="sxs-lookup"><span data-stu-id="d5a76-232">Batching can only occur if multiple GameObjects are able to share the same material.</span></span> <span data-ttu-id="d5a76-233">Обычно это невозможно из-за того, что для каждого игрового объекта нужна уникальная текстура соответствующего материала.</span><span class="sxs-lookup"><span data-stu-id="d5a76-233">Typically, this will be blocked by the need for GameObjects to have a unique texture for their respective Material.</span></span> <span data-ttu-id="d5a76-234">Существует метод [создания текстурного атласа](https://en.wikipedia.org/wiki/Texture_atlas), при котором несколько текстур объединяются в одну большую текстуру.</span><span class="sxs-lookup"><span data-stu-id="d5a76-234">It's common to combine Textures into one big Texture, a method known as [Texture Atlasing](https://en.wikipedia.org/wiki/Texture_atlas).</span></span>

<span data-ttu-id="d5a76-235">Более того, во всех случаях, где это возможно и оправдано, лучше объединять несколько сеток в один игровой объект.</span><span class="sxs-lookup"><span data-stu-id="d5a76-235">Furthermore, it's preferable to combine meshes into one GameObject where possible and reasonable.</span></span> <span data-ttu-id="d5a76-236">Каждый отрисовщик в Unity будет использовать собственные вызовы отрисовки, и этого можно избежать при одном отрисовщике для объединенной сетки.</span><span class="sxs-lookup"><span data-stu-id="d5a76-236">Each Renderer in Unity will have its associated draw call(s) versus submitting a combined mesh under one Renderer.</span></span>

>[!NOTE]
> <span data-ttu-id="d5a76-237">Изменение свойств в Renderer.material во время выполнения приводит к созданию копии материала, что может нарушить возможность пакетной обработки.</span><span class="sxs-lookup"><span data-stu-id="d5a76-237">Modifying properties of Renderer.material at runtime will create a copy of the Material and thus potentially break batching.</span></span> <span data-ttu-id="d5a76-238">Используйте Renderer.sharedMaterial для изменения свойств общего материала для нескольких игровых объектов.</span><span class="sxs-lookup"><span data-stu-id="d5a76-238">Use Renderer.sharedMaterial to modify shared material properties across GameObjects.</span></span>

## <a name="gpu-performance-recommendations"></a><span data-ttu-id="d5a76-239">Рекомендации по производительности GPU</span><span class="sxs-lookup"><span data-stu-id="d5a76-239">GPU performance recommendations</span></span>

<span data-ttu-id="d5a76-240">Дополнительные сведения об оптимизации отрисовки графических объектов в Unity см. [здесь](https://unity3d.com/learn/tutorials/temas/performance-optimization/optimizing-graphics-rendering-unity-games).</span><span class="sxs-lookup"><span data-stu-id="d5a76-240">Learn more about [optimizing graphics rendering in Unity](https://unity3d.com/learn/tutorials/temas/performance-optimization/optimizing-graphics-rendering-unity-games)</span></span>

### <a name="optimize-depth-buffer-sharing"></a><span data-ttu-id="d5a76-241">Оптимизация совместного использования буфера глубины</span><span class="sxs-lookup"><span data-stu-id="d5a76-241">Optimize depth buffer sharing</span></span>

<span data-ttu-id="d5a76-242">Мы рекомендуем включить параметр **Depth buffer sharing** (Совместное использование буфера глубины) в разделе **Player XR Settings** (Параметры проигрывателя смешанной реальности) для повышения [стабильности голограммы](../platform-capabilities-and-apis/Hologram-stability.md).</span><span class="sxs-lookup"><span data-stu-id="d5a76-242">It's recommended to enable **Depth buffer sharing** under **Player XR Settings** to optimize for [hologram stability](../platform-capabilities-and-apis/Hologram-stability.md).</span></span> <span data-ttu-id="d5a76-243">Но если вы включаете повторное проецирование на поздней стадии на основе глубины с этим параметром, мы рекомендуем выбрать **16-разрядный формат глубины**, а не **24-разрядный**.</span><span class="sxs-lookup"><span data-stu-id="d5a76-243">When enabling depth-based late-stage reprojection with this setting however, it's recommended to select **16-bit depth format** instead of **24-bit depth format**.</span></span> <span data-ttu-id="d5a76-244">16-разрядные буферы глубины существенно снизят нагрузку на пропускную способность (передачу данных) для буфера глубины, а значит и энергопотребление.</span><span class="sxs-lookup"><span data-stu-id="d5a76-244">The 16-bit depth buffers will drastically reduce the bandwidth (and thus power) associated with depth buffer traffic.</span></span> <span data-ttu-id="d5a76-245">Это позволит одновременно снизить энергопотребление и повысить производительность.</span><span class="sxs-lookup"><span data-stu-id="d5a76-245">This can be a big win both in power reduction and performance improvement.</span></span> <span data-ttu-id="d5a76-246">Но использование *16-разрядного формата глубины* может иметь два неприятных последствия.</span><span class="sxs-lookup"><span data-stu-id="d5a76-246">However, there are two possible negative outcomes by using *16-bit depth format*.</span></span>

<span data-ttu-id="d5a76-247">**Z-конфликт**</span><span class="sxs-lookup"><span data-stu-id="d5a76-247">**Z-Fighting**</span></span>

<span data-ttu-id="d5a76-248">Снижение четкости по глубине при 16-разрядном буфере повышает вероятность [Z-конфликтов](https://en.wikipedia.org/wiki/Z-fighting) по сравнению с 24-разрядными буферами.</span><span class="sxs-lookup"><span data-stu-id="d5a76-248">The reduced depth range fidelity makes [z-fighting](https://en.wikipedia.org/wiki/Z-fighting) more likely to occur with 16 bit than 24-bit.</span></span> <span data-ttu-id="d5a76-249">Чтобы избежать таких артефактов, измените ближнюю и дальнюю отсекающие плоскости для [камеры Unity](https://docs.unity3d.com/Manual/class-Camera.html) с учетом снижения разрешения.</span><span class="sxs-lookup"><span data-stu-id="d5a76-249">To avoid these artifacts, modify the near/far clip planes of the [Unity camera](https://docs.unity3d.com/Manual/class-Camera.html) to account for the lower precision.</span></span> <span data-ttu-id="d5a76-250">Для приложений на основе HoloLens дальняя плоскость обрезки в 50 м вместо стандартного для Unity значения 1000 м обычно полностью устраняет Z-конфликты.</span><span class="sxs-lookup"><span data-stu-id="d5a76-250">For HoloLens-based applications, a far clip plane of 50 m instead of the Unity default 1000 m can generally eliminate any z-fighting.</span></span>

<span data-ttu-id="d5a76-251">**Отключение буфера трафаретов**</span><span class="sxs-lookup"><span data-stu-id="d5a76-251">**Disabled Stencil Buffer**</span></span>

<span data-ttu-id="d5a76-252">Если Unity создает [текстуру отрисовки с 16-разрядной глубиной](https://docs.unity3d.com/ScriptReference/RenderTexture-depth.html), буфер трафаретов не создается.</span><span class="sxs-lookup"><span data-stu-id="d5a76-252">When Unity creates a [Render Texture with 16-bit depth](https://docs.unity3d.com/ScriptReference/RenderTexture-depth.html), there's no stencil buffer created.</span></span> <span data-ttu-id="d5a76-253">Согласно документации по Unity, выбор 24-разрядного формата глубины приводит к созданию 24-разрядного z-буфера и 8-разрядного буфера трафаретов (https://docs.unity3d.com/Manual/SL-Stencil.html) (если на устройстве применим 32-разрядный формат, что обычно справедливо для устройств HoloLens).</span><span class="sxs-lookup"><span data-stu-id="d5a76-253">Selecting 24-bit depth format, per Unity documentation, will create a 24-bit z-buffer, as well as an [8-bit stencil buffer] (https://docs.unity3d.com/Manual/SL-Stencil.html) (if 32-bit is applicable on a device, which is generally the case such as HoloLens).</span></span>

### <a name="avoid-full-screen-effects"></a><span data-ttu-id="d5a76-254">Отказ от полноэкранных эффектов</span><span class="sxs-lookup"><span data-stu-id="d5a76-254">Avoid full-screen effects</span></span>

<span data-ttu-id="d5a76-255">Некоторые техники для полного экрана могут быть ресурсоемкими из-за того, что их работа в каждом кадре исчисляется миллионами операций.</span><span class="sxs-lookup"><span data-stu-id="d5a76-255">Techniques that operate on the full screen can be expensive since their order of magnitude is millions of operations every frame.</span></span> <span data-ttu-id="d5a76-256">Мы рекомендуем отказаться от [эффектов постобработки](https://docs.unity3d.com/Manual/PostProcessingOverview.html), таких как сглаживание, свечение и т. п.</span><span class="sxs-lookup"><span data-stu-id="d5a76-256">It's recommended to avoid [post-processing effects](https://docs.unity3d.com/Manual/PostProcessingOverview.html) such as anti-aliasing, bloom, and more.</span></span>

### <a name="optimal-lighting-settings"></a><span data-ttu-id="d5a76-257">Оптимальные параметры освещения</span><span class="sxs-lookup"><span data-stu-id="d5a76-257">Optimal lighting settings</span></span>

<span data-ttu-id="d5a76-258">[Глобальное освещение в реальном времени](https://docs.unity3d.com/Manual/GIIntro.html) в Unity дает потрясающие визуальные результаты, но требует довольно ресурсоемких вычислений.</span><span class="sxs-lookup"><span data-stu-id="d5a76-258">[Real-time Global Illumination](https://docs.unity3d.com/Manual/GIIntro.html) in Unity can provide outstanding visual results but involves expensive lighting calculations.</span></span> <span data-ttu-id="d5a76-259">Мы рекомендуем отключать глобальное освещение в реальном времени для всех сцен Unity. Для этого нужно в разделе **Window** > **Rendering** > **Lighting Settings** (Окно > Отрисовка > Параметры освещения) снять флажок **Real-time Global Illumination** (Глобальное освещение в реальном времени).</span><span class="sxs-lookup"><span data-stu-id="d5a76-259">We recommended disabling real-time Global Illumination for every Unity scene file via **Window** > **Rendering** > **Lighting Settings** > Uncheck **Real-time Global Illumination**.</span></span>

<span data-ttu-id="d5a76-260">Более того, мы рекомендуем отключить все тени, так как они требуют дополнительных ресурсов GPU для сцены Unity.</span><span class="sxs-lookup"><span data-stu-id="d5a76-260">Furthermore, it's recommended to disable all shadow casting as these also add expensive GPU passes onto a Unity scene.</span></span> <span data-ttu-id="d5a76-261">Тени можно отключать отдельно для каждого источника света или глобально через параметры качества.</span><span class="sxs-lookup"><span data-stu-id="d5a76-261">Shadows can be disable per light but can also be controlled holistically via Quality settings.</span></span>

<span data-ttu-id="d5a76-262">Выберите **Edit** > **Project Settings** (Редактировать > Свойства проекта), затем категорию **Quality** (Качество) и укажите вариант **Low Quality** (Низкое качество) для платформы UWP.</span><span class="sxs-lookup"><span data-stu-id="d5a76-262">**Edit** > **Project Settings**, then select the **Quality** category > Select **Low Quality** for the UWP Platform.</span></span> <span data-ttu-id="d5a76-263">Можно также отдельно указать для свойства **Shadows** (Тени) значение **Disable Shadows** (Отключить тени).</span><span class="sxs-lookup"><span data-stu-id="d5a76-263">One can also just set the **Shadows** property to **Disable Shadows**.</span></span>

<span data-ttu-id="d5a76-264">С моделями в Unity рекомендуется использовать просчитанное освещение (baked lighting).</span><span class="sxs-lookup"><span data-stu-id="d5a76-264">We recommended that you use baked lighting with your models in Unity.</span></span>

### <a name="reduce-poly-count"></a><span data-ttu-id="d5a76-265">Уменьшение количества многоугольников</span><span class="sxs-lookup"><span data-stu-id="d5a76-265">Reduce poly count</span></span>

<span data-ttu-id="d5a76-266">Количество полигонов можно снизить следующими способами:</span><span class="sxs-lookup"><span data-stu-id="d5a76-266">Polygon count is reduced by either</span></span>
1) <span data-ttu-id="d5a76-267">Удаление объектов из сцены.</span><span class="sxs-lookup"><span data-stu-id="d5a76-267">Removing objects from a scene</span></span>
2) <span data-ttu-id="d5a76-268">Прореживание ресурсов, которое позволяет снизить количество полигонов для некоторой сетки.</span><span class="sxs-lookup"><span data-stu-id="d5a76-268">Asset decimation, which reduces the number of polygons for a given mesh</span></span>
3) <span data-ttu-id="d5a76-269">Внедрение в приложение [системы уровня детализации](https://docs.unity3d.com/Manual/LevelOfDetail.html), которая отрисовывает более далекие объекты с меньшим числом полигонов без изменения их геометрии.</span><span class="sxs-lookup"><span data-stu-id="d5a76-269">Implementing a [Level of Detail (LOD) System](https://docs.unity3d.com/Manual/LevelOfDetail.html) into your application, which renders far away objects with lower-polygon version of the same geometry</span></span>

### <a name="understanding-shaders-in-unity"></a><span data-ttu-id="d5a76-270">Общие сведения о шейдерах в Unity</span><span class="sxs-lookup"><span data-stu-id="d5a76-270">Understanding shaders in Unity</span></span>

<span data-ttu-id="d5a76-271">Для сравнения производительности шейдеров можно использовать упрощенную оценку среднего числа операций, выполняемых каждым из них в среде выполнения.</span><span class="sxs-lookup"><span data-stu-id="d5a76-271">An easy approximation to compare shaders in performance is to identify the average number of operations each executes at runtime.</span></span> <span data-ttu-id="d5a76-272">В Unity это выполнить очень легко.</span><span class="sxs-lookup"><span data-stu-id="d5a76-272">This can be done easily in Unity.</span></span>

1) <span data-ttu-id="d5a76-273">Выберите нужный ресурс шейдера или материал, затем в верхнем правом углу окна Inspector (Инспектор) выберите значок шестеренки и действие **Select Shader** (Выбрать шейдер).</span><span class="sxs-lookup"><span data-stu-id="d5a76-273">Select your shader asset or select a material, then in the top-right corner of the inspector window, select the gear icon followed by **"Select Shader"**</span></span>

    ![Выбор шейдера в Unity](images/Select-shader-unity.png)
2) <span data-ttu-id="d5a76-275">После выбора ресурса шейдера нажмите кнопку **Compile and show code** (Компилировать и показать код) в окне Inspector (Инспектор).</span><span class="sxs-lookup"><span data-stu-id="d5a76-275">With the shader asset selected, select the **"Compile and show code"** button under the inspector window</span></span>

    ![Компиляция кода шейдера в Unity](images/compile-shader-code-unity.PNG)

3) <span data-ttu-id="d5a76-277">После компиляции найдите раздел статистики в области результатов, где отображается число разных операций для вершинных и пиксельных шейдеров (учтите, что пиксельные шейдеры часто называют фрагментными).</span><span class="sxs-lookup"><span data-stu-id="d5a76-277">After compiling, look for the statistics section in the results with the number of different operations for both the vertex and pixel shader (Note: pixel shaders are often also called fragment shaders)</span></span>

    ![Работа стандартного шейдера Unity](images/unity-standard-shader-compilation.png)

#### <a name="optimize-pixel-shaders"></a><span data-ttu-id="d5a76-279">Оптимизация пиксельных шейдеров</span><span class="sxs-lookup"><span data-stu-id="d5a76-279">Optimize pixel shaders</span></span>

<span data-ttu-id="d5a76-280">Изучая результаты статистики, полученные описанным выше методом, вы можете заметить, что [фрагментный шейдер](https://en.wikipedia.org/wiki/Shader#Pixel_shaders) в среднем выполняет больше операций, чем [вершинный шейдер](https://en.wikipedia.org/wiki/Shader#Vertex_shaders).</span><span class="sxs-lookup"><span data-stu-id="d5a76-280">Looking at the compiled statistic results using the method above, the [fragment shader](https://en.wikipedia.org/wiki/Shader#Pixel_shaders) will generally execute more operations than the [vertex shader](https://en.wikipedia.org/wiki/Shader#Vertex_shaders), on average.</span></span> <span data-ttu-id="d5a76-281">Фрагментный шейдер, также именуемый пиксельным шейдером, выполняется отдельно для каждого пикселя на экране, а вершинный шейдер выполняется только для вершин всех сеток, отрисовываемых на экране.</span><span class="sxs-lookup"><span data-stu-id="d5a76-281">The fragment shader, also known as the pixel shader, is executed per pixel on the screen output while the vertex shader is only executed per-vertex of all meshes being drawn to the screen.</span></span> 

<span data-ttu-id="d5a76-282">Таким образом, фрагментные шейдеры не только выполняют больше операций, чем вершинные (из-за сложных вычислений освещения) но и почти всегда применяются к более крупному набору данных.</span><span class="sxs-lookup"><span data-stu-id="d5a76-282">Thus, not only do fragment shaders have more instructions than vertex shaders because of all the lighting calculations, fragment shaders are almost always executed on a larger dataset.</span></span> <span data-ttu-id="d5a76-283">Например, при размере экрана 2000 на 2000 пикселей фрагментный шейдер будет выполнен 2000 × 2000 = 4 000 000 раз.</span><span class="sxs-lookup"><span data-stu-id="d5a76-283">For example, if the screen output is a 2k by 2k image, then the fragment shader can get executed 2,000\*2,000 = 4,000,000 times.</span></span> <span data-ttu-id="d5a76-284">При отрисовке для двух глаз это число удваивается, так как работают сразу два экрана.</span><span class="sxs-lookup"><span data-stu-id="d5a76-284">If rendering two eyes, this number doubles since there are two screens.</span></span> <span data-ttu-id="d5a76-285">Если приложение смешанной реальности использует несколько проходов, полноэкранные эффекты постобработки или отрисовку нескольких сеток в пределах одного пикселя, это количество еще значительно увеличится.</span><span class="sxs-lookup"><span data-stu-id="d5a76-285">If a mixed reality application has multiple passes, full-screen post-processing effects, or rendering multiple meshes to the same pixel, this number will increase dramatically.</span></span> 

<span data-ttu-id="d5a76-286">Таким образом, снижение числа операций во фрагментных шейдерах обычно значительно больше влияет на производительность, чем аналогичная оптимизация в вершинном шейдере.</span><span class="sxs-lookup"><span data-stu-id="d5a76-286">Therefore, reducing the number of operations in the fragment shader can generally give far greater performance gains over optimizations in the vertex shader.</span></span>

#### <a name="unity-standard-shader-alternatives"></a><span data-ttu-id="d5a76-287">Альтернативы стандартному шейдеру Unity</span><span class="sxs-lookup"><span data-stu-id="d5a76-287">Unity Standard shader alternatives</span></span>

<span data-ttu-id="d5a76-288">Вместо отрисовки на основе физических параметров или другого шейдера высокого качества, попробуйте применить более производительный и более дешевый шейдер.</span><span class="sxs-lookup"><span data-stu-id="d5a76-288">Instead of using a physically based rendering (PBR) or another high-quality shader, look at utilizing a more performant and cheaper shader.</span></span> <span data-ttu-id="d5a76-289">В [наборе средств для смешанной реальности](https://github.com/Microsoft/MixedRealityToolkit-Unity) предоставляется [стандартный шейдер MRTK](https://microsoft.github.io/MixedRealityToolkit-Unity/Documentation/README_MRTKStandardShader.html), который оптимизирован для проектов смешанной реальности.</span><span class="sxs-lookup"><span data-stu-id="d5a76-289">The [Mixed Reality Toolkit](https://github.com/Microsoft/MixedRealityToolkit-Unity) provides the [MRTK standard shader](https://microsoft.github.io/MixedRealityToolkit-Unity/Documentation/README_MRTKStandardShader.html) that has been optimized for mixed reality projects.</span></span>

<span data-ttu-id="d5a76-290">В Unity также доступны упрощенные версии шейдеров (без освещенности, с освещенностью вершин, диффузное освещение и т. д.), которые работают быстрее стандартного шейдера Unity.</span><span class="sxs-lookup"><span data-stu-id="d5a76-290">Unity also provides an unlit, vertex lit, diffuse, and other simplified shader options that are faster compared to the Unity Standard shader.</span></span> <span data-ttu-id="d5a76-291">Дополнительные сведения см. в статье об [использовании и производительности встроенных шейдеров](https://docs.unity3d.com/Manual/shader-Performance.html).</span><span class="sxs-lookup"><span data-stu-id="d5a76-291">See [Usage and Performance of Built-in Shaders](https://docs.unity3d.com/Manual/shader-Performance.html) for more detailed information.</span></span>

#### <a name="shader-preloading"></a><span data-ttu-id="d5a76-292">Предварительная загрузка шейдера</span><span class="sxs-lookup"><span data-stu-id="d5a76-292">Shader preloading</span></span>

<span data-ttu-id="d5a76-293">*Предварительная загрузка шейдера* и некоторые другие приемы позволяют оптимизировать [время загрузки шейдера](https://docs.unity3d.com/Manual/OptimizingShaderLoadTime.html).</span><span class="sxs-lookup"><span data-stu-id="d5a76-293">Use *Shader preloading* and other tricks to optimize [shader load time](https://docs.unity3d.com/Manual/OptimizingShaderLoadTime.html).</span></span> <span data-ttu-id="d5a76-294">В частности, предварительная загрузка шейдера позволяет избежать задержек, связанных с компиляцией шейдера во время выполнения.</span><span class="sxs-lookup"><span data-stu-id="d5a76-294">In particular, shader preloading means you won't see any hitches due to runtime shader compilation.</span></span>

### <a name="limit-overdraw"></a><span data-ttu-id="d5a76-295">Ограничение перерисовки</span><span class="sxs-lookup"><span data-stu-id="d5a76-295">Limit overdraw</span></span>

<span data-ttu-id="d5a76-296">В Unity можно отобразить перерисовку сцены, переключившись на [**меню режима отрисовки**](https://docs.unity3d.com/Manual/ViewModes.html) в верхнем левом углу **представления сцены** и выбрав параметр **Overdraw** (Перерисовка).</span><span class="sxs-lookup"><span data-stu-id="d5a76-296">In Unity, one can display overdraw for their scene, by toggling the [**draw mode menu**](https://docs.unity3d.com/Manual/ViewModes.html) in the top-left corner of the **Scene view** and selecting **Overdraw**.</span></span>

<span data-ttu-id="d5a76-297">Обычно перерисовка устраняется отбрасыванием объектов до того, как они будут отправлены в GPU.</span><span class="sxs-lookup"><span data-stu-id="d5a76-297">Generally, overdraw can be mitigated by culling objects ahead of time before they're sent to the GPU.</span></span> <span data-ttu-id="d5a76-298">Unity предоставляет подробные сведения о реализации [отбрасывания загораживаемых объектов](https://docs.unity3d.com/Manual/OcclusionCulling.html) для этой платформы.</span><span class="sxs-lookup"><span data-stu-id="d5a76-298">Unity provides details on implementing [Occlusion Culling](https://docs.unity3d.com/Manual/OcclusionCulling.html) for their engine.</span></span>

## <a name="memory-recommendations"></a><span data-ttu-id="d5a76-299">Рекомендации по использованию памяти</span><span class="sxs-lookup"><span data-stu-id="d5a76-299">Memory recommendations</span></span>

<span data-ttu-id="d5a76-300">Операции выделения и освобождения памяти в больших объемах могут значительно снижать производительность голографического приложения, что приведет к нестабильному поведению, замиранию кадров и другим неприятным эффектам.</span><span class="sxs-lookup"><span data-stu-id="d5a76-300">Excessive memory allocation & deallocation operations can have adverse effects on your holographic application, resulting in inconsistent performance, frozen frames, and other detrimental behavior.</span></span> <span data-ttu-id="d5a76-301">При разработке в Unity особенно важно понимать особенности использования памяти, так как управление памятью здесь реализовано через сборщик мусора.</span><span class="sxs-lookup"><span data-stu-id="d5a76-301">It's especially important to understand memory considerations when developing in Unity since memory management is controlled by the garbage collector.</span></span>

#### <a name="garbage-collection"></a><span data-ttu-id="d5a76-302">Сборка мусора</span><span class="sxs-lookup"><span data-stu-id="d5a76-302">Garbage collection</span></span>

<span data-ttu-id="d5a76-303">Голографические приложения тратят вычислительное время процессора на сбор мусора, когда он активируется для анализа объектов, вышедших из поля зрения в процессе выполнения и требующих удаления из памяти, чтобы использовать ее повторно.</span><span class="sxs-lookup"><span data-stu-id="d5a76-303">Holographic apps will lose processing compute time to the garbage collector (GC) when the GC is activated to analyze objects that are no longer in scope during execution and their memory needs to be released, so it can be made available for reuse.</span></span> <span data-ttu-id="d5a76-304">Постоянные операции выделения и освобождения памяти обычно требуют более частого вызова сборщика мусора, что ухудшает производительность и взаимодействие с пользователем.</span><span class="sxs-lookup"><span data-stu-id="d5a76-304">Constant allocations and de-allocations will generally require the garbage collector to run more frequently, thus hurting performance and user experience.</span></span>

<span data-ttu-id="d5a76-305">Unity предоставляет отличный ресурс, на котором подробно описана работа сборщика мусора и собраны рекомендации по повышению эффективности работы с памятью в коде.</span><span class="sxs-lookup"><span data-stu-id="d5a76-305">Unity has provided an excellent page that explains in detail how the garbage collector works and tips to write more efficient code in regards to memory management.</span></span>
- [<span data-ttu-id="d5a76-306">Оптимизация сбора мусора в играх на Unity</span><span class="sxs-lookup"><span data-stu-id="d5a76-306">Optimizing garbage collection in Unity games</span></span>](https://unity3d.com/learn/tutorials/topics/performance-optimization/optimizing-garbage-collection-unity-games?playlist=44069)

<span data-ttu-id="d5a76-307">При разработке в Unity одной из самых распространенных ошибок, которые приводят к избыточному сбору мусора, является отсутствие кэша для ссылок на компоненты и классы.</span><span class="sxs-lookup"><span data-stu-id="d5a76-307">One of the most common practices that leads to excessive garbage collection isn't caching references to components and classes in Unity development.</span></span> <span data-ttu-id="d5a76-308">Все ссылки следует собирать в методе Start() или Awake() и использовать повторно в функциях Update() и LateUpdate().</span><span class="sxs-lookup"><span data-stu-id="d5a76-308">Any references should be captured during Start() or Awake() and reused in later functions such as Update() or LateUpdate().</span></span>

<span data-ttu-id="d5a76-309">Еще немного советов.</span><span class="sxs-lookup"><span data-stu-id="d5a76-309">Other quick tips:</span></span>
- <span data-ttu-id="d5a76-310">Используйте класс C# [StringBuilder](https://docs.microsoft.com/dotnet/api/system.text.stringbuilder) для динамического создания сложных строк в процессе выполнения.</span><span class="sxs-lookup"><span data-stu-id="d5a76-310">Use the [StringBuilder](https://docs.microsoft.com/dotnet/api/system.text.stringbuilder) C# class to dynamically build complex strings at runtime</span></span>
- <span data-ttu-id="d5a76-311">Удалите все вызовы Debug.Log(), когда в них отпадет необходимость, иначе они будут по-прежнему выполняться в рабочих версиях приложения.</span><span class="sxs-lookup"><span data-stu-id="d5a76-311">Remove calls to Debug.Log() when no longer needed, as they still execute in all build versions of an app</span></span>
- <span data-ttu-id="d5a76-312">Если голографическое приложение часто требует большого объема памяти, попробуйте вызывать [_**System.GC.Collect()**_](https://docs.microsoft.com/dotnet/api/system.gc.collect) на этапах загрузки, например при отображении экрана загрузки или перехода между сценами.</span><span class="sxs-lookup"><span data-stu-id="d5a76-312">If your holographic app generally requires lots of memory, consider calling  [_**System.GC.Collect()**_](https://docs.microsoft.com/dotnet/api/system.gc.collect) during loading phases such as when presenting a loading or transition screen</span></span>

#### <a name="object-pooling"></a><span data-ttu-id="d5a76-313">Использование пулов объектов</span><span class="sxs-lookup"><span data-stu-id="d5a76-313">Object pooling</span></span>

<span data-ttu-id="d5a76-314">Использование пулов объектов — это распространенный метод для снижения затрат на постоянное выделение или освобождение памяти для объектов.</span><span class="sxs-lookup"><span data-stu-id="d5a76-314">Object pooling is a popular technique for reducing the cost of continuous object allocation and deallocations.</span></span> <span data-ttu-id="d5a76-315">Для этого выделяется большой пул идентичных объектов, из которого извлекаются для повторного использования доступные и неактивные экземпляры. Это эффективнее, чем постоянный процесс создания и уничтожения объектов.</span><span class="sxs-lookup"><span data-stu-id="d5a76-315">This is done by allocating a large pool of identical objects and reusing inactive, available instances from this pool instead of constantly spawning and destroying objects over time.</span></span> <span data-ttu-id="d5a76-316">Пулы объектов отлично подходят для многократно используемых компонентов с переменными периодами жизни в приложении.</span><span class="sxs-lookup"><span data-stu-id="d5a76-316">Object pools are great for reuseable components that have variable lifetime during an app.</span></span>

- [<span data-ttu-id="d5a76-317">Руководство по использованию пулов объектов в Unity</span><span class="sxs-lookup"><span data-stu-id="d5a76-317">Object Pooling Tutorial in Unity</span></span>](https://unity3d.com/learn/tutorials/topics/scripting/object-pooling) 

## <a name="startup-performance"></a><span data-ttu-id="d5a76-318">Производительность при запуске</span><span class="sxs-lookup"><span data-stu-id="d5a76-318">Startup performance</span></span>

<span data-ttu-id="d5a76-319">Мы рекомендуем начать работу приложения с небольшой сцены, а затем загружать остальную часть с помощью *[SceneManager.LoadSceneAsync](https://docs.unity3d.com/ScriptReference/SceneManagement.SceneManager.LoadSceneAsync.html)* .</span><span class="sxs-lookup"><span data-stu-id="d5a76-319">Consider starting your app with a smaller scene, then using *[SceneManager.LoadSceneAsync](https://docs.unity3d.com/ScriptReference/SceneManagement.SceneManager.LoadSceneAsync.html)* to load the rest of the scene.</span></span> <span data-ttu-id="d5a76-320">Это позволит приложению максимально быстро перейти к интерактивному состоянию.</span><span class="sxs-lookup"><span data-stu-id="d5a76-320">This allows your app to get to an interactive state as fast as possible.</span></span> <span data-ttu-id="d5a76-321">При активации новой сцены создается пиковая нагрузка на ЦП, что может привести к подвисанию или отрывистому отображению содержимого.</span><span class="sxs-lookup"><span data-stu-id="d5a76-321">There may be a large CPU spike while the new scene is being activated and that any rendered content might stutter or hitch.</span></span> <span data-ttu-id="d5a76-322">Для обхода этой проблемы можно установить для свойства загружаемой сцены AsyncOperation.allowSceneActivation значение False, затем дождаться полной загрузки сцены, очистить экран и вернуть этому параметру значение True для завершения активации сцены.</span><span class="sxs-lookup"><span data-stu-id="d5a76-322">One way to work around this is to set the AsyncOperation.allowSceneActivation property to "false" on the scene being loaded, wait for the scene to load, clear the screen too black, and then set it back to "true" to complete the scene activation.</span></span>

<span data-ttu-id="d5a76-323">Не забывайте, что в процессе загрузки сцены пользователю будет отображаться голографический стартовый экран.</span><span class="sxs-lookup"><span data-stu-id="d5a76-323">Remember that while the startup scene is loading, the holographic splash screen will be displayed to the user.</span></span>

## <a name="see-also"></a><span data-ttu-id="d5a76-324">См. также статью</span><span class="sxs-lookup"><span data-stu-id="d5a76-324">See also</span></span>
- [<span data-ttu-id="d5a76-325">Оптимизация отрисовки графических объектов в играх на Unity</span><span class="sxs-lookup"><span data-stu-id="d5a76-325">Optimizing graphics rendering in Unity games</span></span>](https://unity3d.com/learn/tutorials/temas/performance-optimization/optimizing-graphics-rendering-unity-games?playlist=44069)
- [<span data-ttu-id="d5a76-326">Оптимизация сбора мусора в играх на Unity</span><span class="sxs-lookup"><span data-stu-id="d5a76-326">Optimizing garbage collection in Unity games</span></span>](https://unity3d.com/learn/tutorials/topics/performance-optimization/optimizing-garbage-collection-unity-games?playlist=44069)
- <span data-ttu-id="d5a76-327">[Советы и рекомендации по физике (Unity)](https://unity3d.com/learn/tutorials/topics/physics/physics-best-practices)</span><span class="sxs-lookup"><span data-stu-id="d5a76-327">[Physics Best Practices [Unity]](https://unity3d.com/learn/tutorials/topics/physics/physics-best-practices)</span></span>
- <span data-ttu-id="d5a76-328">[Оптимизация скриптов (Unity)](https://docs.unity3d.com/Manual/MobileOptimizationPracticalScriptingOptimizations.html)</span><span class="sxs-lookup"><span data-stu-id="d5a76-328">[Optimizing Scripts [Unity]](https://docs.unity3d.com/Manual/MobileOptimizationPracticalScriptingOptimizations.html)</span></span>
