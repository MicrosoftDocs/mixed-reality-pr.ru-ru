---
title: 308. Смешанная реальность и Azure — уведомления на разных устройствах
description: Пройдите этот курс, чтобы узнать, как реализовать центры уведомлений Azure, функции Azure и службу хранилища Azure и таблицы в приложении смешанной реальности.
author: drneil
ms.author: jemccull
ms.date: 07/04/2018
ms.topic: article
keywords: Azure, Mixed Reality, Academy, Unity, учебник, API, уведомление, функции, таблицы, центры уведомлений, hololens, иммерсивное, VR, Windows 10, Visual Studio
ms.openlocfilehash: 4b71968eb546cc5d7a5cd767f2ecafae102c763c
ms.sourcegitcommit: dd13a32a5bb90bd53eeeea8214cd5384d7b9ef76
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/17/2020
ms.locfileid: "94679543"
---
# <a name="mr-and-azure-308-cross-device-notifications"></a>308. Смешанная реальность и Azure: уведомления на разных устройствах

<br>

>[!NOTE]
>Руководства Mixed Reality Academy были разработаны для иммерсивных гарнитур HoloLens (1-го поколения) и иммерсивных гарнитур Mixed Reality.  Поэтому мы считаем, что важно оставить эти руководства для разработчиков, которые ищут рекомендации по разработке для этих устройств.  Данные руководства **_не_** будут обновляться с учетом последних наборов инструментов или возможностей взаимодействия для HoloLens 2.  Они будут сохранены для работы на поддерживаемых устройствах. Появится новая серия руководств, которые будут опубликованы в будущем, где будет показано, как разрабатывать данные для HoloLens 2.  Это уведомление будет обновлено ссылкой на эти учебники при их публикации.

<br>

![окончательный продукт — запуск](images/AzureLabs-Lab8-00.png)

В этом курсе вы узнаете, как добавлять возможности концентраторов уведомлений в приложение смешанной реальности с помощью центров уведомлений Azure, таблиц Azure и функций Azure.

**Центры уведомлений Azure** — это служба Майкрософт, которая позволяет разработчикам отправлять целевые и персонализированные push-уведомления на любую платформу, работающую в облаке. Это позволяет разработчикам взаимодействовать с конечными пользователями или даже взаимодействовать между различными приложениями в зависимости от сценария. Дополнительные сведения см. на [странице](https://docs.microsoft.com/azure/notification-hubs/notification-hubs-push-notification-overview)центров **уведомлений Azure** .

**Функции Azure** — это служба Майкрософт, которая позволяет разработчикам запускать небольшие фрагменты кода "функции" в Azure. Это позволяет делегировать работу в облако, а не локальное приложение, которое может иметь множество преимуществ. **Функции Azure** поддерживают несколько языков разработки, включая C \# , F \# , Node.js, Java и PHP. Дополнительные сведения см. на странице **функций Azure** [page](https://docs.microsoft.com/azure/azure-functions/functions-overview).

**Таблицы Azure** — это облачная служба Майкрософт, которая позволяет разработчикам хранить структурированные данные, отличные от SQL, в облаке, что упрощает доступ к ним из любого места. Служба может похвастаться структуру, которая обеспечивает развитие таблиц по мере необходимости, и, таким образом, является очень гибкой. Дополнительные сведения см. на странице **таблиц Azure** [page](https://docs.microsoft.com/azure/cosmos-db/table-storage-overview) .

Прополнив этот курс, вы получите иммерсивное приложение для работы в смешанной реальности и приложение для настольного ПК, которое сможет сделать следующее:

1. Приложение настольного ПК позволит пользователю перемещать объект в двухмерном пространстве (X и Y) с помощью мыши.

2. Перемещение объектов в приложении для ПК будет отправлено в облако с помощью JSON, которое будет иметь форму строки, содержащей идентификатор объекта, тип и сведения о преобразовании (координаты X и Y). 

3. Приложение Mixed Reality, которое имеет идентичную сцену для классического приложения, будет получать уведомления о перемещении объектов из службы концентраторов уведомлений (которая только что была обновлена настольным приложением). 

4. При получении уведомления, которое будет содержать идентификатор объекта, тип и сведения о преобразовании, приложение Mixed Reality применит полученные сведения к собственной сцене.

В приложении вы будете выполнять интеграцию результатов с вашей структурой. Этот курс предназначен для изучения того, как интегрировать службу Azure с проектом Unity. Это ваша задача использовать знания, полученные из этого курса, для улучшения приложения смешанной реальности. Этот курс является автономным учебником, который не участвует в других практических занятиях смешанной реальности.

## <a name="device-support"></a>Поддержка устройств

<table>
<tr>
<th>Курс</th><th style="width:150px"> <a href="../../../hololens-hardware-details.md">HoloLens</a></th><th style="width:150px"> <a href="../../../discover/immersive-headset-hardware-details.md">Иммерсивные гарнитуры</a></th>
</tr><tr>
<td> 308. Смешанная реальность и Azure: уведомления на разных устройствах</td><td style="text-align: center;"> ✔️</td><td style="text-align: center;"> ✔️</td>
</tr>
</table>

> [!NOTE]
> Хотя этот курс в основном ориентирован на гарнитуры Windows Mixed Reality (VR), вы также можете применить сведения, которые вы узнаете в этом курсе, к Microsoft HoloLens. Как вы пройдете вместе с курсом, вы увидите примечания о любых изменениях, которые могут потребоваться для поддержки HoloLens. При использовании HoloLens вы можете заметить некоторые эхо во время записи голоса.

## <a name="prerequisites"></a>Предварительные требования

> [!NOTE]
> Этот учебник предназначен для разработчиков, имеющих базовый опыт работы с Unity и C#. Также имейте в виду, что предварительные требования и письменные инструкции в этом документе отражают, что проверялось и проверено во время написания статьи (Май 2018). Вы можете использовать новейшее программное обеспечение, как указано в статье [Установка средств](../../install-the-tools.md) , но не следует предполагать, что информация в этом курсе будет полностью соответствовать тому, что вы найдете в более новом программном обеспечении, чем показано ниже.

Для этого курса рекомендуется следующее оборудование и программное обеспечение:

- ПК для разработки, [совместимый с Windows Mixed Reality](https://support.microsoft.com/help/4039260/windows-10-mixed-reality-pc-hardware-guidelines) для разработки головных телефонов (VR)
- [Windows 10 для дизайнеров с обновлением (или более поздней версии) с включенным режимом разработчика](../../install-the-tools.md#installation-checklist)
- [Последний пакет SDK для Windows 10](../../install-the-tools.md#installation-checklist)
- [Unity 2017,4](../../install-the-tools.md#installation-checklist)
- [Visual Studio 2017](../../install-the-tools.md#installation-checklist)
- Высокодоступная [гарнитура Windows Mixed Reality (VR)](../../../discover/immersive-headset-hardware-details.md) или [Microsoft HoloLens](../../../hololens-hardware-details.md) с включенным режимом разработчика
- Доступ к Интернету для установки Azure и доступа к концентраторам уведомлений

## <a name="before-you-start"></a>Перед началом работы

- Чтобы избежать проблем при создании этого проекта, настоятельно рекомендуется создать проект, упомянутый в этом руководстве, в корневой или ближайшем к корневой папке (длинные пути к папкам могут вызвать проблемы во время сборки).
- Вы должны быть владельцем портала разработчика Майкрософт и портала регистрации приложений, в противном случае у вас не будет разрешения на доступ к приложению в [главе 2](#chapter-2---retrieve-your-new-apps-credentials).

## <a name="chapter-1---create-an-application-on-the-microsoft-developer-portal"></a>Глава 1. Создание приложения на портале разработчика Майкрософт

Чтобы использовать службу **концентраторов уведомлений Azure** , необходимо создать приложение на портале разработчика Майкрософт, так как приложение должно быть зарегистрировано, чтобы оно может отправлять и получать уведомления.

1.  Войдите на [портал разработчика Майкрософт](https://developer.microsoft.com/dashboard).

    > Вам потребуется войти в учетную запись Майкрософт.

2.  На панели мониторинга щелкните **создать новое приложение**.

    ![Создание приложения](images/AzureLabs-Lab8-01.png)

3.  Появится всплывающее окно, где необходимо зарезервировать имя нового приложения. В текстовое поле вставьте соответствующее имя. Если выбранное имя доступно, справа от текстового поля появится галочка. После добавления доступного имени нажмите кнопку **резервное название продукта** в левом нижнем углу всплывающего окна.

    ![обратить имя](images/AzureLabs-Lab8-02.png)

4.  Теперь, когда приложение создано, вы можете перейти к следующей главе.

## <a name="chapter-2---retrieve-your-new-apps-credentials"></a>Глава 2. получение учетных данных для новых приложений

Войдите на портал регистрации приложений, где будет указано новое приложение, и получите учетные данные, которые будут использоваться для настройки **службы концентраторов уведомлений** на **портале Azure**.

1.  Перейдите на [портал регистрации приложений](https://apps.dev.microsoft.com).

    ![Портал регистрации приложений](images/AzureLabs-Lab8-03.png)

    > [!WARNING] 
    > Для входа в систему необходимо использовать учетную запись Майкрософт.  
    > Это **должна** быть учетная запись Майкрософт, которая использовалась в предыдущей [главе](#chapter-1---create-an-application-on-the-microsoft-developer-portal)с порталом для разработчиков Магазина Windows.

2.  Приложение будет найдено в разделе **Мои приложения** . Найдя его, щелкните его, и вы перейдете на новую страницу с именем приложения и **регистрацией**.

    ![Ваше недавно зарегистрированное приложение](images/AzureLabs-Lab8-04.png)

3.  Прокрутите страницу регистрации вниз и найдите раздел **секреты приложения** и **идентификатор безопасности пакета** для приложения. Скопируйте оба этих параметра для использования с настройкой **службы "центры уведомлений Azure** " в следующей главе.

    ![Секреты приложения](images/AzureLabs-Lab8-05.png)

## <a name="chapter-3---setup-azure-portal-create-notification-hubs-service"></a>Глава 3. Настройка портала Azure: создание службы концентраторов уведомлений

После извлечения учетных данных приложения необходимо открыть портал Azure, где вы создадите службу центров уведомлений Azure.

1.  Войдите на [портал Azure](https://portal.azure.com).

    > [!NOTE] 
    > Если у вас еще нет учетной записи Azure, необходимо создать ее. Если вы используете этот учебник в учебной или лабораторной ситуации, обратитесь к своему преподавателю или к одной из прокторс, чтобы получить помощь в настройке новой учетной записи.

2.  Войдя в систему, щелкните New ( **создать** ) в левом верхнем углу, найдите **Центр уведомлений** и нажмите кнопку **_Ввод_* _.

    ![Поиск центра уведомлений](images/AzureLabs-Lab8-06.png)

    > [!NOTE] 
    > Слово _*_New в новых_*_ порталах может быть заменено на _ * создание ресурса * *.

3.  На новой странице будет представлено описание службы *концентраторов уведомлений* . В нижнем левом углу этого запроса нажмите кнопку **создать** , чтобы создать связь с этой службой.

    ![Создание экземпляра концентраторов уведомлений](images/AzureLabs-Lab8-07.png)

4.  После нажатия кнопки **_создать_* _:

    1.  Вставьте нужное имя для этого экземпляра службы.

    2.  Укажите _ *пространство имен**, которое вы сможете связать с этим приложением.

    3.  Выберите **расположение.**

    4.  Выберите **группу ресурсов** или создайте новую. Группа ресурсов предоставляет способ мониторинга, контроля доступа, подготовки счетов и управления ими для коллекции ресурсов Azure. Рекомендуется, чтобы все службы Azure, связанные с одним проектом (например, в этих лабораториях), были в общей группе ресурсов.

        > Если вы хотите ознакомиться с дополнительными сведениями о группах ресурсов Azure, перейдите [по этой ссылке, чтобы управлять группой ресурсов](https://docs.microsoft.com/azure/azure-resource-manager/resource-group-portal). 

    5.  Выберите подходящую **подписку**.

    6.  Также необходимо подтвердить, что вы поняли условия, примененные к этой службе.

    7. Нажмите кнопку **Создать**.

        ![Заполнение сведений о службе](images/AzureLabs-Lab8-08.png)

5.  После нажатия кнопки **создать** необходимо подождать, пока не будет создана служба, а это может занять некоторое время.

6.  После создания экземпляра службы на портале отобразится уведомление.

    ![уведомление](images/AzureLabs-Lab8-09.png)

7.  Нажмите кнопку " **Переход к ресурсу** " в уведомлении, чтобы изучить новый экземпляр службы. Вы будете перенаправлены на новый экземпляр службы **концентратора уведомлений** .

    ![Переход к ресурсу](images/AzureLabs-Lab8-10.png)
    
8.  На странице Обзор в середине страницы щелкните **Windows (WNS).** Панель справа изменится на отображение двух текстовых полей, требующих идентификатора безопасности и **ключа безопасности** **пакета** , из приложения, настроенного ранее.

    ![вновь созданная служба концентраторов](images/AzureLabs-Lab8-11.png)

9. После копирования сведений в правильные поля нажмите кнопку **сохранить**, и вы получите уведомление об успешном обновлении центра уведомлений.

    ![Копировать сведения о безопасности](images/AzureLabs-Lab8-12.png)

## <a name="chapter-4---setup-azure-portal-create-table-service"></a>Глава 4. Настройка портала Azure: создание службы таблиц

После создания экземпляра службы концентраторов уведомлений вернитесь на портал Azure, где вы создадите службу таблиц Azure, создав ресурс хранилища.

1.  Если вы еще не вошли в систему, войдите на [портал Azure](https://portal.azure.com).

2.  После входа в систему щелкните **создать** в левом верхнем углу и найдите **учетную запись хранения** и нажмите клавишу **Ввод**.

    > [!NOTE] 
    > Слово **_New_*_ может быть заменено* на "_ создать ресурс**" на новых порталах.

3.  В списке выберите **учетная запись хранения — BLOB-объект, файл, таблица и очередь** .

    ![Поиск учетной записи хранения](images/AzureLabs-Lab8-13.png)

4.  На новой странице будет представлено описание службы **учетной записи хранения** . В нижнем левом углу этого запроса нажмите кнопку **создать** , чтобы создать экземпляр этой службы.

    ![Создание экземпляра хранилища](images/AzureLabs-Lab8-14.png)

5.  После нажатия кнопки **создать** появится панель:

    1. Вставьте нужное **имя** для этого экземпляра службы (необходимо указать все символы в нижнем регистре).

    2. В качестве **модели развертывания** щелкните **Resource Manager**.

    3.  Для **типа учетной записи** в раскрывающемся меню выберите **хранилище (общее назначение v1)**.

    4. Выберите подходящее **Расположение**.
    
    5.  В раскрывающемся меню **репликация** выберите **доступ для чтения — геоизбыточное хранилище (RA-GRS)**.

    6.  Для **повышения производительности** щелкните **стандартный**.

    7.  В разделе **Обязательное безопасное перемещение** выберите **отключено**.

    8.  В раскрывающемся меню **Подписка** выберите подходящую подписку.

    9.  Выберите **группу ресурсов** или создайте новую. Группа ресурсов предоставляет способ мониторинга, контроля доступа, подготовки счетов и управления ими для коллекции ресурсов Azure. Рекомендуется, чтобы все службы Azure, связанные с одним проектом (например, в этих лабораториях), были в общей группе ресурсов.

        > Если вы хотите ознакомиться с дополнительными сведениями о группах ресурсов Azure, перейдите [по этой ссылке, чтобы управлять группой ресурсов](https://docs.microsoft.com/azure/azure-resource-manager/resource-group-portal).

    10. Оставьте **виртуальные сети** **отключенными** , если это возможно.

    11. Нажмите кнопку **Создать**.

        ![Заполнение сведений о хранилище](images/AzureLabs-Lab8-15.png)

6.  После нажатия кнопки **создать** необходимо подождать, пока не будет создана служба, а это может занять некоторое время.

7.  После создания экземпляра службы на портале отобразится уведомление. Щелкните уведомления, чтобы изучить новый экземпляр службы.

    ![уведомление о новом хранилище](images/AzureLabs-Lab8-16.png)

8.  Нажмите кнопку " **Переход к ресурсу** " в уведомлении, чтобы изучить новый экземпляр службы. Будет выполнен переход на новую страницу обзора экземпляра службы хранилища.

    ![Переход к ресурсу](images/AzureLabs-Lab8-17.PNG)

9. На странице Обзор в правой части щелкните **таблицы**.
    
    ![](images/AzureLabs-Lab8-18.PNG)

10. Панель справа изменится на отображение сведений о **службе таблиц** , где необходимо добавить новую таблицу. Для этого нажмите кнопку **+** **Таблица** в левом верхнем углу.

    ![Открытие таблиц](images/AzureLabs-Lab8-19.png)

11. Будет отображена новая страница, где необходимо ввести **имя таблицы**. Это имя, которое будет использоваться для ссылки на данные в приложении в последующих главах. Вставьте соответствующее имя и нажмите кнопку **ОК**.

    ![создать новую таблицу](images/AzureLabs-Lab8-20.png)    

12. После создания новой таблицы ее можно будет увидеть на странице **службы таблиц** (в нижней части).

    ![создана новая таблица](images/AzureLabs-Lab8-21.png)
    

## <a name="chapter-5---completing-the-azure-table-in-visual-studio"></a>Глава 5. Заполнение таблицы Azure в Visual Studio

Теперь, когда учетная запись хранения **службы таблиц** была настроена, можно добавить в нее данные, которые будут использоваться для хранения и извлечения информации. Редактирование таблиц можно выполнить с помощью **Visual Studio**.

1.  Откройте **Visual Studio**.

2.  В меню щелкните **Просмотреть**  >  **Cloud Explorer**.

    ![открыть Cloud Explorer](images/AzureLabs-Lab8-22.png)

3.  **Cloud Explorer** откроется как закрепленный элемент (подождите, так как загрузка может занять некоторое время).

    > [!NOTE] 
    > Если подписка, использованная для создания *учетных записей хранения* , не отображается, убедитесь, что у вас есть: 
    > - Войдите в ту же учетную запись, которая использовалась для портала Azure.
    > - Выберите подписку на странице управления учетными записями (может потребоваться применить фильтр из параметров учетной записи):  
    >
    >   ![Найти подписку](images/AzureLabs-Lab8-22-5.png)

4.  Будут показаны облачные службы Azure. Найдите **учетные записи хранения** и щелкните стрелку слева от нее, чтобы развернуть учетные записи.

    ![Открытие учетных записей хранения](images/AzureLabs-Lab8-23.png)

5.  После развертывания вновь созданная **учетная запись хранения** должна быть доступна. Щелкните стрелку слева от хранилища, а затем после разворачивания найдите **таблицы** и щелкните стрелку рядом с ней, чтобы открыть **таблицу** , созданную в последней главе. Дважды щелкните **таблицу**.

    ![открыть таблицу объектов сцены](images/AzureLabs-Lab8-24.png)

6.  Таблица откроется в центре окна Visual Studio. Щелкните значок таблицы с рядом с **+** ним (плюс).

    ![Добавить новую таблицу](images/AzureLabs-Lab8-25.png)

7.  Появится окно с запросом на *Добавление сущности*. В итоге вы создадите три сущности, каждая из которых имеет несколько свойств. Вы увидите, что *PartitionKey* и *RowKey* уже предоставлены, так как они используются таблицей для поиска данных. 

    ![ключ секции и строки](images/AzureLabs-Lab8-26.png)

8. Обновите *значение* **PartitionKey** и **RowKey** следующим образом (не забудьте сделать это для каждого добавляемого свойства строки, хотя каждый раз следует увеличивать RowKey):

    ![добавить правильные значения](images/AzureLabs-Lab8-26-5.png)

9.  Нажмите кнопку **Добавить свойство** , чтобы добавить дополнительные строки данных. Создайте первую пустую таблицу, совпадающую с таблицей ниже.

10. По завершении нажмите кнопку **ОК** .

    ![по завершении нажмите кнопку ОК.](images/AzureLabs-Lab8-27.png)

    > [!WARNING] 
    > Убедитесь, что вы изменили **тип** **X**, **Y** и **Z**, записи на **Double**. 

11. Обратите внимание, что таблица теперь содержит строку данных. **+** Еще раз щелкните значок (плюс), чтобы добавить другую сущность.

    ![Первая строка](images/AzureLabs-Lab8-27-5.png)

12. Создайте дополнительное свойство, а затем задайте значения для новой сущности в соответствии с показанными ниже.

    ![Добавить куб](images/AzureLabs-Lab8-28.png)

13. Повторите Последнее действие, чтобы добавить другую сущность. Задайте значения для этой сущности, указанные ниже.

    ![добавить цилиндр](images/AzureLabs-Lab8-29.png)

14. Теперь таблица должна выглядеть так, как показано ниже.

    ![Таблица завершена](images/AzureLabs-Lab8-30.png)

15. Вы выполнили эту главу. Обязательно сохраните.

## <a name="chapter-6---create-an-azure-function-app"></a>Глава 6. Создание приложение-функция Azure

Создайте приложение-функция Azure, который будет вызываться настольным приложением для обновления службы **таблиц** и отправки уведомления через **Центр уведомлений**.

Сначала необходимо создать файл, который позволит вашей функции Azure загружать нужные библиотеки.

1.  Откройте **Блокнот** (нажмите клавишу Windows и введите Блокнот).

    ![открыть Блокнот](images/AzureLabs-Lab8-31.png)

2.  При открытии блокнота вставьте в него структуру JSON. После этого сохраните его на рабочем столе, как **project.js**. Важно, чтобы имя было правильным: Убедитесь, что оно **не имеет расширения txt** . Этот файл определяет библиотеки, которые будет использовать функция. Если вы использовали NuGet, он покажется вам знакомым.

    ```json
    {
    "frameworks": {
        "net46":{
        "dependencies": {
            "WindowsAzure.Storage": "7.0.0",
            "Microsoft.Azure.NotificationHubs" : "1.0.9",
            "Microsoft.Azure.WebJobs.Extensions.NotificationHubs" :"1.1.0"
        }
        }
    }
    }
    ```

3.  Войдите на [портал Azure](https://portal.azure.com).

4.  Войдя в систему, щелкните New ( **создать** ) в левом верхнем углу и выполните поиск по **приложение-функция** нажмите клавишу **Ввод**.

    ![Поиск приложения функции](images/AzureLabs-Lab8-32.png)

    > [!NOTE] 
    > Слово **New** может быть заменено на **создать ресурс** в новых порталах.

5.  На новой странице будет представлено описание службы **приложение-функция** . В нижнем левом углу этого запроса нажмите кнопку **создать** , чтобы создать связь с этой службой.

    ![экземпляр приложения функции](images/AzureLabs-Lab8-33.png)

6.  После нажатия кнопки **создать** заполните следующие поля:

    1. В качестве **имени приложения** вставьте нужное имя для этого экземпляра службы.

    2. Выберите **подписку**.

    3. Выберите ценовую категорию, подходящую для вас. Если вы впервые создаете **службу приложение-функция**, вам будет доступен бесплатный уровень.

    4. Выберите **группу ресурсов** или создайте новую. Группа ресурсов предоставляет способ мониторинга, контроля доступа, подготовки счетов и управления ими для коллекции ресурсов Azure. Рекомендуется, чтобы все службы Azure, связанные с одним проектом (например, в этих лабораториях), были в общей группе ресурсов.

        > Если вы хотите ознакомиться с дополнительными сведениями о группах ресурсов Azure, перейдите [по этой ссылке, чтобы управлять группой ресурсов](https://docs.microsoft.com/azure/azure-resource-manager/resource-group-portal).

    5. Для **ОС** щелкните Windows, так как это Целевая платформа.

    6. Выберите **план размещения** (в этом учебнике используется **план потребления**).

    7. Выберите **Расположение** **(выберите то же расположение, что и хранилище, созданное на предыдущем шаге)** .

    8. В разделе **хранилище** **необходимо выбрать службу хранилища, созданную на предыдущем шаге**.

    9. Вам не потребуется *Application Insights* в этом приложении, поэтому вы можете **оставить его без** изменений.

    10. Нажмите кнопку **Создать**.

        ![создать новый экземпляр](images/AzureLabs-Lab8-34.png)

7.  После нажатия кнопки **создать** необходимо подождать, пока не будет создана служба, а это может занять некоторое время.

8.  После создания экземпляра службы на портале отобразится уведомление.

    ![новое уведомление](images/AzureLabs-Lab8-35.png)

9.  Щелкните уведомления, чтобы изучить новый экземпляр службы.

10. Нажмите кнопку " **Переход к ресурсу** " в уведомлении, чтобы изучить новый экземпляр службы. 

    ![Переход к ресурсу](images/AzureLabs-Lab8-36.png)

11. Щелкните **+** значок (плюс) рядом с пунктом *функции*, чтобы *создать новый*.

    ![Добавить новую функцию](images/AzureLabs-Lab8-37.png)

12. На центральной панели появится окно создания **функции** . Проигнорируйте информацию в верхней половине панели и щелкните **Пользовательская функция**, расположенная рядом с нижней областью (в синей области, как показано ниже).

    ![Пользовательская функция](images/AzureLabs-Lab8-38.png)

13. На новой странице в окне будут показаны различные типы функций. Прокрутите вниз, чтобы просмотреть сиреневые типы, и щелкните **http-элемент размещения** .

    ![Ссылка HTTP на размещение](images/AzureLabs-Lab8-39.png)

    > [!IMPORTANT]
    > Возможно, потребуется прокрутить страницу вниз (и этот образ может выглядеть неточно так же, если обновления на портале Azure выполнены), но вы ищете элемент, именуемый *http-ПОстановкой*.

14. Откроется окно **http-размещения** , в котором необходимо настроить функцию (см. рисунок ниже для изображения).

    1.  Для **языка** в раскрывающемся меню выберите C \# .

    2.  В качестве **имени** введите соответствующее имя.

    3.  В раскрывающемся меню **уровень проверки подлинности** выберите **функция**.

    4.  В разделе **имя таблицы** необходимо указать точное имя, которое использовалось для создания службы **таблиц** ранее (включая тот же регистр букв).

    5.  В разделе **Подключение к учетной записи хранения** используйте раскрывающееся меню и выберите в нем свою учетную запись хранения. Если это не так, щелкните **новую** гиперссылку рядом с заголовком раздела, чтобы отобразить другую панель, в которой должна быть указана учетная запись хранения.

        ![новое хранилище](images/AzureLabs-Lab8-40.png)

15. Нажмите кнопку **создать** , и вы получите уведомление о том, что параметры успешно обновлены.

    ![Создание функции](images/AzureLabs-Lab8-41.png)

16. После нажатия кнопки **создать** вы будете перенаправлены в редактор функций.

    ![Обновление кода функции](images/AzureLabs-Lab8-42.png)

17. Вставьте следующий код в редактор функций (заменив Код в функции):

    ```csharp
    #r "Microsoft.WindowsAzure.Storage"

    using System;
    using Microsoft.WindowsAzure.Storage;
    using Microsoft.WindowsAzure.Storage.Table;
    using Microsoft.Azure.NotificationHubs;
    using Newtonsoft.Json;

    public static async Task Run(UnityGameObject gameObj, CloudTable table, IAsyncCollector<Notification> notification, TraceWriter log)
    {
        //RowKey of the table object to be changed
        string rowKey = gameObj.RowKey;

        //Retrieve the table object by its RowKey
        TableOperation operation = TableOperation.Retrieve<UnityGameObject>("UnityPartitionKey", rowKey); 

        TableResult result = table.Execute(operation);

        //Create a UnityGameObject so to set its parameters
        UnityGameObject existingGameObj = (UnityGameObject)result.Result; 

        existingGameObj.RowKey = rowKey;
        existingGameObj.X = gameObj.X;
        existingGameObj.Y = gameObj.Y;
        existingGameObj.Z = gameObj.Z;

        //Replace the table appropriate table Entity with the value of the UnityGameObject
        operation = TableOperation.Replace(existingGameObj); 

        table.Execute(operation);

        log.Verbose($"Updated object position");

        //Serialize the UnityGameObject
        string wnsNotificationPayload = JsonConvert.SerializeObject(existingGameObj);
        
        log.Info($"{wnsNotificationPayload}");

        var headers = new Dictionary<string, string>();

        headers["X-WNS-Type"] = @"wns/raw";

        //Send the raw notification to subscribed devices
        await notification.AddAsync(new WindowsNotification(wnsNotificationPayload, headers)); 

        log.Verbose($"Sent notification");
    }

    // This UnityGameObject represent a Table Entity
    public class UnityGameObject : TableEntity
    {
        public string Type { get; set; }
        public double X { get; set; }
        public double Y { get; set; }
        public double Z { get; set; }
        public string RowKey { get; set; }
    }
    ```

    > [!NOTE]
    > Используя встроенные библиотеки, функция получает имя и расположение объекта, который был перемещен в сцене Unity (как объект C#, именуемый **унитигамеобжект**). Затем этот объект используется для обновления параметров объекта в созданной таблице. После этого функция вызывает созданную службу концентратора уведомлений, которая уведомляет все подписанные приложения.

18. После ввода кода нажмите кнопку **сохранить**.

19. Затем щелкните **\<** значок (стрелка) в правой части страницы.

    ![открыть панель отправки](images/AzureLabs-Lab8-43.png)

20. Панель будет продвигаться справа. На этой панели нажмите кнопку **Отправить** и отобразится обозреватель файлов.

21. Перейдите к и щелкните **project.js** файла, созданного ранее в **блокноте** , а затем нажмите кнопку **Открыть** . Этот файл определяет библиотеки, которые будет использовать функция.

    ![Отправить JSON](images/AzureLabs-Lab8-44.png)

22. После отправки файл появится на панели справа. Щелкнув его, вы откроете его в редакторе **функций** . Он должен выглядеть **точно** так же, как и следующий образ (под шагом 23).

23. Затем на панели слева под элементом **функции** щелкните ссылку **Интеграция** .

    ![Функция интеграции](images/AzureLabs-Lab8-45.png)

24. На следующей странице в правом верхнем углу щелкните **Расширенный редактор** (как показано ниже).

    ![откройте расширенный редактор](images/AzureLabs-Lab8-46.png)

25. На центральной панели будет открыт **function.js** файла, который необходимо заменить на следующий фрагмент кода. Это определяет создаваемую функцию и параметры, передаваемые в функцию.

    ```json
    {
    "bindings": [
        {
        "authLevel": "function",
        "type": "httpTrigger",
        "methods": [
            "get",
            "post"
        ],
        "name": "gameObj",
        "direction": "in"
        },
        {
        "type": "table",
        "name": "table",
        "tableName": "SceneObjectsTable",
        "connection": "mrnothubstorage_STORAGE",
        "direction": "in"
        },
        {
        "type": "notificationHub",
        "direction": "out",
        "name": "notification",
        "hubName": "MR_NotHub_ServiceInstance",
        "connection": "MRNotHubNS_DefaultFullSharedAccessSignature_NH",
        "platform": "wns"
        }
    ]
    }
    ```

26. Теперь редактор должен выглядеть следующим образом:

    ![вернуться к стандартному редактору](images/AzureLabs-Lab8-47.png)

27. Вы можете заметить, что только что вставленные входные параметры могут не соответствовать таблице и сведениям о хранилище, поэтому их необходимо обновить. **Не выведем это**, как описано далее. Просто щелкните ссылку **стандартный редактор** в правом верхнем углу страницы, чтобы вернуться назад.

28. Вернувшись в **стандартный редактор**, в разделе **входные данные** выберите **хранилище таблиц Azure (таблица)**. 
    
    ![Входные данные таблицы](images/AzureLabs-Lab8-47-5.png)

29. Убедитесь в следующем совпадении со **своими** сведениями, так как они могут отличаться (ниже приведены действия).

    1.  **Имя таблицы**: имя таблицы, созданной в службе "хранилище Azure" службы "таблицы".

    2.  **Подключение к учетной записи хранения.** щелкните **создать**, которое отображается рядом с раскрывающимся меню, и в правой части окна появится панель.

        ![новое хранилище](images/AzureLabs-Lab8-48.png)

        1.  Выберите **учетную запись хранения**, созданную ранее для размещения **приложений функций.**

        2. Вы увидите, что значение подключения **учетной записи хранения** было создано.

        3. По завершении нажмите кнопку **сохранить** .

    3.  Страница **входных данных** теперь должна соответствовать приведенной ниже странице **, в которой отображаются сведения** .

        ![входные данные завершены](images/AzureLabs-Lab8-49.png)

30. Затем в разделе **выходные данные** щелкните **Центр уведомлений Azure (уведомление)** . Убедитесь, что следующие данные соответствуют **вашим** сведениям, так как они могут отличаться (ниже приведены действия).

    1.  **Имя концентратора уведомлений**. это имя созданного ранее экземпляра службы **концентратора уведомлений** .

    2.  **Подключение к пространству имен концентраторов уведомлений**: щелкните **создать**, которое отображается рядом с раскрывающимся меню.

        ![проверить выходные данные](images/AzureLabs-Lab8-50.png)

    3. Появится всплывающее окно **подключения** (см. рисунок ниже), где необходимо выбрать **пространство имен** **концентратора уведомлений**, настроенного ранее.

    4. Выберите имя **центра уведомлений** в среднем раскрывающемся меню.

    5.  Задайте для раскрывающегося меню **политики** значение **DefaultFullSharedAccessSignature**.

    6. Нажмите кнопку **выбрать** , чтобы вернуться назад.

        ![Выходное обновление](images/AzureLabs-Lab8-51.png)

31.  Теперь страница **выходные данные** должна соответствовать приведенной ниже таблице, но **вместо нее.** Обязательно нажмите кнопку **сохранить**.

> [!WARNING]
> *Не изменяйте имя концентратора уведомлений напрямую* (все это должно быть выполнено с помощью **Расширенный редактор**, если выполнены предыдущие шаги правильно.

![выходные данные завершены](images/AzureLabs-Lab8-50.png)

32. На этом этапе необходимо протестировать функцию, чтобы убедиться, что она работает. Выполните указанные ниже действия. 

    1. Еще раз перейдите на страницу функции:

        ![выходные данные завершены](images/AzureLabs-Lab8-50-1.png)

    2. Вернитесь на страницу функция, щелкните вкладку **Test (тест** ) в правой части страницы, чтобы открыть колонку Test ( *тест* ):

        ![выходные данные завершены](images/AzureLabs-Lab8-50-2.png)

    3. В текстовое поле **текст запроса** в колонке вставьте следующий код:

        ```
        {  
            "Type":null,
            "X":3,
            "Y":0,
            "Z":1,
            "PartitionKey":null,
            "RowKey":"Obj2",
            "Timestamp":"0001-01-01T00:00:00+00:00",
            "ETag":null
        }
        ```

    4. Выполнив тестовый код, нажмите кнопку **выполнить** в правом нижнем углу, и тест будет выполнен. Выходные журналы теста будут отображаться в области консоли под кодом функции.

        ![выходные данные завершены](images/AzureLabs-Lab8-50-3.png)

    > [!WARNING]
    > Если приведенный выше тест завершается неудачно, необходимо проверить, что вы выполнили описанные выше действия точно, особенно параметры на **панели интеграции**. 

## <a name="chapter-7---set-up-desktop-unity-project"></a>Глава 7. Настройка проекта Unity для настольных систем

> [!IMPORTANT]
> Настольное приложение, которое сейчас создается, **не будет** работать в редакторе Unity. Он должен выполняться вне редактора, после создания приложения с помощью Visual Studio (или развернутого приложения). 

Ниже приведена типичная Настройка для разработки с помощью Unity и смешанной реальности, которая является хорошим шаблоном для других проектов.

Настройка и тестирование иммерсивного наушников смешанной реальности.

> [!NOTE] 
> Для этого курса **не** потребуется использовать контроллеры движения. Если вам нужна поддержка настройки иммерсивного гарнитуры, перейдите по этой ссылке, [чтобы настроить Windows Mixed Reality](https://support.microsoft.com/help/4043101/windows-10-set-up-windows-mixed-reality).

1.  Откройте **Unity** и нажмите кнопку **создать**.

    ![новый проект Unity](images/AzureLabs-Lab8-52.png)

2.  Необходимо указать имя проекта Unity, вставить **унитидесктопнотифхуб**. Убедитесь, что для типа проекта задано значение **3D**. Задайте для **расположения нужное расположение** (Помните, что ближе к корневым каталогам лучше). Затем нажмите кнопку **создать проект**.

    ![создание проекта](images/AzureLabs-Lab8-53.png)

3.  При открытом Unity стоит проверить, что для **редактора скриптов** по умолчанию задано значение **Visual Studio**. Перейдите к разделу **изменение**  >  **настроек** , а затем в новом окне перейдите к разделу **Внешние инструменты**. Измените **Редактор внешних скриптов** на **Visual Studio 2017**. Закройте окно **настройки** .

    ![Настройка внешних средств VS](images/AzureLabs-Lab8-54.png)

4.  Затем перейдите в раздел **File**  >  **параметры сборки** файлов и выберите **универсальная платформа Windows**, а затем нажмите кнопку **переключения платформы** , чтобы применить выбранные элементы.

    ![Переключение платформ](images/AzureLabs-Lab8-55.png)

5.  Несмотря на то **File**, что все еще находятся в  >  **параметрах сборки** файлов, убедитесь, что:

    1.  **Целевое устройство** настроено для **любого устройства**

        > Это приложение будет использоваться для вашего рабочего стола, поэтому должно быть **любым устройством** .

    2.  Для **типа сборки** задано значение **D3D**

    3.  **Пакет SDK** установлен в значение " **Последняя установка** "

    4.  Для **версии Visual Studio** установлено значение " **Последняя установка** "

    5.  **Сборка и запуск** настроены на **локальный компьютер**

    6.  Здесь стоит сохранить сцену и добавить ее в сборку.

        1. Для этого выберите **Добавить открытые сцены**. Появится окно сохранения.

            ![Добавление открытых сцен](images/AzureLabs-Lab8-56.png)

        2. Создайте новую папку для этого, а также любой будущей сцены, а затем нажмите кнопку **создать папку** , чтобы создать новую папку, назовите ее « **сцены**».

            ![Новая папка сцен](images/AzureLabs-Lab8-57.png)

        3. Откройте только что созданную папку **сцены** , а затем в поле **имя файла:** введите **NH \_ Desktop \_ сцены** и нажмите кнопку **сохранить**.

            ![новые NH_Desktop_Scene](images/AzureLabs-Lab8-58.png)

    7.  Оставшиеся параметры, в **параметрах сборки**, должны быть оставлены по умолчанию.

6.  В том же окне нажмите кнопку **Параметры проигрывателя** , чтобы открыть связанную панель в пространстве, где находится **инспектор** .

7.  На этой панели необходимо проверить несколько параметров:

    1.  На вкладке **другие параметры** выполните следующие действия.

        1.  Должна быть экспериментальная **версия среды выполнения сценариев** **(эквивалент .NET 4,6)**

        2. **Серверная часть сценариев** должна быть **.NET**

        3. **Уровень совместимости API** должен быть **.NET 4,6**

            ![4,6 NET version](images/AzureLabs-Lab8-59.png)

    2.  На вкладке **Параметры публикации** в разделе **возможности** установите флажок:

        - **InternetClient**;

            ![Клиент Tick Internet](images/AzureLabs-Lab8-60.png)

8.  Назад в **параметрах сборки** *\# проекты Unity C* больше не заключаются; установите флажок рядом с этим.

9.  Закройте окно **Build Settings** (Параметры сборки).

10. Сохраните сцену и файл проекта **File**  >  **сохранить сцену/файл**  >  **сохранить проект**.

    > [!IMPORTANT]
    > Если вы хотите пропустить компонент *настройки Unity* для этого проекта (классическое приложение) и продолжить работу с кодом, можно [скачать этот файл. пакет unitypackage](https://github.com/Microsoft/HolographicAcademy/raw/Azure-MixedReality-Labs/Azure%20Mixed%20Reality%20Labs/MR%20and%20Azure%20308%20-%20Cross-device%20notifications/Azure-MR-308-Desktop.unitypackage), импортировать его в проект в качестве [**пользовательского пакета**](https://docs.unity3d.com/Manual/AssetPackages.html), а затем продолжить в [главе 9](#chapter-9---create-the-tabletoscene-class-in-the-desktop-unity-project).  Все равно потребуется добавить компоненты скрипта.

## <a name="chapter-8---importing-the-dlls-in-unity"></a>Глава 8. импорт библиотек DLL в Unity

Вы будете использовать службу хранилища Azure для Unity (которая самостоятельно использует пакет SDK для .NET для Azure). Дополнительные сведения см. по этой [ссылке о службе хранилища Azure для Unity](https://docs.microsoft.com/sandbox/gamedev/unity/azure-storage-unity).

В Unity существует известная ошибка, которая требует перенастройки подключаемых модулей после импорта. Эти действия (4-7 в этом разделе) больше не понадобятся после устранения ошибки.

Чтобы импортировать пакет SDK в собственный проект, убедитесь, что вы скачали последнюю версию [**. пакет unitypackage**](https://aka.ms/azstorage-unitysdk) с сайта GitHub. Затем сделайте следующее.

1.  Добавьте **. пакет unitypackage** в Unity с помощью команды меню **\> \> настраиваемый пакет импорт активов** .

2.  В появившемся окне **Импорт пакета Unity** можно выбрать все в разделе * *_подключаемый модуль_ \> * хранилище * * *.  Снимите флажок все остальное, так как он не требуется для этого курса.

    ![Импорт в пакет](images/AzureLabs-Lab8-61.png)

3.  Нажмите кнопку **_Импорт_* _, чтобы добавить элементы в проект.

4.  Перейдите в папку _ *Storage** в разделе **подключаемые модули** в представлении проекта и выберите *только* следующие подключаемые модули:

    -   Microsoft.Data.Edm
    -   Microsoft.Data.OData
    -   Microsoft.WindowsAzure.Storage
    -   Newtonsoft.Json.
    -   System.Spatial

![снять флажок с любой платформы](images/AzureLabs-Lab8-62.png)

5.  Выбрав *нужные подключаемые модули* , **снимите флажок для** **любой платформы** и **снимите флажок** **всаплайер** , а затем нажмите кнопку **Применить**.

    ![применение библиотек DLL платформы](images/AzureLabs-Lab8-63.png)

    > [!NOTE] 
    > Мы помечаем эти отдельные подключаемые модули для использования только в редакторе Unity. Это связано с тем, что в папке WSA существуют разные версии тех же подключаемых модулей, которые будут использоваться после экспорта проекта из Unity.

6.  В папке подключаемый модуль **хранилища** выберите только:

    -   Microsoft.Data.Services.Client

        ![Set не обрабатывать библиотеки DLL](images/AzureLabs-Lab8-64.png)

7.  Установите флажок **не обрабатывать** в разделе **параметры платформы** и нажмите кнопку **_Применить_* _.

    ![не применять обработку](images/AzureLabs-Lab8-65.png)

    > [!NOTE] 
    > Мы помечаем этот подключаемый модуль "не обрабатывать", так как при обработке этого подключаемого модуля в установщике сборок Unity возникли трудности. Подключаемый модуль по-прежнему будет работать, даже если он не обрабатывается.

## <a name="chapter-9---create-the-tabletoscene-class-in-the-desktop-unity-project"></a>Глава 9. Создание класса Таблетосцене в проекте Unity для настольных систем

Теперь необходимо создать скрипты, содержащие код для запуска приложения.

Первый сценарий, который необходимо создать, — это _ * Таблетосцене * *, который отвечает за:

-   Чтение сущностей в таблице Azure.
-   С помощью табличных данных определите, какие объекты следует порождать и в какой должности.

Второй сценарий, который необходимо создать, — это **клаудсцене**, который отвечает за:

-   Регистрация события щелчка левой кнопкой мыши, чтобы позволить пользователю перетаскивать объекты вокруг сцены.
-   Сериализация данных объекта из этой сцены Unity и отправка их в приложение-функция Azure.

Чтобы создать этот класс, сделайте следующее:

1.  Щелкните правой кнопкой мыши папку **Asset** , расположенную на панели проект, и выберите **создать**  >  **папку**. Назовите папку **Scripts**.

    ![создать папку скриптов](images/AzureLabs-Lab8-66.png)

    ![Папка создания скриптов 2](images/AzureLabs-Lab8-67.png)

2.  Дважды щелкните только что созданную папку, чтобы открыть ее.

3.  Щелкните правой кнопкой мыши внутри папки **Scripts** и выберите пункт **создать**  >  **скрипт C#**. Назовите сценарий **таблетосцене**.

    ![новый скрипт c# ](images/AzureLabs-Lab8-68.png)
     ![ таблетосцене переименование](images/AzureLabs-Lab8-69.png)

4.  Дважды щелкните скрипт, чтобы открыть его в Visual Studio 2017.

5.  Добавьте приведенные ниже пространства имен.

    ```csharp
    using Microsoft.WindowsAzure.Storage;
    using Microsoft.WindowsAzure.Storage.Auth;
    using Microsoft.WindowsAzure.Storage.Table;
    using UnityEngine;
    ```

6.  В классе вставьте следующие переменные:

    ```csharp
        /// <summary>    
        /// allows this class to behave like a singleton
        /// </summary>    
        public static TableToScene instance;

        /// <summary>    
        /// Insert here you Azure Storage name     
        /// </summary>    
        private string accountName = " -- Insert your Azure Storage name -- ";

        /// <summary>    
        /// Insert here you Azure Storage key    
        /// </summary>    
        private string accountKey = " -- Insert your Azure Storage key -- ";
    ```
    
    > [!NOTE] 
    > Замените значение **AccountName** на имя службы хранилища Azure и значение **accountKey** значением ключа, которое находится в службе хранилища Azure, на портале Azure (см. изображение ниже). 
    >
    > ![получение ключа учетной записи](images/AzureLabs-Lab8-70.png)

7.  Теперь добавьте методы **Start ()** и **спящего режима ()** для инициализации класса.

    ```csharp
        /// <summary>
        /// Triggers before initialization
        /// </summary>
        void Awake()
        {
            // static instance of this class
            instance = this;
        }

        /// <summary>
        /// Use this for initialization
        /// </summary>
        void Start()
        {  
            // Call method to populate the scene with new objects as 
            // pecified in the Azure Table
            PopulateSceneFromTableAsync();
        }
    ```

8.  В классе **таблетосцене** добавьте метод, который будет получать значения из таблицы Azure и использовать их для порождения соответствующих примитивов в сцене.

    ```csharp
        /// <summary>    
        /// Populate the scene with new objects as specified in the Azure Table    
        /// </summary>    
        private async void PopulateSceneFromTableAsync()
        {
            // Obtain credentials for the Azure Storage
            StorageCredentials creds = new StorageCredentials(accountName, accountKey);

            // Storage account
            CloudStorageAccount account = new CloudStorageAccount(creds, useHttps: true);
            
            // Storage client
            CloudTableClient client = account.CreateCloudTableClient(); 
            
            // Table reference
            CloudTable table = client.GetTableReference("SceneObjectsTable");

            TableContinuationToken token = null;

            // Query the table for every existing Entity
            do
            {
                // Queries the whole table by breaking it into segments
                // (would happen only if the table had huge number of Entities)
                TableQuerySegment<AzureTableEntity> queryResult = await table.ExecuteQuerySegmentedAsync(new TableQuery<AzureTableEntity>(), token); 

                foreach (AzureTableEntity entity in queryResult.Results)
                {
                    GameObject newSceneGameObject = null;
                    Color newColor;

                    // check for the Entity Type and spawn in the scene the appropriate Primitive
                    switch (entity.Type)
                    {
                        case "Cube":
                            // Create a Cube in the scene
                            newSceneGameObject = GameObject.CreatePrimitive(PrimitiveType.Cube);
                            newColor = Color.blue;
                            break;

                        case "Sphere":
                            // Create a Sphere in the scene
                            newSceneGameObject = GameObject.CreatePrimitive(PrimitiveType.Sphere);
                            newColor = Color.red;
                            break;

                        case "Cylinder":
                            // Create a Cylinder in the scene
                            newSceneGameObject = GameObject.CreatePrimitive(PrimitiveType.Cylinder);
                            newColor = Color.yellow;
                            break;
                        default:
                            newColor = Color.white;
                            break;
                    }

                    newSceneGameObject.name = entity.RowKey;

                    newSceneGameObject.GetComponent<MeshRenderer>().material = new Material(Shader.Find("Diffuse"))
                    {
                        color = newColor
                    };

                    //check for the Entity X,Y,Z and move the Primitive at those coordinates
                    newSceneGameObject.transform.position = new Vector3((float)entity.X, (float)entity.Y, (float)entity.Z);
                }

                // if the token is null, it means there are no more segments left to query
                token = queryResult.ContinuationToken;
            }

            while (token != null);
        }
    ```

9.  За пределами класса **таблетосцене** необходимо определить класс, используемый приложением для сериализации и десериализации **сущностей таблицы**.

    ```csharp
        /// <summary>
        /// This objects is used to serialize and deserialize the Azure Table Entity
        /// </summary>
        [System.Serializable]
        public class AzureTableEntity : TableEntity
        {
            public AzureTableEntity(string partitionKey, string rowKey)
                : base(partitionKey, rowKey) { }

            public AzureTableEntity() { }
            public string Type { get; set; }
            public double X { get; set; }
            public double Y { get; set; }
            public double Z { get; set; }
        }
    ```

10. **Сохраните** данные перед возвратом в редактор Unity.

11. Щелкните **главную камеру** на панели **Иерархия** , чтобы ее свойства отображались в **инспекторе**.

12. Откройте папку **скрипты** , выберите **файл скрипт таблетосцене** и перетащите его на **основную камеру**. Результат должен быть следующим:

    ![Добавить скрипт в основную камеру](images/AzureLabs-Lab8-71.png)

## <a name="chapter-10---create-the-cloudscene-class-in-the-desktop-unity-project"></a>Глава 10. Создание класса Клаудсцене в проекте Unity для настольных систем

Второй сценарий, который необходимо создать, — это **клаудсцене**, который отвечает за:

-   Регистрация события щелчка левой кнопкой мыши, чтобы позволить пользователю перетаскивать объекты вокруг сцены.

-   Сериализация данных объекта из этой сцены Unity и отправка их в приложение-функция Azure.

Чтобы создать второй скрипт, выполните следующие действия.

1.  Щелкните правой кнопкой мыши в папке **Scripts** и выберите **создать**, а затем — **\# Сценарий C**. Назовите сценарий **клаудсцене**
    
    ![новый скрипт c# ](images/AzureLabs-Lab8-72.png)
     ![ Переименование клаудсцене](images/AzureLabs-Lab8-73.png)

2.  Добавьте приведенные ниже пространства имен.

    ```csharp
    using Newtonsoft.Json;
    using System.Collections;
    using System.Text;
    using System.Threading.Tasks;
    using UnityEngine;
    using UnityEngine.Networking;
    ```

3.  Вставьте следующие переменные:

    ```csharp
        /// <summary>
        /// Allows this class to behave like a singleton
        /// </summary>
        public static CloudScene instance;

        /// <summary>
        /// Insert here you Azure Function Url
        /// </summary>
        private string azureFunctionEndpoint = "--Insert here you Azure Function Endpoint--";

        /// <summary>
        /// Flag for object being moved
        /// </summary>
        private bool gameObjHasMoved;

        /// <summary>
        /// Transform of the object being dragged by the mouse
        /// </summary>
        private Transform gameObjHeld;

        /// <summary>
        /// Class hosted in the TableToScene script
        /// </summary>
        private AzureTableEntity azureTableEntity;
    ```

4.  Замените значение **азурефунктионендпоинт** URL-адресом приложение-функция Azure, который находится в службе приложение-функция Azure, на портале Azure, как показано на рисунке ниже.

    ![получить URL-адрес функции](images/AzureLabs-Lab8-74.png)

5.  Теперь добавьте методы **Start ()** и **спящего режима ()** для инициализации класса.

    ```csharp
        /// <summary>
        /// Triggers before initialization
        /// </summary>
        void Awake()
        {
            // static instance of this class
            instance = this;
        }

        /// <summary>
        /// Use this for initialization
        /// </summary>
        void Start()
        {
            // initialise an AzureTableEntity
            azureTableEntity = new AzureTableEntity();
        }
    ```

6.  В методе **Update ()** добавьте следующий код, который определит ввод и перетаскивание мыши, который, в свою очередь, переместит объекты gameobject в сцене. Если пользователь переместил и удалил объект, он передаст имя и координаты объекта методу **упдатеклаудсцене ()**, который вызывает службу Azure приложение-функция, которая будет обновлять таблицу Azure и активировать уведомление.

    ```csharp
        /// <summary>
        /// Update is called once per frame
        /// </summary>
        void Update()
        {
            //Enable Drag if button is held down
            if (Input.GetMouseButton(0))
            {
                // Get the mouse position
                Vector3 mousePosition = new Vector3(Input.mousePosition.x, Input.mousePosition.y, 10);

                Vector3 objPos = Camera.main.ScreenToWorldPoint(mousePosition);

                Ray ray = Camera.main.ScreenPointToRay(Input.mousePosition);

                RaycastHit hit;

                // Raycast from the current mouse position to the object overlapped by the mouse
                if (Physics.Raycast(ray, out hit))
                {
                    // update the position of the object "hit" by the mouse
                    hit.transform.position = objPos;

                    gameObjHasMoved = true;

                    gameObjHeld = hit.transform;
                }
            }

            // check if the left button mouse is released while holding an object
            if (Input.GetMouseButtonUp(0) && gameObjHasMoved)
            {
                gameObjHasMoved = false;

                // Call the Azure Function that will update the appropriate Entity in the Azure Table
                // and send a Notification to all subscribed Apps
                Debug.Log("Calling Azure Function");

                StartCoroutine(UpdateCloudScene(gameObjHeld.name, gameObjHeld.position.x, gameObjHeld.position.y, gameObjHeld.position.z));
            }
        }
    ```

7.  Теперь добавьте метод **упдатеклаудсцене ()** , как показано ниже:

    ```csharp
        private IEnumerator UpdateCloudScene(string objName, double xPos, double yPos, double zPos)
        {
            WWWForm form = new WWWForm();

            // set the properties of the AzureTableEntity
            azureTableEntity.RowKey = objName;

            azureTableEntity.X = xPos;

            azureTableEntity.Y = yPos;

            azureTableEntity.Z = zPos;

            // Serialize the AzureTableEntity object to be sent to Azure
            string jsonObject = JsonConvert.SerializeObject(azureTableEntity);

            using (UnityWebRequest www = UnityWebRequest.Post(azureFunctionEndpoint, jsonObject))
            {
                byte[] jsonToSend = new System.Text.UTF8Encoding().GetBytes(jsonObject);

                www.uploadHandler = new UploadHandlerRaw(jsonToSend);

                www.uploadHandler.contentType = "application/json";

                www.downloadHandler = new DownloadHandlerBuffer();

                www.SetRequestHeader("Content-Type", "application/json");

                yield return www.SendWebRequest();

                string response = www.responseCode.ToString();
            }
        }
    ```

8.  Сохранение кода и возврат в Unity

9.  Перетащите сценарий **клаудсцене** на **основную камеру**. 

    1. Щелкните **главную камеру** на панели **Иерархия** , чтобы ее свойства отображались в **инспекторе**. 

    2. После открытия папки **Scripts (скрипты** ) выберите сценарий **клаудсцене** и перетащите его на **основную камеру**. Результат должен быть следующим:

        > ![Перетащите облачный скрипт на основную камеру](images/AzureLabs-Lab8-75.png)

## <a name="chapter-11---build-the-desktop-project-to-uwp"></a>Глава 11. Создание проекта для настольных систем в UWP

Все, что необходимо для раздела Unity этого проекта, теперь завершено.

1.  Перейдите к **параметрам сборки** (**File**  >  **параметры сборки** файлов).

2.  В окне " **параметры сборки** " щелкните **Сборка**.

    ![проект сборки](images/AzureLabs-Lab8-76.png)

3.  Откроется окно **проводника** , в котором будет предложено создать расположение для сборки. Создайте новую папку (щелкнув **создать папку** в левом верхнем углу) и назовите ее **Build**.

    ![создать папку для сборки](images/AzureLabs-Lab8-77.png)

    1.  Откройте папку "новые **сборки** " и создайте другую папку (с помощью **новой папки** еще раз) и назовите ее **NH \_ Desktop \_ app**.

        ![имя папки NH_Desktop_App](images/AzureLabs-Lab8-78.png)

    2.  Выбрав **\_ классическое \_ приложение NH** . Щелкните **выбрать папку**. Построение проекта займет около минуты.

4.  После сборки появится **окно проводника** , в котором отображается расположение нового проекта. Однако не нужно открывать его, так как сначала необходимо создать другой проект Unity в следующих нескольких главах.


## <a name="chapter-12---set-up-mixed-reality-unity-project"></a>Глава 12. Настройка проекта Unity смешанной реальности

Ниже приведена типичная Настройка для разработки с использованием смешанной реальности, которая является хорошим шаблоном для других проектов.

1.  Откройте **Unity** и нажмите кнопку **создать**.

    ![новый проект Unity](images/AzureLabs-Lab8-79.png)

2.  Теперь необходимо указать имя проекта Unity, вставить **унитимрнотифхуб**. Убедитесь, что для типа проекта задано значение **3D**. Задайте для **расположения нужное расположение** (Помните, что ближе к корневым каталогам лучше). Затем нажмите кнопку **создать проект**.

    ![имя Унитимрнотифхуб](images/AzureLabs-Lab8-80.png)

3.  При открытом Unity стоит проверить, что для **редактора скриптов** по умолчанию задано значение **Visual Studio**. Перейдите к разделу **изменение**  >  **настроек** , а затем в новом окне перейдите к разделу **Внешние инструменты**. Измените **Редактор внешних скриптов** на **Visual Studio 2017**. Закройте окно **настройки** .

    ![присвоить внешнему редактору VS](images/AzureLabs-Lab8-81.png)

4.  Затем перейдите в раздел **File**  >  **параметры сборки** файлов и переключите платформу на **универсальная платформа Windows**, нажав кнопку **коммутатора на платформе** .

    ![Переключение платформ в UWP](images/AzureLabs-Lab8-82.png)

5.  Перейдите в **File** раздел  >  **параметры сборки** файлов и убедитесь в том, что:

    1.  **Целевое устройство** настроено для **любого устройства**

        > Для Microsoft HoloLens задайте для параметра **целевое устройство** значение *HoloLens*.

    2.  Для **типа сборки** задано значение **D3D**

    3.  **Пакет SDK** установлен в значение " **Последняя установка** "

    4.  Для **версии Visual Studio** установлено значение " **Последняя установка** "

    5.  **Сборка и запуск** настроены на **локальный компьютер**

    6.  Здесь стоит сохранить сцену и добавить ее в сборку.

        1. Для этого выберите **Добавить открытые сцены**. Появится окно сохранения.

            ![Добавление открытых сцен](images/AzureLabs-Lab8-83.png)

        2. Создайте новую папку для этого, а также любой будущей сцены, а затем нажмите кнопку **создать папку** , чтобы создать новую папку, назовите ее « **сцены**».

            ![Новая папка сцен](images/AzureLabs-Lab8-84.png)

        3. Откройте только что созданную папку **сцены** , а затем в поле **имя файла:** введите **NH \_ MR \_ сцены** и нажмите кнопку **сохранить**.

            ![Новая сцена — NH_MR_Scene](images/AzureLabs-Lab8-85.png)

    7.  Оставшиеся параметры, в **параметрах сборки**, должны быть оставлены по умолчанию.

6.  В том же окне нажмите кнопку **Параметры проигрывателя** , чтобы открыть связанную панель в пространстве, где находится **инспектор** .    

    ![открыть параметры проигрывателя](images/AzureLabs-Lab8-86.png)

7.  На этой панели необходимо проверить несколько параметров:

    1.  На вкладке **другие параметры** выполните следующие действия.

        1.  Должна быть **экспериментальная** **версия среды выполнения сценариев** (эквивалент .NET 4,6)
        2.  **Серверная часть сценариев** должна быть **_.NET_* _
        3.  _ *Уровень совместимости API** должен быть **.NET 4,6**

            ![совместимость API](images/AzureLabs-Lab8-87.png)

    2.  На панели в **параметрах XR** (см. ниже **Параметры публикации**), **поддерживаемая виртуальная реальность** Tick, убедитесь, что добавлен **пакет SDK для Windows Mixed Reality** .

        ![обновить параметры XR](images/AzureLabs-Lab8-88.png)        

    3.  На вкладке **Параметры публикации** в разделе **возможности**:

        - **InternetClient**;           

            ![Клиент Tick Internet](images/AzureLabs-Lab8-89.png)

8.  Вернувшись в **параметры сборки**. **проекты C# для Unity** больше не заключаются: установите флажок рядом с этим.

9.  После внесения этих изменений закройте окно параметры сборки.

10. Сохраните сцену и файл проекта **File**  >  **сохранить сцену/файл**  >  **сохранить проект**.

    > [!IMPORTANT]
    > Если вы хотите пропустить компонент *настройки Unity* для этого проекта (приложение Mixed Reality) и продолжить работу с кодом, [Скачайте этот файл. пакет unitypackage](https://github.com/Microsoft/HolographicAcademy/raw/Azure-MixedReality-Labs/Azure%20Mixed%20Reality%20Labs/MR%20and%20Azure%20308%20-%20Cross-device%20notifications/Azure-MR-308-MR.unitypackage), импортируйте его в проект в качестве [**пользовательского пакета**](https://docs.unity3d.com/Manual/AssetPackages.html), а затем продолжайте в [главе 14](#chapter-14---creating-the-tabletoscene-class-in-the-mixed-reality-unity-project). Все равно потребуется добавить компоненты скрипта.

### <a name="chapter-13---importing-the-dlls-in-the-mixed-reality-unity-project"></a>Глава 13. импорт библиотек DLL в проекте Unity смешанной реальности

Вы будете использовать службу хранилища Azure для библиотеки Unity (которая использует пакет SDK для .NET для Azure). Перейдите по этой [ссылке, чтобы использовать службу хранилища Azure с Unity](https://docs.microsoft.com/sandbox/gamedev/unity/azure-storage-unity).
В Unity существует известная ошибка, которая требует перенастройки подключаемых модулей после импорта. Эти действия (4-7 в этом разделе) больше не понадобятся после устранения ошибки.

Чтобы импортировать пакет SDK в собственный проект, убедитесь, что вы скачали последнюю версию [. пакет unitypackage](https://aka.ms/azstorage-unitysdk). Затем сделайте следующее.

1.  Добавьте файл. пакет unitypackage, скачанный из приведенных выше, в Unity с **Assets** помощью команды  >  **Import Package**  >  меню **настраиваемый пакет** для импорта активов.

2.  В появившемся окне **Импорт пакета Unity** можно выбрать все в разделе хранилище **подключаемых модулей**  >  **Storage**.

    ![Импорт пакета](images/AzureLabs-Lab8-90.png)

3.  Нажмите кнопку **Импорт** , чтобы добавить элементы в проект.

4.  Перейдите в папку **хранилища** **подключаемых модулей** в представлении проекта и выберите *только* следующие подключаемые модули:

    -   Microsoft.Data.Edm
    -   Microsoft.Data.OData
    -   Microsoft.WindowsAzure.Storage
    -   Newtonsoft.Json.
    -   System.Spatial

    ![Выбор подключаемых модулей](images/AzureLabs-Lab8-91.png)

5.  Выбрав *нужные подключаемые модули* , **снимите флажок для** **любой платформы** и **снимите флажок** **всаплайер** , а затем нажмите кнопку **Применить**.

    ![применить изменения платформы](images/AzureLabs-Lab8-92.png)

    > [!NOTE] 
    > Эти отдельные подключаемые модули помечаются для использования только в редакторе Unity. Это связано с тем, что в папке WSA существуют разные версии тех же подключаемых модулей, которые будут использоваться после экспорта проекта из Unity.

6.  В папке подключаемый модуль **хранилища** выберите только:

    -   Microsoft.Data.Services.Client

        ![Выбор клиента служб данных](images/AzureLabs-Lab8-93.png)

7.  Установите флажок **не обрабатывать** в разделе **параметры платформы** и нажмите кнопку **Применить**.

    ![не обрабатывать](images/AzureLabs-Lab8-94.png)

    > [!NOTE] 
    > Вы помечаете этот подключаемый модуль как "не обрабатывать", так как у него возникли трудности с обработкой этого подключаемого модуля. Подключаемый модуль по-прежнему будет работать, даже если он не обрабатывается.

## <a name="chapter-14---creating-the-tabletoscene-class-in-the-mixed-reality-unity-project"></a>Глава 14. Создание класса Таблетосцене в проекте Unity для смешанной реальности

Класс **таблетосцене** идентичен описанному в [главе 9](#chapter-9---create-the-tabletoscene-class-in-the-desktop-unity-project). Создайте тот же класс в проекте Unity смешанной реальности, следуя той же процедуре, описанной в [главе 9](#chapter-9---create-the-tabletoscene-class-in-the-desktop-unity-project).

После завершения этой главы в обоих **проектах Unity** этот класс будет настроен на основной камере.

## <a name="chapter-15---creating-the-notificationreceiver-class-in-the-mixed-reality-unity-project"></a>Глава 15. Создание класса Нотификатионрецеивер в проекте Unity для смешанной реальности

Второй сценарий, который необходимо создать, — это **нотификатионрецеивер**, который отвечает за:

-   Регистрация приложения в центре уведомлений при инициализации.
-   Прослушивание уведомлений, поступающих от концентратора уведомлений.
-   Десериализация данных объекта из полученных уведомлений.
-   Переместить объекты gameobject в сцене на основе десериализованных данных.

Чтобы создать скрипт **нотификатионрецеивер** , выполните следующие действия.

1.  Щелкните правой кнопкой мыши в папке **Scripts** и выберите **создать**, а затем — **\# Сценарий C**. Назовите сценарий **нотификатионрецеивер**.

    ![Создание нового имени сценария c#, ](images/AzureLabs-Lab8-95.png)
     ![ нотификатионрецеивер](images/AzureLabs-Lab8-96.png)

2.  Дважды щелкните скрипт, чтобы открыть его.

3.  Добавьте приведенные ниже пространства имен.

    ```csharp
    //using Microsoft.WindowsAzure.Messaging;
    using Newtonsoft.Json;
    using System;
    using System.Collections;
    using UnityEngine;

    #if UNITY_WSA_10_0 && !UNITY_EDITOR
    using Windows.Networking.PushNotifications;
    #endif
    ```

4.  Вставьте следующие переменные:

    ```csharp
        /// <summary>
        /// allows this class to behave like a singleton
        /// </summary>
        public static NotificationReceiver instance;

        /// <summary>
        /// Value set by the notification, new object position
        /// </summary>
        Vector3 newObjPosition;

        /// <summary>
        /// Value set by the notification, object name
        /// </summary>
        string gameObjectName;

        /// <summary>
        /// Value set by the notification, new object position
        /// </summary>
        bool notifReceived;

        /// <summary>
        /// Insert here your Notification Hub Service name 
        /// </summary>
        private string hubName = " -- Insert the name of your service -- ";

        /// <summary>
        /// Insert here your Notification Hub Service "Listen endpoint"
        /// </summary>
        private string hubListenEndpoint = "-Insert your Notification Hub Service Listen endpoint-";
    ```

5.  Замените значение **hubName** на имя службы центра уведомлений и значение **хублистенендпоинт** на значение конечной точки на вкладке политики доступа (служба концентратора уведомлений Azure) на портале Azure (см. изображение ниже).

    ![вставить конечную точку политики концентраторов уведомлений](images/AzureLabs-Lab8-97.png)

6.  Теперь добавьте методы **Start ()** и **спящего режима ()** для инициализации класса.

    ```csharp
        /// <summary>
        /// Triggers before initialization
        /// </summary>
        void Awake()
        {
            // static instance of this class
            instance = this;
        }

        /// <summary>
        /// Use this for initialization
        /// </summary>
        void Start()
        {
            // Register the App at launch
            InitNotificationsAsync();

            // Begin listening for notifications
            StartCoroutine(WaitForNotification());
        }
    ```

7.  Добавьте метод **ваитфорнотификатион** , чтобы разрешить приложению получать уведомления из библиотеки концентратора уведомлений без конфликта с основным потоком:

    ```csharp
        /// <summary>
        /// This notification listener is necessary to avoid clashes 
        /// between the notification hub and the main thread   
        /// </summary>
        private IEnumerator WaitForNotification()
        {
            while (true)
            {
                // Checks for notifications each second
                yield return new WaitForSeconds(1f);

                if (notifReceived)
                {
                    // If a notification is arrived, moved the appropriate object to the new position
                    GameObject.Find(gameObjectName).transform.position = newObjPosition;

                    // Reset the flag
                    notifReceived = false;
                }
            }
        }
    ```

8.  Следующий метод, **инитнотификатионасинк ()**, будет регистрировать приложение в службе концентратора уведомлений при инициализации. Код записывается в комментарий, так как Unity не сможет построить проект. Комментарии будут удалены при импорте пакета NuGet для обмена сообщениями Azure в Visual Studio.

    ```csharp
        /// <summary>
        /// Register this application to the Notification Hub Service
        /// </summary>
        private async void InitNotificationsAsync()
        {
            // PushNotificationChannel channel = await PushNotificationChannelManager.CreatePushNotificationChannelForApplicationAsync();

            // NotificationHub hub = new NotificationHub(hubName, hubListenEndpoint);

            // Registration result = await hub.RegisterNativeAsync(channel.Uri);

            // If registration was successful, subscribe to Push Notifications
            // if (result.RegistrationId != null)
            // {
            //     Debug.Log($"Registration Successful: {result.RegistrationId}");
            //     channel.PushNotificationReceived += Channel_PushNotificationReceived;
            // }
        }
    ```

9.  Следующий обработчик **Channel \_ пушнотификатионрецеивед ()** будет срабатывать при каждом получении уведомления. Будет выполнена десериализация уведомления, которое будет являться сущностью таблицы Azure, перемещенной в классическое приложение, а затем переместить соответствующий GameObject в сцене с той же позицией. 
    
    > [!IMPORTANT]
    > Код записывается в комментарий, поскольку код ссылается на библиотеку обмена сообщениями Azure, которую вы добавите после сборки проекта Unity с помощью диспетчера пакетов NuGet в Visual Studio. Таким образом, проект Unity не сможет выполнить сборку, пока не будет добавлен в комментарий. Имейте в виду, что при построении проекта и последующем возврате к Unity необходимо будет **повторно закомментировать** этот код.

    ```csharp
        ///// <summary>
        ///// Handler called when a Push Notification is received
        ///// </summary>
        //private void Channel_PushNotificationReceived(PushNotificationChannel sender, PushNotificationReceivedEventArgs args)    
        //{
        //    Debug.Log("New Push Notification Received");
        //
        //    if (args.NotificationType == PushNotificationType.Raw)
        //    {
        //        //  Raw content of the Notification
        //        string jsonContent = args.RawNotification.Content;
        //
        //        // Deserialise the Raw content into an AzureTableEntity object
        //        AzureTableEntity ate = JsonConvert.DeserializeObject<AzureTableEntity>(jsonContent);
        //
        //        // The name of the Game Object to be moved
        //        gameObjectName = ate.RowKey;          
        //
        //        // The position where the Game Object has to be moved
        //        newObjPosition = new Vector3((float)ate.X, (float)ate.Y, (float)ate.Z);
        //
        //        // Flag thats a notification has been received
        //        notifReceived = true;
        //    }
        //}
    ```

10. Не забудьте сохранить изменения перед возвратом в редактор Unity.

11. Щелкните **главную камеру** на панели **Иерархия** , чтобы ее свойства отображались в **инспекторе**.

12. После открытия папки **Scripts (скрипты** ) выберите сценарий **нотификатионрецеивер** и перетащите его на **основную камеру**. Результат должен быть следующим:

    ![Перетащите скрипт получателя уведомлений на камеру](images/AzureLabs-Lab8-98.png)

    > [!NOTE]
    > Если вы разрабатываете это для Microsoft HoloLens, необходимо обновить компонент *камеры* **основной камеры**, чтобы:
    > - Снять флаги: сплошной цвет
    > - Фон: черный

## <a name="chapter-16---build-the-mixed-reality-project-to-uwp"></a>Глава 16. Создание проекта смешанной реальности для UWP

Эта глава идентична процессу сборки для предыдущего проекта. Все необходимое для раздела Unity этого проекта теперь завершено, поэтому пришло время создать его из Unity.

1.  Перейдите к **параметрам сборки** ( **File**  >  **параметры сборки** файлов).

2.  В меню **параметры сборки** убедитесь, что **проекты C# для Unity** _ являются тактовыми (что позволит вам редактировать скрипты в этом проекте после сборки).

3.  По завершении нажмите кнопку _ * сборка * *.

    ![проект сборки](images/AzureLabs-Lab8-99.png)

4.  Откроется окно **проводника** , в котором будет предложено создать расположение для сборки. Создайте новую папку (щелкнув **создать папку** в левом верхнем углу) и назовите ее **Build**.

    ![создать папку сборок](images/AzureLabs-Lab8-100.png)

    1.  Откройте папку "новые **сборки** " и создайте другую папку (с помощью **новой папки** еще раз) и назовите ее **NH- \_ \_ приложение MR**.

        ![создать папку NH_MR_Apps](images/AzureLabs-Lab8-101.png)

    2.  Выбрав **приложение NH \_ MR \_** . Щелкните **выбрать папку**. Построение проекта займет около минуты.

5.  После сборки откроется окно **проводника** , в котором находится новый проект.



## <a name="chapter-17---add-nuget-packages-to-the-unitymrnotifhub-solution"></a>Глава 17. Добавление пакетов NuGet в решение Унитимрнотифхуб

> [!WARNING] 
> Помните, что после добавления следующих пакетов NuGet (и раскомментируйте код в следующей [главе](#chapter-18---edit-unitymrnotifhub-application-notificationreceiver-class)) код, при повторном открытии в проекте Unity, будет представлять ошибки. Если вы хотите вернуться и продолжить редактирование в редакторе Unity, вам потребуется комментарий, ерросоме код, а затем раскомментировать его позже, как только вы вернетесь в Visual Studio. 

После завершения сборки Mixed Reality перейдите к проекту Mixed Reality, который вы создали, и дважды щелкните файл решения (SLN) в этой папке, чтобы открыть решение с помощью Visual Studio 2017.
Теперь необходимо добавить пакет NuGet **WindowsAzure. Messaging. Managed.** это библиотека, которая используется для получения уведомлений из центра уведомлений.

Чтобы импортировать пакет NuGet, выполните следующие действия.

1.  В **Обозреватель решений** щелкните решение правой кнопкой мыши.

2.  Щелкните **Управление пакетами NuGet**.

    ![открыть диспетчер NuGet](images/AzureLabs-Lab8-102.png)

3.  **_Browse_*Откройте вкладку "Обзор" и выполните поиск по слову _* WindowsAzure. Messaging. Managed**.

    ![Поиск пакета Windows Azure Messaging](images/AzureLabs-Lab8-103.png)

4.  Выберите результат (как показано ниже) и в окне справа установите флажок рядом с пунктом **проект**. Он поместит такт в флажок рядом с **Project**, а также флажок рядом с проектом **Сборка — CSharp** и **унитимрнотифхуб** .

    ![тикать все проекты](images/AzureLabs-Lab8-104.png)

5.  Изначально указанная версия **может** быть несовместима с этим проектом. Поэтому щелкните раскрывающееся меню рядом с пунктом **Version (версия**) и выберите **Version 0.1.7.9 (версия**), а затем нажмите кнопку **установить**.

6.  Установка пакета NuGet завершена. Найдите код с комментарием, введенный в классе **нотификатионрецеивер** , и удалите комментарии.



## <a name="chapter-18---edit-unitymrnotifhub-application-notificationreceiver-class"></a>Глава 18 — изменение приложения Унитимрнотифхуб, класс Нотификатионрецеивер

После добавления **пакетов NuGet** необходимо *раскомментировать* часть кода в классе **нотификатионрецеивер** .

В том числе:

1. Пространство имен в верхней части:

    ```csharp
    using Microsoft.WindowsAzure.Messaging;
    ```

2. Весь код в методе **InitNotificationsAsync ()** :

    ```csharp
        /// <summary>
        /// Register this application to the Notification Hub Service
        /// </summary>
        private async void InitNotificationsAsync()
        {
            PushNotificationChannel channel = await PushNotificationChannelManager.CreatePushNotificationChannelForApplicationAsync();

            NotificationHub hub = new NotificationHub(hubName, hubListenEndpoint);

            Registration result = await hub.RegisterNativeAsync(channel.Uri);

            // If registration was successful, subscribe to Push Notifications
            if (result.RegistrationId != null)
            {
                Debug.Log($"Registration Successful: {result.RegistrationId}");
                channel.PushNotificationReceived += Channel_PushNotificationReceived;
            }
        }
    ```

> [!WARNING]
> В приведенном выше коде есть комментарий: Убедитесь, что вы случайно не изменили *комментирование* комментария (так как код не будет компилироваться, если у вас есть!).

3. И наконец, событие **Channel_PushNotificationReceived** :

    ```csharp
        /// <summary>
        /// Handler called when a Push Notification is received
        /// </summary>
        private void Channel_PushNotificationReceived(PushNotificationChannel sender, PushNotificationReceivedEventArgs args)
        {
            Debug.Log("New Push Notification Received");

            if (args.NotificationType == PushNotificationType.Raw)
            {
                //  Raw content of the Notification
                string jsonContent = args.RawNotification.Content;

                // Deserialize the Raw content into an AzureTableEntity object
                AzureTableEntity ate = JsonConvert.DeserializeObject<AzureTableEntity>(jsonContent);

                // The name of the Game Object to be moved
                gameObjectName = ate.RowKey;

                // The position where the Game Object has to be moved
                newObjPosition = new Vector3((float)ate.X, (float)ate.Y, (float)ate.Z);

                // Flag thats a notification has been received
                notifReceived = true;
            }
        }
    ```

Выполнив эти комментарии, убедитесь, что вы сохранили, а затем переходите к следующей главе.

## <a name="chapter-19---associate-the-mixed-reality-project-to-the-store-app"></a>Глава 19. Связывание проекта Mixed Reality с приложением магазина

Теперь необходимо связать проект **Mixed Reality** с приложением магазина, созданным в начале лаборатории.

1.  Откройте решение.

2.  Щелкните правой кнопкой мыши проект приложения UWP на панели обозреватель решений, выберите **магазин** и **свяжите приложение с магазином...**

    ![открыть ассоциацию магазина](images/AzureLabs-Lab8-105.png)

3.  Появится новое окно **с именем связать приложение с магазином Windows**. Нажмите кнопку **Далее**.

    ![Переход к следующему экрану](images/AzureLabs-Lab8-106.png)

4.  Будут загружены все приложения, связанные с учетной записью, с которой вы выполнили вход. Если вы не вошли в учетную запись, вы можете **войти** на эту страницу.

5.  Найдите **имя приложения Магазина** , созданное в начале этого руководства, и выберите его. Затем нажмите кнопку **Далее**.

    ![Найдите и выберите имя вашего магазина.](images/AzureLabs-Lab8-107.png)

6.  Щелкните **Связать**.

    ![связать приложение](images/AzureLabs-Lab8-108.png)

7.  Теперь ваше приложение **связано** с приложением магазина. Это необходимо для включения уведомлений.

## <a name="chapter-20---deploy-unitymrnotifhub-and-unitydesktopnotifhub-applications"></a>Глава 20. Развертывание приложений Унитимрнотифхуб и Унитидесктопнотифхуб

Эта глава может быть проще с двумя людьми, так как в результате будут включены оба приложения, работающие на рабочем столе компьютера, а другая — в иммерсивное гарнитуру.

Иммерсивное приложение в гарнитуре ожидает получения изменений в сцене (изменение расположения локальных объекты gameobject), а классическое приложение будет вносить изменения в локальную сцену (изменения позиционирования), которые будут использоваться совместно с приложением MR. Имеет смысл сначала развернуть приложение MR, а затем классическое приложение, чтобы получатель мог начать прослушивание.

Чтобы развернуть приложение **унитимрнотифхуб** на локальном компьютере, выполните следующие действия.

1.  Откройте файл решения приложения **унитимрнотифхуб** в **Visual Studio 2017**.

2.  На **платформе решения** выберите **x86, локальный компьютер**.

3.  В **конфигурации решения** выберите **Отладка**.

    ![Задание конфигурации проекта](images/AzureLabs-Lab8-109.png)

4.  Перейдите в **меню "сборка** " и щелкните " **Развернуть решение** ", чтобы загружать неопубликованные приложение на компьютере.

5.  Теперь приложение должно отобразиться в списке установленных приложений, готовых к запуску.

Чтобы развернуть приложение **унитидесктопнотифхуб** на локальном компьютере, выполните следующие действия.

1.  Откройте файл решения приложения **унитидесктопнотифхуб** в **Visual Studio 2017**.

2.  На **платформе решения** выберите **x86, локальный компьютер**.

3.  В **конфигурации решения** выберите **Отладка**.

    ![Задание конфигурации проекта](images/AzureLabs-Lab8-110.png)

4.  Перейдите в **меню "сборка** " и щелкните " **Развернуть решение** ", чтобы загружать неопубликованные приложение на компьютере.

5.  Теперь приложение должно отобразиться в списке установленных приложений, готовых к запуску.

6.  Запустите приложение Mixed Reality, а затем настольное приложение.

При запуске обоих приложений переместите объект в классической сцене (с помощью левой кнопки мыши). Эти позиционированные изменения будут сделаны локально, сериализованы и отправлены в службу приложение-функция. Затем служба приложение-функция обновит таблицу вместе с концентратором уведомлений. После получения обновления Центр уведомлений отправит обновленные данные непосредственно во все зарегистрированные приложения (в данном случае это приложение для иммерсивного гарнитуры), которое затем десериализует входящие данные и применяет новые позиционированные данные к локальным объектам, перемещая их в сцену.


## <a name="your-finished-your-azure-notification-hubs-application"></a>Ваше приложение для центров уведомлений Azure завершено
 
Поздравляем, вы создали приложение смешанной реальности, которое использует службу концентраторов уведомлений Azure и разрешают обмен данными между приложениями.
 
![окончательный конец продукта](images/AzureLabs-Lab8-00.png)
 
## <a name="bonus-exercises"></a>Дополнительные упражнения

### <a name="exercise-1"></a>Упражнение 1

Можно ли изменить цвет объекты gameobject и отправить это уведомление другим приложениям, просматривающим сцену?

### <a name="exercise-2"></a>Упражнение 2

Можно ли добавить перемещение объекты gameobject в приложение MR и просмотреть обновленную сцену в классическом приложении?
