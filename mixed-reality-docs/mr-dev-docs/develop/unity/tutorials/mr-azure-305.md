---
title: 305. Смешанная реальность и Azure — функции и хранилище
description: Пройдите этот курс, чтобы узнать, как реализовать службу хранилища Azure и функции в приложении смешанной реальности.
author: drneil
ms.author: jemccull
ms.date: 07/04/2018
ms.topic: article
keywords: Azure, Mixed Reality, Academy, Unity, учебник, API, функции, хранилище, hololens, иммерсивное, VR, Windows 10, Visual Studio
ms.openlocfilehash: 5c9784446923b3eae7a600b8e672574ce6465038
ms.sourcegitcommit: d3a3b4f13b3728cfdd4d43035c806c0791d3f2fe
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/20/2021
ms.locfileid: "98583428"
---
# <a name="mr-and-azure-305-functions-and-storage"></a>305. Смешанная реальность и Azure: функции и хранилище

<br>

>[!NOTE]
>Руководства Mixed Reality Academy были разработаны для иммерсивных гарнитур HoloLens (1-го поколения) и иммерсивных гарнитур Mixed Reality.  Поэтому мы считаем, что важно оставить эти руководства для разработчиков, которые ищут рекомендации по разработке для этих устройств.  Данные руководства **_не_** будут обновляться с учетом последних наборов инструментов или возможностей взаимодействия для HoloLens 2.  Они будут сохранены для работы на поддерживаемых устройствах. Появится новая серия руководств, которые будут опубликованы в будущем, где будет показано, как разрабатывать данные для HoloLens 2.  Это уведомление будет обновлено ссылкой на эти учебники при их публикации.

<br> 

![окончательный продукт — запуск](images/AzureLabs-Lab5-00.png)

В этом курсе вы узнаете, как создавать и использовать функции Azure и хранить данные в ресурсе службы хранилища Azure в приложении смешанной реальности.

*Функции Azure* — это служба Майкрософт, которая позволяет разработчикам запускать небольшие фрагменты кода "функции" в Azure. Это позволяет делегировать работу в облако, а не локальное приложение, которое может иметь множество преимуществ. *Функции Azure* поддерживают несколько языков разработки, включая C \# , F \# , Node.js, Java и PHP. Дополнительные сведения см. в [статье о функциях Azure](/azure/azure-functions/functions-overview).

*Хранилище Azure* — это облачная служба Майкрософт, которая позволяет разработчикам хранить данные с страховкой, которая будет высокодоступной, безопасной, устойчивой, масштабируемой и избыточной. Это означает, что корпорация Майкрософт будет выполнять все задачи обслуживания и критические проблемы. Дополнительные сведения см. в [статье о службе хранилища Azure](/azure/storage/common/storage-introduction).

Прополнив этот курс, вы получите иммерсивное приложение для наушников, которое сможет сделать следующее:

1.  Позволяет пользователю взходить на сцену.
2.  Активировать порождение объектов, когда пользователь высматривает трехмерную кнопку "Кнопка".
3.  Порожденные объекты будут выбраны функцией Azure.
4.  При порождении каждого объекта приложение сохранит тип объекта в *файле Azure*, расположенном в *службе хранилища Azure*.
5.  После второй загрузки данные *файла Azure* будут получены и использованы для воспроизведения порожденных действий от предыдущего экземпляра приложения.

В приложении вы будете выполнять интеграцию результатов с вашей структурой. Этот курс предназначен для изучения того, как интегрировать службу Azure с проектом Unity. Это ваша задача использовать знания, полученные из этого курса, для улучшения приложения смешанной реальности.

## <a name="device-support"></a>Поддержка устройств

<table>
<tr>
<th>Курс</th><th style="width:150px"> <a href="/hololens/hololens1-hardware">HoloLens</a></th><th style="width:150px"> <a href="../../../discover/immersive-headset-hardware-details.md">Иммерсивные гарнитуры</a></th>
</tr><tr>
<td>305. Смешанная реальность и Azure: функции и хранилище</td><td style="text-align: center;"> ✔️</td><td style="text-align: center;"> ✔️</td>
</tr>
</table>

> [!NOTE]
> Хотя этот курс в основном ориентирован на гарнитуры Windows Mixed Reality (VR), вы также можете применить сведения, которые вы узнаете в этом курсе, к Microsoft HoloLens. Как вы пройдете вместе с курсом, вы увидите примечания о любых изменениях, которые могут потребоваться для поддержки HoloLens.

## <a name="prerequisites"></a>Предварительные требования

> [!NOTE]
> Этот учебник предназначен для разработчиков, имеющих базовый опыт работы с Unity и C#. Также имейте в виду, что предварительные требования и письменные инструкции в этом документе отражают, что проверялось и проверено во время написания статьи (Май 2018). Вы можете использовать новейшее программное обеспечение, как указано в статье [Установка средств](../../install-the-tools.md) , но не следует предполагать, что информация в этом курсе будет полностью соответствовать тому, что вы найдете в более новом программном обеспечении, чем показано ниже.

Для этого курса рекомендуется следующее оборудование и программное обеспечение:

- ПК для разработки, [совместимый с Windows Mixed Reality](https://support.microsoft.com/help/4039260/windows-10-mixed-reality-pc-hardware-guidelines) для разработки головных телефонов (VR)
- [Windows 10 для дизайнеров с обновлением (или более поздней версии) с включенным режимом разработчика](../../install-the-tools.md#installation-checklist)
- [Последний пакет SDK для Windows 10](../../install-the-tools.md#installation-checklist)
- [Unity 2017,4](../../install-the-tools.md#installation-checklist)
- [Visual Studio 2017](../../install-the-tools.md#installation-checklist)
- Высокодоступная [гарнитура Windows Mixed Reality (VR)](../../../discover/immersive-headset-hardware-details.md) или [Microsoft HoloLens](/hololens/hololens1-hardware) с включенным режимом разработчика
- Подписка на учетную запись Azure для создания ресурсов Azure.
- Доступ к Интернету для установки Azure и извлечения данных

## <a name="before-you-start"></a>Перед началом работы

Чтобы избежать проблем при создании этого проекта, настоятельно рекомендуется создать проект, упомянутый в этом руководстве, в корневой или ближайшем к корневой папке (длинные пути к папкам могут вызвать проблемы во время сборки).

## <a name="chapter-1---the-azure-portal"></a>Глава 1. портал Azure

Чтобы использовать **службу хранилища Azure**, вам потребуется создать и настроить **учетную запись хранения** в портал Azure.

1.  Войдите на  [портал Azure](https://portal.azure.com).

    > [!NOTE]
    > Если у вас еще нет учетной записи Azure, необходимо создать ее. Если вы используете этот учебник в учебной или лабораторной ситуации, обратитесь к своему преподавателю или к одной из прокторс, чтобы получить помощь в настройке новой учетной записи.

2.  Войдя в систему, щелкните New ( **создать** ) в левом верхнем углу, а затем найдите *учетную запись хранения* и нажмите клавишу **Ввод**.

    ![Поиск в службе хранилища Azure](images/AzureLabs-Lab5-01.png)

    > [!NOTE]
    > Слово **New** может быть заменено на **создать ресурс** в новых порталах.

3.  На новой странице будет представлено описание службы *учетной записи хранения Azure* . В нижнем левом углу этого запроса нажмите кнопку **создать** , чтобы создать связь с этой службой.

    ![Создание службы](images/AzureLabs-Lab5-02.png)

4.  После нажатия кнопки **создать**:

    1.  Введите *имя* для своей учетной записи. Имейте в виду, что это поле принимает только цифры и строчные буквы.

    2.  В качестве *модели развертывания* выберите **Resource Manager**.

    3.  В качестве *типа учетной записи* выберите **хранилище (общее назначение v1)**.

    4.  Определите *Расположение* группы ресурсов (при создании новой группы ресурсов). В идеале это расположение будет находиться в регионе, в котором будет выполняться приложение. Некоторые ресурсы Azure доступны только в определенных регионах.

    5.  Для *репликации* выберите **геоизбыточное хранилище (RA-GRS) с доступом для чтения**.

    6.  В разделе *Производительность* выберите **Стандартная**.

    7.  Оставьте *защищенное перемещение обязательным* , как **отключено**.

    8.  Выберите *подписку*.

    9. Выберите *группу ресурсов* или создайте новую. Группа ресурсов предоставляет способ мониторинга, контроля доступа, подготовки счетов и управления ими для коллекции ресурсов Azure. Рекомендуется, чтобы все службы Azure, связанные с одним проектом (например, в этих лабораториях), были в общей группе ресурсов. 

        > Если вы хотите ознакомиться с дополнительными сведениями о группах ресурсов Azure, обратитесь [к статье о группе ресурсов](/azure/azure-resource-manager/resource-group-portal).

    10. Также необходимо подтвердить, что вы поняли условия, примененные к этой службе.

    11. Нажмите кнопку **создания**.

        ![сведения о входной службе](images/AzureLabs-Lab5-03.png)

5.  После нажатия кнопки **создать** необходимо подождать, пока не будет создана служба, а это может занять некоторое время.

6.  После создания экземпляра службы на портале отобразится уведомление.

    ![новое уведомление на портале Azure](images/AzureLabs-Lab5-04.png)

7.  Щелкните уведомления, чтобы изучить новый экземпляр службы.

    ![Переход к ресурсу](images/AzureLabs-Lab5-05.png)

8.  Нажмите кнопку " **Переход к ресурсу** " в уведомлении, чтобы изучить новый экземпляр службы. Вы будете перенаправлены на новый экземпляр службы *учетной записи хранения* .

    ![ключи доступа](images/AzureLabs-Lab5-06.png)

9.  Щелкните *ключи доступа*, чтобы отобразить конечные точки для этой облачной службы. Чтобы скопировать один из ключей для последующего использования, используйте *Блокнот* или аналогичный. Кроме того, обратите внимание на значение *строки подключения* , так как оно будет использоваться в классе *азуресервицес* , который будет создан позже.

    ![Копировать строку подключения](images/AzureLabs-Lab5-07.png)

## <a name="chapter-2---setting-up-an-azure-function"></a>Глава 2. Настройка функции Azure

Теперь вы можете написать функцию **Azure**  в службе Azure.

**Функцию Azure** можно использовать для практически любых действий, выполняемых с классической функцией в коде. разница заключается в том, что доступ к этой функции может осуществляться любым приложением, имеющим учетные данные для доступа к учетной записи Azure.

Чтобы создать функцию Azure, выполните следующие действия.

1.  На *портале Azure* щелкните **создать** в левом верхнем углу и найдите *приложение-функция* и нажмите клавишу **Ввод**.

    ![Создание приложения функции](images/AzureLabs-Lab5-08.png)

    > [!NOTE]
    > Слово **New** может быть заменено на **создать ресурс** в новых порталах.

2.  На новой странице будет представлено описание службы *приложение-функция Azure* . В нижнем левом углу этого запроса нажмите кнопку **создать** , чтобы создать связь с этой службой.

    ![сведения о приложении функции](images/AzureLabs-Lab5-09.png)

3.  После нажатия кнопки **создать**:

    1.  Укажите *имя приложения*. Здесь можно использовать только буквы и цифры (допускается использование прописных и строчных букв).

    2.  Выберите предпочитаемую *подписку*.

    3. Выберите *группу ресурсов* или создайте новую. Группа ресурсов предоставляет способ мониторинга, контроля доступа, подготовки счетов и управления ими для коллекции ресурсов Azure. Рекомендуется, чтобы все службы Azure, связанные с одним проектом (например, в этих лабораториях), были в общей группе ресурсов. 

        > Если вы хотите ознакомиться с дополнительными сведениями о группах ресурсов Azure, обратитесь [к статье о группе ресурсов](/azure/azure-resource-manager/resource-group-portal).

    4.  В этом упражнении выберите *Windows* в качестве выбранной **ОС**.

    5.  Выберите *план потребления* для **плана размещения**.

    6.  Определите *Расположение* группы ресурсов (при создании новой группы ресурсов). В идеале это расположение будет находиться в регионе, в котором будет выполняться приложение. Некоторые ресурсы Azure доступны только в определенных регионах. Для оптимальной производительности выберите тот же регион, что и для учетной записи хранения.

    7.  В поле *хранилище* выберите **использовать существующий**, а затем в раскрывающемся меню найдите созданное ранее хранилище.

    8.  Для этого упражнения не выполняйте *Application Insights* .

        ![сведения о приложении входной функции](images/AzureLabs-Lab5-10.png)

4.  Нажмите кнопку **Создать** .

5.  После нажатия кнопки **создать** необходимо подождать, пока не будет создана служба, а это может занять некоторое время.

6.  После создания экземпляра службы на портале отобразится уведомление.

    ![новое уведомление на портале Azure](images/AzureLabs-Lab5-11.png)

7.  Щелкните уведомления, чтобы изучить новый экземпляр службы. 

    ![Переход к приложению функции ресурсов](images/AzureLabs-Lab5-12.png)

8.  Нажмите кнопку " **Переход к ресурсу** " в уведомлении, чтобы изучить новый экземпляр службы. Вы будете перенаправлены на новый экземпляр службы *приложение-функция* .

9.  На панели мониторинга *приложение-функция* наведите указатель мыши на *функции*, расположенные на панели слева, а затем щелкните символ **+ (плюс)** .

    ![создать новую функцию](images/AzureLabs-Lab5-13.png)

10. На следующей странице убедитесь, что **веб-перехватчик + API** выбран, и для *выбора языка* выберите **CSharp**, так как это будет язык, используемый в этом руководстве. Наконец, нажмите кнопку **создать эту функцию** .

    ![Выбор веб-перехватчика CSharp](images/AzureLabs-Lab5-14.png)

11. Вы должны присутствовать на кодовой странице (Run. CSX), если это не так, щелкните созданную функцию в списке функции на панели слева.

    ![открыть новую функцию](images/AzureLabs-Lab5-15.png)

12. Скопируйте следующий код в функцию. Эта функция будет просто возвращать случайное целое число от 0 до 2 при вызове. Не беспокойтесь о существующем коде, вы можете вставить его в верхнюю часть.

    ```csharp
        using System.Net;
        using System.Threading.Tasks;

        public static int Run(CustomObject req, TraceWriter log)
        {
            Random rnd = new Random();
            int randomInt = rnd.Next(0, 3);
            return randomInt;
        }

        public class CustomObject
        {
            public String name {get; set;}
        }
    ```

13. Щелкните **Сохранить**.

14. Результат должен выглядеть, как показано на рисунке ниже.

15. Щелкните **получить URL-адрес функции** и обратите внимание на отображаемую *конечную точку* . Его необходимо вставить в класс *азуресервицес* , который будет создан далее в этом курсе.

    ![Получение конечной точки функции](images/AzureLabs-Lab5-16.png)

    ![Вставить конечную точку функции](images/AzureLabs-Lab5-16-5.png)

## <a name="chapter-3---setting-up-the-unity-project"></a>Глава 3. Настройка проекта Unity

Ниже приведена типичная Настройка для разработки с использованием смешанной реальности, которая является хорошим шаблоном для других проектов.

Настройка и тестирование иммерсивного наушников смешанной реальности.

> [!NOTE]
> Для этого курса **не** потребуется использовать контроллеры движения. Если вам нужна поддержка настройки иммерсивного головного телефона, [посетите статью Настройка смешанной реальности](https://support.microsoft.com/help/4043101/windows-10-set-up-windows-mixed-reality).

1.  Откройте Unity и нажмите кнопку **создать**.

    ![Создать новый проект Unity](images/AzureLabs-Lab5-17.png)

2.  Теперь необходимо указать имя проекта Unity. Вставка **MR_Azure_Functions**. Убедитесь, что для типа проекта задано значение **3D**. Задайте для *расположения нужное расположение* (Помните, что ближе к корневым каталогам лучше). Затем нажмите кнопку **создать проект**.

    ![Присвойте имя новому проекту Unity](images/AzureLabs-Lab5-18.png)

3.  При открытом Unity стоит проверить, что для **редактора скриптов** по умолчанию задано значение **Visual Studio**. Перейдите к разделу **изменение**  >  **настроек** , а затем в новом окне перейдите к разделу **Внешние инструменты**. Измените **Редактор внешних скриптов** на **Visual Studio 2017**. Закройте окно **настройки** .

    ![Установка Visual Studio в качестве редактора скриптов](images/AzureLabs-Lab5-19.png)

4.  Затем перейдите в раздел   >  **параметры сборки** файлов и переключите платформу на **универсальная платформа Windows**, нажав кнопку **коммутатора на платформе** .

    ![Переключение платформы в UWP](images/AzureLabs-Lab5-20.png)

5.  Перейдите в раздел  >  **параметры сборки** файлов и убедитесь в том, что:

    1. **Целевое устройство** настроено для **любого устройства**.

        > Для Microsoft HoloLens задайте для параметра **целевое устройство** значение *HoloLens*.

    2. Для **типа сборки** задано значение **D3D**

    3. **Пакет SDK** установлен в значение " **Последняя установка** "

    4. Для **версии Visual Studio** установлено значение " **Последняя установка** "

    5. **Сборка и запуск** настроены на **локальный компьютер**

    6. Сохраните сцену и добавьте ее в сборку.

        1.  Для этого выберите **Добавить открытые сцены**. Появится окно сохранения.

            ![Добавление открытых сцен](images/AzureLabs-Lab5-21.png)

        2.  Создайте новую папку для этого, а также любой будущей сцены, а затем нажмите кнопку **создать папку** , чтобы создать новую папку, назовите ее « **сцены**».

            ![создать папку сцен](images/AzureLabs-Lab5-22.png)

        3.  Откройте созданную папку **сцены** , а затем в текстовом поле **имя файла** введите **функтионссцене**, а затем нажмите кнопку **сохранить**.

            ![Сохранить сцену функций](images/AzureLabs-Lab5-23.png)

6.  Оставшиеся параметры, в **параметрах сборки**, должны быть оставлены по умолчанию.

    ![Оставить параметры сборки по умолчанию](images/AzureLabs-Lab5-24.png)

7.  В окне *параметры сборки* нажмите кнопку **Параметры проигрывателя** , чтобы открыть связанную панель в пространстве, где находится *инспектор* .

    ![Параметры проигрывателя в инспекторе](images/AzureLabs-Lab5-25.png)

8.  На этой панели необходимо проверить несколько параметров:

    1.  На вкладке **другие параметры** выполните следующие действия.

        1.  **Версия среды выполнения сценариев** должна быть **экспериментальной** (эквивалент .NET 4,6), что вызовет необходимость перезапуска редактора.
        2.  **Серверная часть сценариев** должна быть **.NET**
        3.  **Уровень совместимости API** должен быть **.NET 4,6**

    2.  На вкладке **Параметры публикации** в разделе **возможности** установите флажок:
        
        -  **InternetClient**;

            ![Установка возможностей](images/AzureLabs-Lab5-26.png)

    3.  На более низких панели в **параметрах XR** (см. ниже **Параметры публикации**), **поддерживаемая виртуальная реальность** Tick, убедитесь, что добавлен **пакет SDK для Windows Mixed Reality** .

        ![задать параметры XR](images/AzureLabs-Lab5-27.png)

9.  Назад в *параметрах сборки* *проекты C# Unity* больше не заключаются; Установите флажок рядом с этим.

    ![проекты тактов c#](images/AzureLabs-Lab5-28.png)

10.  Закройте окно Build Settings (Параметры сборки).

11. Сохраните сцену и проект (**файл**  >  **сохранить сцену/файл**  >  **сохранить проект**).

## <a name="chapter-4---setup-main-camera"></a>Глава 4. Настройка основной камеры

> [!IMPORTANT]
> Если вы хотите пропустить *настройку Unity, настроили* компоненты этого курса и продолжить работу с кодом, [Скачайте этот файл. пакет unitypackage](https://github.com/Microsoft/HolographicAcademy/raw/Azure-MixedReality-Labs/Azure%20Mixed%20Reality%20Labs/MR%20and%20Azure%20305%20-%20Functions%20and%20storage/Azure-MR-305.unitypackage)и импортируйте его в проект как [пользовательский пакет](https://docs.unity3d.com/Manual/AssetPackages.html). Это также будет содержать библиотеки DLL из следующей главы. После импорта продолжите работу с [главой 7](#chapter-7---create-the-azureservices-class). 

1.  На *панели Иерархия* вы найдете объект с названием **Главная камера**, этот объект представляет "головную точку представления", когда вы "внутри приложения".

2.  На панели мониторинга Unity перед вами выберите **основную камеру GameObject**. Вы заметите, что на *панели инспектора* (как правило, на панели мониторинга) отображаются различные компоненты этого *GameObject*, с помощью кнопки *преобразовывать* в верхней части, за которой следует *Камера* и некоторые другие компоненты. Необходимо будет сбросить преобразование основной камеры, чтобы она правильно расположиться.

3.  Для этого щелкните значок **шестеренки** рядом с компонентом *преобразования* камеры и выберите **сбросить**.

    ![Сброс преобразования](images/AzureLabs-Lab5-29.png)

4.  Затем обновите компонент **преобразования** , чтобы он выглядел следующим образом:

    |         |    TRANSFORM-ПОЗИЦИОНИРОВАНИЕ   |       |
    | :-----: | :-----------------------: | :----:|
    | **X**   | **да**                     | **Z** |
    | 0       | 1                         | 0     |    

    |       | ПОВОРОТ ПРЕОБРАЗОВАНИЯ |       |
    | :---: | :------------------: | :----:|
    | **X** | **да**                | **Z** |
    | 0     | 0                    | 0     |

    |       | ПРЕОБРАЗОВАНИЕ — МАСШТАБИРОВАНИЕ |       |
    | :---: | :---------------: | :---: |
    | **X** | **да**             | **Z** |
    | 1     | 1                 | 1     |

    ![Задание преобразования камеры](images/AzureLabs-Lab5-30.png)

## <a name="chapter-5---setting-up-the-unity-scene"></a>Глава 5. Настройка сцены Unity

1.  Щелкните правой кнопкой мыши пустую область *панели Иерархия* в разделе **трехмерный объект**, добавьте **плоскость**.

    ![Создание новой плоскости](images/AzureLabs-Lab5-31.png)

2.  Выбрав объект **плоскости** , измените следующие параметры на *панели инспектора*:

    |       | TRANSFORM-ПОЗИЦИОНИРОВАНИЕ |       |
    | :---: | :------------------: | :---: |
    | **X** | **да**                | **Z** |
    | 0     | 0                    | 4     |

    |       | ПРЕОБРАЗОВАНИЕ — МАСШТАБИРОВАНИЕ |       |
    | :---: | :---------------: | :---: |
    | **X** | **да**             | **Z** |
    | 10    | 1                 | 10    |

    ![Задание расположения и масштаба плоскости](images/AzureLabs-Lab5-32.png)

    ![представление сцены плоскости](images/AzureLabs-Lab5-33.png)

3.  Щелкните правой кнопкой мыши пустую область *панели Иерархия* в разделе **трехмерный объект** и добавьте **куб**.

    1.  Переименование Куба в **газебуттон** (с выбранным кубом нажмите клавишу "F2").

    2.  Измените следующие параметры на *панели инспектора*:

        |       | TRANSFORM-ПОЗИЦИОНИРОВАНИЕ |       |
        | :---: | :------------------: |:-----:|
        | **X** | **да**                | **Z** |
        | 0     | 3                    | 5     |


        ![задать преобразование кнопки взвзгляда](images/AzureLabs-Lab5-34.png)

        ![представление сцены кнопки взгляда](images/AzureLabs-Lab5-35.png)

    3.  Щелкните раскрывающийся список **тег** и выберите **Добавить тег** , чтобы открыть *панель Теги & слои*.

        ![Добавить новый тег](images/AzureLabs-Lab5-36.png)

        ![выбрать плюс](images/AzureLabs-Lab5-37.png)

    4.  Нажмите кнопку **+ (плюс)** и в поле *новое имя тега* введите **газебуттон** и нажмите кнопку **сохранить**.

        ![имя новый тег](images/AzureLabs-Lab5-38.png)

    5.  Щелкните объект **газебуттон** на *панели Иерархия*, а затем на *панели инспектора* назначьте созданный тег **газебуттон** .

        ![назначить кнопке "взгляд" новый тег](images/AzureLabs-Lab5-39.png)

4.  Щелкните правой кнопкой мыши объект **газебуттон** на *панели Иерархия* и добавьте **пустой GameObject** (который будет добавлен в качестве *дочернего* объекта).

5.  Выберите новый объект и переименуйте его в **шапеспавнпоинт**.

    1.  Измените следующие параметры на *панели инспектора*:

        |       | TRANSFORM-ПОЗИЦИОНИРОВАНИЕ |       |
        | :---: | :------------------: |:----: |
        | **X** |**да**                 | **Z** |
        | 0     | -1                   | 0     |

        ![Обновление преобразования точки порождения фигуры](images/AzureLabs-Lab5-40.png)

        ![представление сцены создания точки порождения фигуры](images/AzureLabs-Lab5-41.png)

6.  Далее предстоит создать **трехмерный текстовый** объект, чтобы оставить отзыв о состоянии службы Azure.

    Щелкните правой кнопкой мыши **газебуттон** на панели Иерархия и добавьте трехмерный трехмерный объект  >  **3D** Object в качестве *дочернего*.

    ![создать новый объект объемного текста](images/AzureLabs-Lab5-42.png)

7.  Переименуйте **трехмерный текстовый** объект в **азурестатустекст**.

8.  Измените преобразование объекта **азурестатустекст** следующим образом:

    |       | TRANSFORM-ПОЗИЦИОНИРОВАНИЕ |       |
    | :---: | :------------------: | :---: |
    | **X** | **да**                | **Z** |
    | 0     | 0                    | –0,6  |

    |       | ПРЕОБРАЗОВАНИЕ — МАСШТАБИРОВАНИЕ |       |
    | :---: | :---------------: | :---: |
    | **X** | **да**             | **Z** |
    | 0.1   | 0.1               | 0.1   |


    > [!NOTE]
    > Не беспокойтесь, если он находится вне сети, так как это будет исправлено при обновлении компонента сетки текста.

9.  Измените компонент " **Сетка текста** " в соответствии с приведенным ниже:

    ![Настройка компонента сетки текста](images/AzureLabs-Lab5-43.png)

    > [!TIP]
    > Выбранный цвет имеет шестнадцатеричный цвет: **000000FF**, хотя вы можете выбрать собственный, просто убедитесь, что он доступен для чтения.

10. Теперь структура панели иерархии должна выглядеть следующим образом:

    ![Сетка текста в иерархии](images/AzureLabs-Lab5-43b.png)

10. Теперь сцена должна выглядеть следующим образом:

    ![Сетка текста в представлении сцены](images/AzureLabs-Lab5-44.png)


## <a name="chapter-6---import-azure-storage-for-unity"></a>Глава 6. Импорт хранилища Azure для Unity

Вы будете использовать службу хранилища Azure для Unity (которая самостоятельно использует пакет SDK для .NET для Azure). Дополнительные сведения об этом см. в [статье хранилище Azure для Unity](/sandbox/gamedev/unity/azure-storage-unity).

В Unity существует известная ошибка, которая требует перенастройки подключаемых модулей после импорта. Эти действия (4-7 в этом разделе) больше не понадобятся после устранения ошибки.

Чтобы импортировать пакет SDK в собственный проект, убедитесь, что вы скачали последнюю версию [". пакет unitypackage" из GitHub](https://aka.ms/azstorage-unitysdk). Затем сделайте следующее.

1.  Добавьте файл **. пакет unitypackage** в Unity с помощью команды   >    >  меню **настраиваемый пакет** импорт активов.

2.  В появившемся окне **Импорт пакета Unity** можно выбрать все в разделе хранилище **подключаемых модулей**  >  . Снимите флажок все остальное, так как он не требуется для этого курса.

    ![Импорт в пакет](images/AzureLabs-Lab5-45.png)

3.  Нажмите кнопку **Импорт** , чтобы добавить элементы в проект.

4.  Перейдите в папку *хранилища* *подключаемых модулей* в представлении проекта и выберите *только* следующие подключаемые модули:

    -   Microsoft.Data.Edm
    -   Microsoft.Data.OData
    -   Microsoft.WindowsAzure.Storage
    -   Newtonsoft.Json.
    -   System.Spatial

        ![снять флажок с любой платформы](images/AzureLabs-Lab5-46.png)

5.  Выбрав *нужные подключаемые модули* , **снимите флажок для** *любой платформы* и **снимите флажок** *всаплайер* , а затем нажмите кнопку **Применить**.

    ![применение библиотек DLL платформы](images/AzureLabs-Lab5-47.png)

    > [!NOTE]
    > Мы помечаем эти отдельные подключаемые модули для использования только в редакторе Unity. Это связано с тем, что в папке WSA существуют разные версии тех же подключаемых модулей, которые будут использоваться после экспорта проекта из Unity.

6.  В папке подключаемый модуль *хранилища* выберите только:

    -   Microsoft.Data.Services.Client

        ![Set не обрабатывать библиотеки DLL](images/AzureLabs-Lab5-48.png)

7.  Установите флажок **не обрабатывать** в разделе *параметры платформы* и нажмите кнопку **Применить**.

    ![не применять обработку](images/AzureLabs-Lab5-49.png)

    > [!NOTE]
    > Мы пометили этот подключаемый модуль как "не обрабатывать", так как при обработке этого подключаемого модуля в установщике сборок Unity возникли трудности. Подключаемый модуль по-прежнему будет работать, даже если он не обрабатывается.

## <a name="chapter-7---create-the-azureservices-class"></a>Глава 7. Создание класса Азуресервицес

Первый класс, который предстоит создать, является классом *азуресервицес* .

Класс *азуресервицес* будет отвечать за:

-   Хранение учетных данных учетной записи Azure.

-   Вызов функции приложения Azure.

-   Отправка и скачивание файла данных в облачном хранилище Azure.

Чтобы создать этот класс, сделайте следующее:

1.  Щелкните правой кнопкой мыши папку *Asset* , расположенную на панели проект и выберите **создать**  >  **папку**. Назовите папку **Scripts**.

    ![создать новую папку](images/AzureLabs-Lab5-50.png)

    ![Папка вызова — скрипты](images/AzureLabs-Lab5-51.png)

2.  Дважды щелкните только что созданную папку, чтобы открыть ее.

3.  Щелкните правой кнопкой мыши внутри папки и выберите **создать**  >  **скрипт C#**. Вызовите скрипт *азуресервицес*.

4.  Дважды щелкните новый класс *азуресервицес* , чтобы открыть его в *Visual Studio*.

5.  Добавьте следующие пространства имен в верхнюю часть *азуресервицес*:

    ```csharp
        using System;
        using System.Threading.Tasks;
        using UnityEngine;
        using Microsoft.WindowsAzure.Storage;
        using Microsoft.WindowsAzure.Storage.File;
        using System.IO;
        using System.Net;
    ```

6.  Добавьте следующие поля инспектора в класс *азуресервицес* :

    ```csharp
        /// <summary>
        /// Provides Singleton-like behavior to this class.
        /// </summary>
        public static AzureServices instance;

        /// <summary>
        /// Reference Target for AzureStatusText Text Mesh object
        /// </summary>
        public TextMesh azureStatusText;
    ```

7.  Затем добавьте следующие переменные члена в класс *азуресервицес* :

    ```csharp
        /// <summary>
        /// Holds the Azure Function endpoint - Insert your Azure Function
        /// Connection String here.
        /// </summary>

        private readonly string azureFunctionEndpoint = "--Insert here you AzureFunction Endpoint--";

        /// <summary>
        /// Holds the Storage Connection String - Insert your Azure Storage
        /// Connection String here.
        /// </summary>
        private readonly string storageConnectionString = "--Insert here you AzureStorage Connection String--";

        /// <summary>
        /// Name of the Cloud Share - Hosts directories.
        /// </summary>
        private const string fileShare = "fileshare";

        /// <summary>
        /// Name of a Directory within the Share
        /// </summary>
        private const string storageDirectory = "storagedirectory";

        /// <summary>
        /// The Cloud File
        /// </summary>
        private CloudFile shapeIndexCloudFile;

        /// <summary>
        /// The Linked Storage Account
        /// </summary>
        private CloudStorageAccount storageAccount;

        /// <summary>
        /// The Cloud Client
        /// </summary>
        private CloudFileClient fileClient;

        /// <summary>
        /// The Cloud Share - Hosts Directories
        /// </summary>
        private CloudFileShare share;

        /// <summary>
        /// The Directory in the share that will host the Cloud file
        /// </summary>
        private CloudFileDirectory dir;
    ```

    > [!IMPORTANT]
    > Убедитесь, что значения *конечных точек* и *строк подключения* заменены значениями из хранилища Azure, расположенными на портале Azure.

8.  Теперь необходимо добавить код для методов *"спящий" ()* и *"начало" ()* . Эти методы будут вызываться при инициализации класса:

    ```csharp
        private void Awake()
        {
            instance = this;
        }

        // Use this for initialization
        private void Start()
        {
            // Set the Status text to loading, whilst attempting connection to Azure.
            azureStatusText.text = "Loading...";
        }

        /// <summary>
        /// Call to the Azure Function App to request a Shape.
        /// </summary>
        public async void CallAzureFunctionForNextShape()
        {

        }
    ```

    > [!IMPORTANT]
    > В [следующей главе](#chapter-10---completing-the-azureservices-class)мы будем заполнять код для *каллазурефунктионфорнекстшапе ()* .

9.  Удалите метод *Update ()* , так как этот класс не будет его использовать.

10. Сохраните изменения в Visual Studio, а затем вернитесь в Unity.

11. Щелкните и перетащите класс *азуресервицес* из папки Scripts в основной объект Camera на *панели Иерархия*.

12. Выберите основную камеру, затем возьмите дочерний объект **азурестатустекст** из объекта **газебуттон** и поместите его в поле Целевой объект ссылки **азурестатустекст** в *инспекторе*, чтобы предоставить ссылку на скрипт *азуресервицес* .

    ![Назначение целевой ссылки на текст состояния Azure](images/AzureLabs-Lab5-52.png)

## <a name="chapter-8---create-the-shapefactory-class"></a>Глава 8. Создание класса Шапефактори

Следующий создаваемый скрипт является классом *шапефактори* . Роль этого класса заключается в том, чтобы создать новую фигуру при запросе и удержать историю созданных фигур в *списке журнала фигур*. Каждый раз при создании фигуры *список журнала фигур* обновляется в классе *AzureService* , а затем сохраняется в *хранилище Azure*. При запуске приложения, если сохраненный файл находится в *хранилище Azure*, *список журнала фигур* извлекается и воспроизводится с помощью объекта **3D Text** , который указывает, является ли созданная фигура из хранилища или новой.

Чтобы создать этот класс, сделайте следующее:

1.  Перейдите к созданной ранее папке **Scripts** .

2.  Щелкните правой кнопкой мыши внутри папки и выберите **создать**  >  **скрипт C#**. Вызовите скрипт *шапефактори*.

3.  Дважды щелкните новый скрипт *шапефактори* , чтобы открыть его в *Visual Studio*.

4.  Убедитесь, что класс *шапефактори* содержит следующие пространства имен:

    ```csharp
        using System.Collections.Generic;
        using UnityEngine;
    ```

5.  Добавьте указанные ниже переменные в класс *шапефактори* и замените функции *Start ()* и *спящие ()* на указанные ниже.

    ```csharp
        /// <summary>
        /// Provide this class Singleton-like behaviour
        /// </summary>
        [HideInInspector]
        public static ShapeFactory instance;

        /// <summary>
        /// Provides an Inspector exposed reference to ShapeSpawnPoint
        /// </summary>
        [SerializeField]
        public Transform spawnPoint;

        /// <summary>
        /// Shape History Index
        /// </summary>
        [HideInInspector]
        public List<int> shapeHistoryList;

        /// <summary>
        /// Shapes Enum for selecting required shape
        /// </summary>
        private enum Shapes { Cube, Sphere, Cylinder }

        private void Awake()
        {
            instance = this;
        }

        private void Start()
        {
            shapeHistoryList = new List<int>();
        }
    ```

6.  Метод *креатешапе ()* создает примитивные фигуры на основе указанного *целочисленного* параметра. Логический параметр используется для указания, является ли создаваемая в данный момент фигура из хранилища или новой. Поместите следующий код в класс *шапефактори* под предыдущими методами:

    ```csharp
        /// <summary>
        /// Use the Shape Enum to spawn a new Primitive object in the scene
        /// </summary>
        /// <param name="shape">Enumerator Number for Shape</param>
        /// <param name="storageShape">Provides whether this is new or old</param>
        internal void CreateShape(int shape, bool storageSpace)
        {
            Shapes primitive = (Shapes)shape;
            GameObject newObject = null;
            string shapeText = storageSpace == true ? "Storage: " : "New: ";

            AzureServices.instance.azureStatusText.text = string.Format("{0}{1}", shapeText, primitive.ToString());

            switch (primitive)
            {
                case Shapes.Cube:
                newObject = GameObject.CreatePrimitive(PrimitiveType.Cube);
                break;

                case Shapes.Sphere:
                newObject = GameObject.CreatePrimitive(PrimitiveType.Sphere);
                break;

                case Shapes.Cylinder:
                newObject = GameObject.CreatePrimitive(PrimitiveType.Cylinder);
                break;
            }

            if (newObject != null)
            {
                newObject.transform.position = spawnPoint.position;

                newObject.transform.localScale = new Vector3(0.5f, 0.5f, 0.5f);

                newObject.AddComponent<Rigidbody>().useGravity = true;

                newObject.GetComponent<Renderer>().material.color = UnityEngine.Random.ColorHSV(0f, 1f, 1f, 1f, 0.5f, 1f);
            }
        }
    ```

7.  Не забудьте сохранить изменения в Visual Studio перед возвратом в Unity.

8.  В редакторе Unity щелкните и перетащите класс *шапефактори* из папки **сценарии** в объект **Main** на *панели Иерархия*.

9. Выбрав основную камеру, вы увидите, что в компоненте скрипта *шапефактори* отсутствует ссылка на *точку порождения* . Чтобы устранить эту проблему, перетащите объект **шапеспавнпоинт** с *панели Иерархия* в целевой объект ссылки на **точку порождения** .

    ![задать целевую объект ссылки на фабрику фигур](images/AzureLabs-Lab5-53.png)

## <a name="chapter-9---create-the-gaze-class"></a>Глава 9. Создание класса «взгляд»

Последний скрипт, который необходимо создать, является классом « *взгляд* ».

Этот класс отвечает за создание **райкаст** , который будет проецирован вперед с основной камеры для определения объекта, на котором пользователь смотрит. В этом случае Райкаст потребуется выяснить, просматривает ли пользователь объект **газебуттон** в сцене и инициирует поведение.

Чтобы создать этот класс, сделайте следующее:

1.  Перейдите к созданной ранее папке **Scripts** .

2.  Щелкните правой кнопкой мыши на панели проект и в контекстном меню выберите команду **создать**  >  **скрипт C#**. Вызовите скрипт *взгляд*.

3.  Дважды щелкните новый скрипт " *Взгляните* ", чтобы открыть его в *Visual Studio.*

4.  Убедитесь, что в начале скрипта включено следующее пространство имен:

    ```csharp
        using UnityEngine;
    ```

5.  Затем добавьте следующие переменные в класс *Взгляните* :

    ```csharp
        /// <summary>
        /// Provides Singleton-like behavior to this class.
        /// </summary>
        public static Gaze instance;

        /// <summary>
        /// The Tag which the Gaze will use to interact with objects. Can also be set in editor.
        /// </summary>
        public string InteractibleTag = "GazeButton";

        /// <summary>
        /// The layer which will be detected by the Gaze ('~0' equals everything).
        /// </summary>
        public LayerMask LayerMask = ~0;

        /// <summary>
        /// The Max Distance the gaze should travel, if it has not hit anything.
        /// </summary>
        public float GazeMaxDistance = 300;

        /// <summary>
        /// The size of the cursor, which will be created.
        /// </summary>
        public Vector3 CursorSize = new Vector3(0.05f, 0.05f, 0.05f);

        /// <summary>
        /// The color of the cursor - can be set in editor.
        /// </summary>
        public Color CursorColour = Color.HSVToRGB(0.0223f, 0.7922f, 1.000f);

        /// <summary>
        /// Provides when the gaze is ready to start working (based upon whether
        /// Azure connects successfully).
        /// </summary>
        internal bool GazeEnabled = false;

        /// <summary>
        /// The currently focused object.
        /// </summary>
        internal GameObject FocusedObject { get; private set; }

        /// <summary>
        /// The object which was last focused on.
        /// </summary>
        internal GameObject _oldFocusedObject { get; private set; }

        /// <summary>
        /// The info taken from the last hit.
        /// </summary>
        internal RaycastHit HitInfo { get; private set; }

        /// <summary>
        /// The cursor object.
        /// </summary>
        internal GameObject Cursor { get; private set; }

        /// <summary>
        /// Provides whether the raycast has hit something.
        /// </summary>
        internal bool Hit { get; private set; }

        /// <summary>
        /// This will store the position which the ray last hit.
        /// </summary>
        internal Vector3 Position { get; private set; }

        /// <summary>
        /// This will store the normal, of the ray from its last hit.
        /// </summary>
        internal Vector3 Normal { get; private set; }

        /// <summary>
        /// The start point of the gaze ray cast.
        /// </summary>
        private Vector3 _gazeOrigin;

        /// <summary>
        /// The direction in which the gaze should be.
        /// </summary>
        private Vector3 _gazeDirection;
    ```

> [!IMPORTANT]
> Некоторые из этих переменных могут быть изменены в *редакторе*.

6.  Теперь необходимо добавить код для методов *спящего режима ()* и *Start ()* .

    ```csharp
        /// <summary>
        /// The method used after initialization of the scene, though before Start().
        /// </summary>
        private void Awake()
        {
            // Set this class to behave similar to singleton
            instance = this;
        }

        /// <summary>
        /// Start method used upon initialization.
        /// </summary>
        private void Start()
        {
            FocusedObject = null;
            Cursor = CreateCursor();
        }
    ```

7.  Добавьте следующий код, который создаст объект курсора при запуске, а также метод *Update ()* , который будет выполнять метод райкаст вместе с переключением логического газинаблед.

    ```csharp
        /// <summary>
        /// Method to create a cursor object.
        /// </summary>
        /// <returns></returns>
        private GameObject CreateCursor()
        {
            GameObject newCursor = GameObject.CreatePrimitive(PrimitiveType.Sphere);
            newCursor.SetActive(false);

            // Remove the collider, so it doesn't block raycast.
            Destroy(newCursor.GetComponent<SphereCollider>());
            newCursor.transform.localScale = CursorSize;

            newCursor.GetComponent<MeshRenderer>().material = new Material(Shader.Find("Diffuse"))
            {
                color = CursorColour
            };

            newCursor.name = "Cursor";

            newCursor.SetActive(true);

            return newCursor;
        }

        /// <summary>
        /// Called every frame
        /// </summary>
        private void Update()
        {
            if(GazeEnabled == true)
            {
                _gazeOrigin = Camera.main.transform.position;

                _gazeDirection = Camera.main.transform.forward;

                UpdateRaycast();
            }
        }
    ```

8. Затем добавьте метод *упдатерайкаст ()* , который выполнит проецирование райкаст и определит цель попадания.

    ```csharp
        private void UpdateRaycast()
        {
            // Set the old focused gameobject.
            _oldFocusedObject = FocusedObject;

            RaycastHit hitInfo;

            // Initialise Raycasting.
            Hit = Physics.Raycast(_gazeOrigin,
                _gazeDirection,
                out hitInfo,
                GazeMaxDistance, LayerMask);

            HitInfo = hitInfo;

            // Check whether raycast has hit.
            if (Hit == true)
            {
                Position = hitInfo.point;

                Normal = hitInfo.normal;

                // Check whether the hit has a collider.
                if (hitInfo.collider != null)
                {
                    // Set the focused object with what the user just looked at.
                    FocusedObject = hitInfo.collider.gameObject;
                }
                else
                {
                    // Object looked on is not valid, set focused gameobject to null.
                    FocusedObject = null;
                }
            }
            else
            {
                // No object looked upon, set focused gameobject to null.
                FocusedObject = null;

                // Provide default position for cursor.
                Position = _gazeOrigin + (_gazeDirection * GazeMaxDistance);

                // Provide a default normal.
                Normal = _gazeDirection;
            }

            // Lerp the cursor to the given position, which helps to stabilize the gaze.
            Cursor.transform.position = Vector3.Lerp(Cursor.transform.position, Position, 0.6f);

            // Check whether the previous focused object is this same 
            //    object. If so, reset the focused object.
            if (FocusedObject != _oldFocusedObject)
            {
                ResetFocusedObject();

                if (FocusedObject != null)
                {
                if (FocusedObject.CompareTag(InteractibleTag.ToString()))
                {
                        // Set the Focused object to green - success!
                        FocusedObject.GetComponent<Renderer>().material.color = Color.green;

                        // Start the Azure Function, to provide the next shape!
                        AzureServices.instance.CallAzureFunctionForNextShape();
                    }
                }
            }
        }
    ```

9. Наконец, добавьте метод *ресетфокуседобжект ()* , который будет переключать текущий цвет объектов газебуттон, указывая, создает ли он новую фигуру.

    ```csharp
        /// <summary>
        /// Reset the old focused object, stop the gaze timer, and send data if it
        /// is greater than one.
        /// </summary>
        private void ResetFocusedObject()
        {
            // Ensure the old focused object is not null.
            if (_oldFocusedObject != null)
            {
                if (_oldFocusedObject.CompareTag(InteractibleTag.ToString()))
                {
                    // Set the old focused object to red - its original state.
                    _oldFocusedObject.GetComponent<Renderer>().material.color = Color.red;
                }
            }
        }
    ```

10.  Сохраните изменения в Visual Studio перед возвратом в Unity.

11.  Щелкните и *Перетащите класс «указатель» из* папки «скрипты» в основной объект **Camera** на *панели «Иерархия»*.

## <a name="chapter-10---completing-the-azureservices-class"></a>Глава 10. Завершение работы с классом Азуресервицес

После выполнения других сценариев теперь можно *завершить* класс *азуресервицес* . Это достигается с помощью следующих средств:

1.  Добавление нового метода с именем *креатеклаудидентитясинк ()* для настройки переменных проверки подлинности, необходимых для взаимодействия с Azure.

    > Этот метод также проверяет наличие ранее сохраненного файла, содержащего список фигур.
    >
    > **Если файл найден**, он отключает пользовательский *взгляд* и активирует создание фигур в соответствии с шаблоном фигур, сохраненным в **файле хранилища Azure**. Пользователь может видеть это, так как в **сетке текста** будет отображаться "Storage" или "New" в зависимости от источника фигур.
    >
    > **Если файл не найден**, будет включен *взгляд*, позволяющий пользователю создавать фигуры при просмотре объекта **газебуттон** в сцене.

    ```csharp
        /// <summary>
        /// Create the references necessary to log into Azure
        /// </summary>
        private async void CreateCloudIdentityAsync()
        {
            // Retrieve storage account information from connection string
            storageAccount = CloudStorageAccount.Parse(storageConnectionString);

            // Create a file client for interacting with the file service.
            fileClient = storageAccount.CreateCloudFileClient();

            // Create a share for organizing files and directories within the storage account.
            share = fileClient.GetShareReference(fileShare);

            await share.CreateIfNotExistsAsync();

            // Get a reference to the root directory of the share.
            CloudFileDirectory root = share.GetRootDirectoryReference();

            // Create a directory under the root directory
            dir = root.GetDirectoryReference(storageDirectory);

            await dir.CreateIfNotExistsAsync();

            //Check if the there is a stored text file containing the list
            shapeIndexCloudFile = dir.GetFileReference("TextShapeFile");

            if (!await shapeIndexCloudFile.ExistsAsync())
            {
                // File not found, enable gaze for shapes creation
                Gaze.instance.GazeEnabled = true;

                azureStatusText.text = "No Shape\nFile!";
            }
            else
            {
                // The file has been found, disable gaze and get the list from the file
                Gaze.instance.GazeEnabled = false;

                azureStatusText.text = "Shape File\nFound!";

                await ReplicateListFromAzureAsync();
            }
        }
    ```

2.  Следующий фрагмент кода находится в методе *Start ()* ; где выполняется вызов метода *креатеклаудидентитясинк ()* . Вы можете скопировать свой текущий метод *Start ()* следующим образом:

    ```csharp
        private void Start()
        {
            // Disable TLS cert checks only while in Unity Editor (until Unity adds support for TLS)
    #if UNITY_EDITOR
            ServicePointManager.ServerCertificateValidationCallback = delegate { return true; };
    #endif

            // Set the Status text to loading, whilst attempting connection to Azure.
            azureStatusText.text = "Loading...";

            //Creating the references necessary to log into Azure and check if the Storage Directory is empty
            CreateCloudIdentityAsync();
        }
    ```

3.  Заполните код метода *каллазурефунктионфорнекстшапе ()*. Вы будете использовать ранее созданную *приложение-функция Azure* для запроса индекса фигуры. После получения новой фигуры этот метод отправит форму в класс *шапефактори* , чтобы создать новую фигуру в сцене. Используйте приведенный ниже код, чтобы завершить тело *каллазурефунктионфорнекстшапе ()*.

    ```csharp
        /// <summary>
        /// Call to the Azure Function App to request a Shape.
        /// </summary>
        public async void CallAzureFunctionForNextShape()
        {
            int azureRandomInt = 0;

            // Call Azure function
            HttpWebRequest webRequest = WebRequest.CreateHttp(azureFunctionEndpoint);

            WebResponse response = await webRequest.GetResponseAsync();

            // Read response as string
            using (Stream stream = response.GetResponseStream())
            {
                StreamReader reader = new StreamReader(stream);

                String responseString = reader.ReadToEnd();

                //parse result as integer
                Int32.TryParse(responseString, out azureRandomInt);
            }

            //add random int from Azure to the ShapeIndexList
            ShapeFactory.instance.shapeHistoryList.Add(azureRandomInt);

            ShapeFactory.instance.CreateShape(azureRandomInt, false);

            //Save to Azure storage
            await UploadListToAzureAsync();
        }
    ```

4.  Добавьте метод для создания строки путем сцепления целых чисел, хранящихся в списке журнала фигур, и сохранения их в *файле хранилища Azure*.

    ```csharp
        /// <summary>
        /// Upload the locally stored List to Azure
        /// </summary>
        private async Task UploadListToAzureAsync()
        {
            // Uploading a local file to the directory created above
            string listToString = string.Join(",", ShapeFactory.instance.shapeHistoryList.ToArray());

            await shapeIndexCloudFile.UploadTextAsync(listToString);
        }
    ```

5.  Добавьте метод для получения текста, хранящегося в файле, расположенном в *файле хранилища Azure* , и *десериализация* его в список.

6.  После завершения этого процесса метод повторно включает взгляд, чтобы пользователь мог добавить дополнительные фигуры в сцену.

    ```csharp
        ///<summary>
        /// Get the List stored in Azure and use the data retrieved to replicate 
        /// a Shape creation pattern
        ///</summary>
        private async Task ReplicateListFromAzureAsync()
        {
            string azureTextFileContent = await shapeIndexCloudFile.DownloadTextAsync();

            string[] shapes = azureTextFileContent.Split(new char[] { ',' });

            foreach (string shape in shapes)
            {
                int i;

                Int32.TryParse(shape.ToString(), out i);

                ShapeFactory.instance.shapeHistoryList.Add(i);

                ShapeFactory.instance.CreateShape(i, true);

                await Task.Delay(500);
            }

            Gaze.instance.GazeEnabled = true;

            azureStatusText.text = "Load Complete!";
        }
    ```

7.  Сохраните изменения в Visual Studio перед возвратом в Unity.

## <a name="chapter-11---build-the-uwp-solution"></a>Глава 11. Создание решения UWP

Чтобы начать процесс сборки:

1.  Перейдите в раздел  >  **параметры сборки** файлов.

    ![сборка приложения](images/AzureLabs-Lab5-54.png)

2.  Щелкните **Построить**. Unity запустит окно *проводника* , в котором необходимо создать, а затем выбрать папку для сборки приложения. Создайте эту папку сейчас и назовите ее *app* Name. Затем выберите папку *приложения* и нажмите кнопку **выбрать папку**.

3.  Unity начнет сборку проекта в папку *приложения* .

4.  После того как Unity завершит сборку (может занять некоторое время), он откроет окно *проводника* в расположении сборки (проверьте панель задач, так как она может не всегда отображаться над окнами, но будет уведомлять о добавлении нового окна).

## <a name="chapter-12---deploying-your-application"></a>Глава 12. Развертывание приложения

Чтобы развернуть приложение, выполните следующие действия.

1.  Перейдите к папке *приложения* , созданной в [последней главе](#chapter-11---build-the-uwp-solution). Вы увидите файл с именем приложения с расширением SLN, который следует дважды щелкнуть, чтобы открыть его в *Visual Studio*.

2.  На **платформе решения** выберите **x86, локальный компьютер**.

3.  В **конфигурации решения** выберите **Отладка**.

    > Для Microsoft HoloLens может быть проще установить этот параметр на *Удаленный компьютер*, чтобы вы не были подключены к компьютеру. Однако необходимо также выполнить следующие действия.
    > - Изучите **IP-адрес** HoloLens, который можно найти в **параметрах**  >  **Network & reinternet**  >  **Wi-Fi**  >  **Advanced reoptions**; IPv4 — это адрес, который следует использовать. 
    > - Убедитесь, **что включен** **режим разработчика** ; Найдено в **параметрах**  >  **Update & Security**  >  **для разработчиков**.

    ![развертывание решения](images/AzureLabs-Lab5-55.png)

4.  Перейдите в меню " **Сборка** " и щелкните " **Развернуть решение** ", чтобы загружать неопубликованные приложение на компьютере.

5.  Теперь приложение должно отобразиться в списке установленных приложений, готовых к запуску и тестированию.

## <a name="your-finished-azure-functions-and-storage-application"></a>Готовые функции Azure и приложение для хранения данных

Поздравляем, вы создали приложение смешанной реальности, которое использует функции Azure и службы хранилища Azure. Приложение сможет рисовать на сохраненных данных и предоставить действие на основе этих данных.

![окончательный конец продукта](images/AzureLabs-Lab5-00.png)

## <a name="bonus-exercises"></a>Дополнительные упражнения

### <a name="exercise-1"></a>Упражнение 1

Создайте вторую точку порождения и запишите, из какой порожденной точки был создан объект. При загрузке файла данных воспроизводите созданные фигуры из первоначально созданного расположения.

### <a name="exercise-2"></a>Упражнение 2

Создайте способ перезапуска приложения, вместо того чтобы повторно открывать его каждый раз. **Загрузка сцен** — хорошее место для начала. После этого создайте способ очистки сохраненного списка в *службе хранилища Azure*, чтобы его можно было легко сбросить из приложения.