---
title: Пакет SDK для понимания сцены
description: Узнайте, как установить и использовать пакет SDK для сцены, включая компоненты, сетки и объекты в приложениях смешанной реальности.
author: szymons
ms.author: szymons
ms.date: 12/14/2020
ms.topic: article
keywords: Основные сведения о сцене, пространственное сопоставление, Windows Mixed Reality, Unity
ms.openlocfilehash: 10cb96ffe0496a20c7244ba4c40dec097ebd4bd8
ms.sourcegitcommit: d3a3b4f13b3728cfdd4d43035c806c0791d3f2fe
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/20/2021
ms.locfileid: "98583751"
---
# <a name="scene-understanding-sdk-overview"></a>Общие сведения о пакете SDK для сцены

Понятие "сцена" преобразует неструктурированные данные датчика среды, записанные устройством смешанной реальности, и преобразует их в эффективное абстрактное представление. Пакет SDK выступает в качестве коммуникационного уровня между приложением и сцены среды выполнения. Он предназначен для имитации существующих стандартных конструкций, таких как графики трехмерных сцен для трехмерных представлений, и двумерных прямоугольников и панелей для двумерных приложений. Хотя сцены конструкций понимают, что имитирует сопоставление с конкретными платформами, в целом Сценеундерстандинг является независимым от платформы и обеспечивает взаимодействие между различными средами, которые взаимодействуют с ним. По мере того, как в сцене понимается развитие роли пакета SDK, мы видим, что новые представления и возможности по-прежнему будут доступны в единой инфраструктуре. В этом документе мы сначала предложим основные понятия, которые помогут вам ознакомиться с средой разработки и использованием, а затем предоставить более подробную документацию по конкретным классам и конструкциям.

## <a name="where-do-i-get-the-sdk"></a>Где получить пакет SDK?

Пакет SDK для Сценеундерстандинг загружается через NuGet.

[Пакет SDK для Сценеундерстандинг](https://www.nuget.org/packages/Microsoft.MixedReality.SceneUnderstanding/)

**Примечание.** последний выпуск зависит от предварительных версий пакетов, и для его просмотра необходимо включить пакеты предварительной версии.

Для версии 0.5.2022-RC и более поздних версий сцены понимает поддержку языковых проекций для C# и C++, позволяя приложениям разрабатывать приложения для платформ Win32 или UWP. Начиная с этой версии, Сценеундерстандинг поддерживает поддержку Unity в редакторе, позволяя отменять Сценеобсервер, который используется исключительно для взаимодействия с HoloLens2. 

Для Сценеундерстандинг требуется Windows SDK версии 18362 или более поздней. 

Если вы используете пакет SDK в проекте Unity, используйте [NuGet для Unity](https://github.com/GlitchEnzo/NuGetForUnity) , чтобы установить пакет в проект.

## <a name="conceptual-overview"></a>Общие сведения об основных понятиях

### <a name="the-scene"></a>Сцена

Устройство Mixed Reality постоянно интегрирует информацию о том, что она видит в вашей среде. При понимании сцены создаются все эти источники данных и создается одна единая абстракция. Понятие сцены создает сцены, представляющие собой композицию [сценеобжектс](scene-understanding-SDK.md#sceneobjects) , которая представляет экземпляр одной вещи (например, стены, потолка или этажа). Сами объекты сцены представляют собой композицию [Сценекомпонентс, представляющую более детализированные элементы, составляющие этот Сценеобжект. Примерами компонентов являются четыре и сетчатые сети, но в будущем они могут представлять ограничивающие рамки, конфликты сеток, метаданные и т. д.

Процесс преобразования необработанных данных датчика в сцену является потенциально дорогостоящей операцией, которая может занять секунды для средних пробелов (~ 10x10m) в минутах для больших пробелов (~ 50x50m) и, следовательно, не будет вычисляться устройством без запроса приложения. Вместо этого создание сцены активируется вашим приложением по запросу. Класс Сценеобсервер содержит статические методы, которые могут вычислять или десериализовать сцену, которые затем можно перечислить или взаимодействовать с. Действие "вычисление" выполняется по требованию и выполняется в ЦП, но в отдельном процессе (драйвер Mixed Reality). Однако, пока мы выполняем вычисление в другом процессе, полученные данные сцены сохраняются и обслуживаются в приложении в объекте сцены. 

Ниже приведена схема, на которой показан этот поток процесса, и приведены примеры двух приложений, взаимодействующих с сценой выполнения. 

![Схема процесса](images/SU-ProcessFlow.png)

В левой части находится схема среды выполнения Mixed Reality, которая всегда включена и выполняется в собственном процессе. Эта среда выполнения отвечает за выполнение отслеживания устройств, пространственное сопоставление и другие операции, которые используются в сцене для понимания и причины вокруг всего мира. В правой части схемы показаны два теоретических приложения, которые используют понимание сцены. Первое приложение взаимодействует с МРТК, которое использует для внутренних целей пакет SDK, второе приложение выполняет вычисление и использует два отдельных экземпляра сцены. Все три сцены на этой схеме создают отдельные экземпляры сцен, драйвер не отслеживает глобальное состояние, которое совместно используется приложениями, а объекты сцены в одной сцене не находятся в другой. Понятие "сцена" обеспечивает механизм для мониторинга со временем, но это делается с помощью пакета SDK. Код отслеживания уже выполняется в пакете SDK в процессе приложения.

Поскольку каждый монтажный кадр хранит данные в памяти приложения, можно предположить, что все функции объекта сцены или внутренние данные всегда выполняются в процессе приложения.

### <a name="layout"></a>Layout

Для работы с представлением сцены может быть полезно знать и понять, как среда выполнения представляет компоненты логически и физически. Сцена представляет данные с определенным макетом, который был выбран для простоты при сохранении базовой структуры, плиабле в соответствии с будущими требованиями, не требуя значительных изменений. Сцена делает это, сохраняя все компоненты (стандартные блоки для всех объектов сцены) в плоском списке и определяя иерархию и композицию с помощью ссылок, где определенные компоненты ссылаются на другие.

Ниже представлен пример структуры как в плоской, так и в логической форме.

<table>
<tr><th>Логический макет</th><th>Физический макет</th></tr>
<tr>
<td>
<ul>
  Сцена
  <ul>
  <li>SceneObject_1
    <ul>
      <li>SceneMesh_1</li>
      <li>SceneQuad_1</li>
      <li>SceneQuad_2</li>
    </ul>
  </li>
  <li>SceneObject_2
    <ul>
      <li>SceneQuad_1</li>
      <li>SceneQuad_3</li>
      </li></ul>
  </li>
  <li>SceneObject_3
    <ul>
      <li>SceneMesh_3</li>
    </ul>
  </ul>
</ul>
</td>
<td>
<ul>
  <li>SceneObject_1</li>
  <li>SceneObject_2</li>
  <li>SceneObject_3</li>
  <li>SceneQuad_1</li>
  <li>SceneQuad_2</li>
  <li>SceneQuad_3</li>
  <li>SceneMesh_1</li>
  <li>SceneMesh_2</li>
</ul>
</td>
</tr>
</table>

На этом рисунке показана разница между физическим и логическим макетом сцены. Слева мы видим иерархический макет данных, отображаемых приложением при перечислении сцены. Справа видно, что сцена состоит из 12 отдельных компонентов, доступных по отдельности. При обработке новой сцены мы предполагаем, что приложения будут логически проходить эту иерархию, однако при отслеживании обновлений сцены некоторые приложения могут заинтересовать только те компоненты, которые являются общими для двух сцен.

## <a name="api-overview"></a>Обзор API

В следующем разделе представлен общий обзор конструкций в представлении сцены. В этом разделе вы узнаете, как представлено представление сцены, а также о том, для чего используются различные компоненты. В следующем разделе приводятся конкретные примеры кода и дополнительные сведения, которые будут включены в этот обзор.

Все приведенные ниже типы находятся в `Microsoft.MixedReality.SceneUnderstanding` пространстве имен.

### <a name="scenecomponents"></a>сценекомпонентс

Теперь, когда вы понимаете логическую структуру сцен, теперь можно представить концепцию Сценекомпонентс и то, как они используются для создания иерархии. Сценекомпонентс — это наиболее детализированные декомпозиции в Сценеундерстандинг, представляющие одну основную вещь, например сетку или четырехъядерный прямоугольник. Сценекомпонентс — это вещи, которые могут обновляться независимо друг от друга и на которые могут ссылаться другие Сценекомпонентс, поэтому у них есть одно глобальное свойство с уникальным ИДЕНТИФИКАТОРом, разрешающее этот тип механизма отслеживания и создания ссылок. Идентификаторы используются для логической композиции иерархии сцены, а также для сохранения объектов (действия по обновлению одной сцены относительно другой). 

Если вы обрабатываете все недавно вычисленные сцены как отличающиеся и просто перечисляете все данные внутри него, идентификаторы в значительной степени прозрачны. Однако если вы планируете отслеживание компонентов по нескольким обновлениям, вы будете использовать идентификаторы для индексирования и поиска Сценекомпонентс между объектами сцены.

### <a name="sceneobjects"></a>сценеобжектс

Сценеобжект — это Сценекомпонент, представляющий экземпляр "вещи", например стены, этаж, потолк и т. д. выражается по свойству Kind. Сценеобжектс являются геометрическими и, следовательно, имеют функции и свойства, представляющие их расположение в пространстве, однако они не содержат геометрическую или логическую структуру. Вместо этого Сценеобжектс ссылаться на другие Сценекомпонентс, в частности Сценекуадс и Сценемешес, которые предоставляют различные представления, поддерживаемые системой. При вычислении новой сцены приложение, скорее всего, будет перечислять Сценеобжектс сцены, чтобы обработать его интерес.

Сценеобжектс может иметь одно из следующих:

<table>
<tr>
<th>сценеобжекткинд</th> <th>Описание</th>
</tr>
<tr><td>Историческая справка</td><td>Известно, что Сценеобжект <b>не</b> является одним из других распознаваемых видов объекта сцены. Этот класс не следует путать с неизвестным, где фон может не быть стенным, этажным, вытолоком и т. д. Хотя неизвестно, еще не классифицировано.</b></td></tr>
<tr><td>Брандмауэр</td><td>Физическая стенка. Предполагается, что стены являются неперемещаемыми структурами окружающей среды.</td></tr>
<tr><td>Этаж</td><td>Полs — это любые поверхности, на которых может пройти один проход. Примечание. лестница не является пол. Кроме того, обратите внимание, что в этом этаже предполагается любая неанализируемойная поверхность и, следовательно, нет явного предположений о единственном этаже. Многоуровневые структуры, пандуси и т. д. Все категории должны классифицироваться как пол.</td></tr>
<tr><td>Ceiling</td><td>Верхняя поверхность комнаты.</td></tr>
<tr><td>Платформа</td><td>Крупная плоская поверхность, на которую можно поместить голограммы. Они обычно представляют таблицы, каунтертопс и другие крупные горизонтальные поверхности.</td></tr>
<tr><td>World</td><td>Зарезервированная метка для геометрических данных, не зависящая от меток. Сетка, созданная путем установки флага обновления Енаблеворлдмеш, будет классифицироваться как мир.</td></tr>
<tr><td>Неизвестно</td><td>Этот объект сцены еще не классифицирован и ему назначен тип. Это не следует путать с фоном, так как этот объект может быть любым, система просто не поступила с достаточной классификацией.</td></tr>
</tr>
</table>

### <a name="scenemesh"></a>SceneMesh

Сценемеш — это Сценекомпонент, который приблизительно отражает геометрию произвольных геометрических объектов с помощью списка треугольников. Сценемешес используются в нескольких разных контекстах, они могут представлять компоненты структуры ячеек ватертигхт или Ворлдмеш, представляющие неограниченную сетку пространственных сопоставлений, связанную с сценой. Данные индекса и вершины, предоставляемые в каждой сетке, используют тот же привычный макет, что [и буферы вершин и индексов](/windows/win32/direct3d9/rendering-from-vertex-and-index-buffers) , которые используются для отрисовки сеток треугольников во всех современных API-интерфейсах отрисовки. В понимании сцены сетки используют 32-разрядные индексы и могут быть разбиты на фрагменты для определенных механизмов визуализации.

#### <a name="winding-order-and-coordinate-systems"></a>Порядок поворота и системы координат

Все сетки, созданные при понимании сцены, должны возвращать сетки в Right-Handedной системе координат, используя порядок поворота по часовой стрелке. 

Примечание. сборки ОС, выпущенные до. 191105, могут иметь известную ошибку, когда "мировые" сетки возвращались в Counter-Clockwise порядке обмотки, которая впоследствии была исправлена.

### <a name="scenequad"></a>сценекуад

Сценекуад — это Сценекомпонент, представляющий двумерные поверхности, занимающие трехмерный мир. Сценекуадс можно использовать аналогично ARKit Арпланеанчор или Аркоре плоскости, но они предлагают более высокоуровневые функции в виде двумерных холстов для использования в неструктурированных приложениях или дополненного UX. для четырех массивов предусмотрены двумерные API, которые делают размещение и разметку простыми в использовании, а разработка (за исключением отрисовки) с четырьмя областями должна быть более похожей на работу с плоскими холстами, чем с трехмерными сетками.

#### <a name="scenequad-shape"></a>Сценекуад, фигура

Сценекуадс определить ограниченную прямоугольную поверхность в 2D. Однако Сценекуадс представляют поверхности с произвольными и потенциально сложными фигурами (например, с помощью кольцевой таблицы). Чтобы представить сложную форму, вы можете использовать API Жетсурфацемаск, чтобы отобразить форму поверхности в буфере изображения, который вы задаете. Если Сценеобжект, у которых имеется четырехъядерный объект, также есть сетка, то треугольники сетки должны быть эквивалентны этому визуализированному изображению. они представляют реальную геометрию поверхности в виде 2D-или трехмерных координат.

## <a name="scene-understanding-sdk-details-and-reference"></a>Сцены сведения о пакете SDK и справочнике

Следующий раздел поможет вам ознакомиться с основами Сценеундерстандинг. В этом разделе приводятся основные сведения, в которых вы должны получить достаточно контекста для просмотра примеров приложений, чтобы увидеть, как Сценеундерстандинг используется глобально.

### <a name="initialization"></a>Инициализация

Первым шагом для работы с Сценеундерстандинг является получение ссылки на объект сцены в приложении. Это можно сделать одним из двух способов: сцена может вычисляться драйвером, или существующая сцена, которая была вычислена в прошлом, может быть десериализована. Последнее полезно для работы с Сценеундерстандинг во время разработки, где приложения и опыт можно быстро создавать с помощью прототипа без устройства смешанной реальности.

Сцены вычисляются с помощью Сценеобсервер. Перед созданием сцены приложение должно запросить устройство, чтобы убедиться, что оно поддерживает Сценеундерстандинг, а также запросить доступ пользователей для получения информации, которая необходима Сценеундерстандинг.

```cs
if (!SceneObserver.IsSupported())
{
    // Handle the error
}

// This call should grant the access we need.
await SceneObserver.RequestAccessAsync();
```

Если не вызывается Рекуестакцессасинк (), то Вычисление новой сцены завершится ошибкой. Далее мы вычислим новую сцену, которая находится в корне вокруг гарнитуры смешанной реальности и имеет 10-измерительный радиус.

```cs
// Create Query settings for the scene update
SceneQuerySettings querySettings;

querySettings.EnableSceneObjectQuads = true;                                       // Requests that the scene updates quads.
querySettings.EnableSceneObjectMeshes = true;                                      // Requests that the scene updates watertight mesh data.
querySettings.EnableOnlyObservedSceneObjects = false;                              // Do not explicitly turn off quad inference.
querySettings.EnableWorldMesh = true;                                              // Requests a static version of the spatial mapping mesh.
querySettings.RequestedMeshLevelOfDetail = SceneMeshLevelOfDetail.Fine;            // Requests the finest LOD of the static spatial mapping mesh.

// Initialize a new Scene
Scene myScene = SceneObserver.ComputeAsync(querySettings, 10.0f).GetAwaiter().GetResult();
```

### <a name="initialization-from-data-also-known-as-the-pc-path"></a>Инициализация из данных (также известных как. Путь к компьютеру)

В то время как сцены можно вычислять для прямого потребления, их также можно вычислить в сериализованной форме для последующего использования. Это было признано полезным для разработки, так как оно позволяет разработчикам работать и тестировать сцены без необходимости использования устройства. Процесс сериализации сцены практически идентичен его вычислению, поэтому данные возвращаются в приложение, а не десериализуется локально с помощью пакета SDK. Вы можете выполнить десериализацию самостоятельно или сохранить его для будущего использования.

```cs
// Create Query settings for the scene update
SceneQuerySettings querySettings;

// Compute a scene but serialized as a byte array
SceneBuffer newSceneBuffer = SceneObserver.ComputeSerializedAsync(querySettings, 10.0f).GetAwaiter().GetResult();

// If we want to use it immediately we can de-serialize the scene ourselves
byte[] newSceneData = new byte[newSceneBuffer.Size];
newSceneBuffer.GetData(newSceneData);
Scene mySceneDeSerialized = Scene.Deserialize(newSceneData);

// Save newSceneData for later
```

### <a name="sceneobject-enumeration"></a>Перечисление Сценеобжект

Теперь, когда приложение содержит сцену, приложение будет искать и взаимодействовать с Сценеобжектс. Это делается путем обращения к свойству **сценеобжектс** :

```cs
SceneObject firstFloor = null;

// Find the first floor object
foreach (var sceneObject in myScene.SceneObjects)
{
    if (sceneObject.Kind == SceneObjectKind.Floor)
    {
        firstFloor = sceneObject;
        break;
    }
}
```

### <a name="component-update-and-refinding-components"></a>Обновление компонентов и их поиск

Существует другая функция, которая извлекает компоненты в сцене с именем **_финдкомпонент_* _. Эта функция полезна при обновлении объектов отслеживания и их поиске в последующих сценах. Следующий код вычислит новую сцену относительно предыдущей сцены, а затем найдет этаж в новой сцене.

```cs
// Compute a new scene, and tell the system that we want to compute relative to the previous scene
Scene myNextScene = SceneObserver.ComputeAsync(querySettings, 10.0f, myScene).GetAwaiter().GetResult();

// Use the Id for the floor we found last time, and find it again
firstFloor = (SceneObject)myNextScene.FindComponent(firstFloor.Id);

if (firstFloor != null)
{
    // We found it again, we can now update the transforms of all objects we attached to this floor transform
}
```

## <a name="accessing-meshes-and-quads-from-scene-objects"></a>Доступ к сеткам и четырем из объектов сцены

После обнаружения Сценеобжектс приложение, скорее всего, захочет получить доступ к данным, содержащимся в потерях или в Объединенных в них сетках. Доступ к этим данным осуществляется с помощью свойств « _*_четыре_*_ » и « _*_сетки_*_ ». Следующий код будет перечислять все четыре и сетки нашего объекта Floor.

```cs

// Get the transform for the SceneObject
System.Numerics.Matrix4x4 objectToSceneOrigin = firstFloor.GetLocationAsMatrix();

// Enumerate quads
foreach (var quad in firstFloor.Quads)
{
    // Process quads
}

// Enumerate meshes
foreach (var mesh in firstFloor.Meshes)
{
    // Process meshes
}
```

Обратите внимание, что это Сценеобжект, который имеет преобразование относительно начала сцены. Это обусловлено тем, что Сценеобжект представляет экземпляр "вещь" и размещаемые в пространстве, четыре части и сетки представляют геометрию, которая преобразуется относительно родительской. Можно использовать отдельный Сценеобжектс для ссылки на один и тот же Сценемеш или Сценекуад Сценекомпонентс, и возможно, что у Сценеобжект есть более одного Сценемеш/Сценекуад.

### <a name="dealing-with-transforms"></a>Работа с преобразованиями

Понимание сцены предоставило намеренную попытку выполнить согласование с традиционными представлениями трехмерной сцены при работе с преобразованиями. Таким образом, каждая сцена ограничена одной системой координат, похожей на наиболее распространенные трехмерные представления среды. Сценеобжектс каждый из них предоставляет свое расположение относительно этой системы координат. Если ваше приложение работает с сценами, которые дотягивают ограничение на один источник, можно привязать Сценеобжектс к Спатиаланчорс или создать несколько сцен и объединить их вместе, но для простоты предполагается, что ватертигхт сцены существуют в собственном источнике, локализованном одним NodeId, определенным в сцене. Оригинспатиалграфнодеид.

В следующем коде Unity, например, показано, как использовать восприятие Windows и API Unity для совмещения систем координат. Дополнительные сведения о получении Спатиалкурдинатесистем, которые соответствуют источнику мира Unity, см. в статьях [спатиалкурдинатесистем](//uwp/api/windows.perception.spatial.spatialcoordinatesystem) и [спатиалграфинтероппревиев](//uwp/api/windows.perception.spatial.preview.spatialgraphinteroppreview) . подробные сведения о API восприятия Windows и [собственные объекты смешанной реальности в Unity](//windows/mixed-reality/unity-xrdevice-advanced) .

```cs
private System.Numerics.Matrix4x4? GetSceneToUnityTransformAsMatrix4x4(SceneUnderstanding.Scene scene)
{

      System.Numerics.Matrix4x4? sceneToUnityTransform = System.Numerics.Matrix4x4.Identity;

      Windows.Perception.Spatial.SpatialCoordinateSystem sceneCoordinateSystem = Microsoft.Windows.Perception.Spatial.Preview.SpatialGraphInteropPreview.CreateCoordinateSystemForNode(scene.OriginSpatialGraphNodeId);
      HolograhicFrameData holoFrameData =  Marshal.PtrToStructure<HolograhicFrameData>(UnityEngine.XR.XRDevice.GetNativePtr());
      Windows.Perception.Spatial.SpatialCoordinateSystem unityCoordinateSystem = Microsoft.Windows.Perception.Spatial.SpatialCoordinateSystem.FromNativePtr(holoFrameData.ISpatialCoordinateSystemPtr);

      sceneToUnityTransform = sceneCoordinateSystem.TryGetTransformTo(unityCoordinateSystem);

      if(sceneToUnityTransform != null)
      {
          sceneToUnityTransform = ConvertRightHandedMatrix4x4ToLeftHanded(sceneToUnityTransform.Value);
      }
      else
      {
          return null;
      }

    return sceneToUnityTransform;
}
```

Каждый `SceneObject` из них имеет преобразование, которое затем применяется к этому объекту. В Unity преобразуются в правильные координаты и назначаются локальные преобразования следующим образом:

```cs
private System.Numerics.Matrix4x4 ConvertRightHandedMatrix4x4ToLeftHanded(System.Numerics.Matrix4x4 matrix)
{
    matrix.M13 = -matrix.M13;
    matrix.M23 = -matrix.M23;
    matrix.M43 = -matrix.M43;

    matrix.M31 = -matrix.M31;
    matrix.M32 = -matrix.M32;
    matrix.M34 = -matrix.M34;

    return matrix;
}

 private void SetUnityTransformFromMatrix4x4(Transform targetTransform, System.Numerics.Matrix4x4 matrix, bool updateLocalTransformOnly = false)
 {
    if(targetTransform == null)
    {
        return;
    }

    Vector3 unityTranslation;
    Quaternion unityQuat;
    Vector3 unityScale;

    System.Numerics.Vector3 vector3;
    System.Numerics.Quaternion quaternion;
    System.Numerics.Vector3 scale;

    System.Numerics.Matrix4x4.Decompose(matrix, out scale, out quaternion, out vector3);

    unityTranslation = new Vector3(vector3.X, vector3.Y, vector3.Z);
    unityQuat        = new Quaternion(quaternion.X, quaternion.Y, quaternion.Z, quaternion.W);
    unityScale       = new Vector3(scale.X, scale.Y, scale.Z);

    if(updateLocalTransformOnly)
    {
        targetTransform.localPosition = unityTranslation;
        targetTransform.localRotation = unityQuat;
    }
    else
    {
        targetTransform.SetPositionAndRotation(unityTranslation, unityQuat);
    }
}

// Assume we have an SU object called suObject and a unity equivalent unityObject

System.Numerics.Matrix4x4 converted4x4LocationMatrix = ConvertRightHandedMatrix4x4ToLeftHanded(suObject.GetLocationAsMatrix());
SetUnityTransformFromMatrix4x4(unityObject.transform, converted4x4LocationMatrix, true);
        
```

### <a name="quad"></a>Четырехъядерный

Четыре из них были разработаны для упрощения сценариев размещения и должны рассматриваться как расширения для элементов UX в двумерных холстах. Хотя четыре компонента являются компонентами Сценеобжектс и могут быть визуализированы в трехмерном виде, четыре интерфейса API предполагают, что четыре структуры являются 2D-структурами. Они предлагают такие сведения, как экстент, форма и предоставление API для размещения.

Четыре имеют прямоугольные экстенты, но они представляют собой произвольные геоповерхности. Чтобы включить размещение на этих 2D-поверхностях, взаимодействующих с четырьмя трехмерными средами, можно использовать служебные программы для обеспечения этого взаимодействия. В настоящее время понятие сцены предоставляет две такие функции: _ *финдцентермостплацемент** и **жетсурфацемаск**. Финдцентермостплацемент — это высокоуровневый API-интерфейс, который определяет положение, в котором можно поместить объект, и пытается найти лучшее место для объекта, гарантируя, что ограничивающий прямоугольник будет оставаться на базовой поверхности.

> [!NOTE]
> Координаты выходных данных задаются относительно четырех в ««Quad» места с верхним левым углом (x = 0, y = 0), точно так же, как и с другими типами Rect Windows. Не забудьте принять это в учетную запись при работе с источниками собственных объектов. 

В следующем примере показано, как найти центермост место и привязать голограмму к четырем.

```cs
// This code assumes you already have a "Root" object that attaches the Scene's Origin.

// Find the first quad
foreach (var sceneObject in myScene.SceneObjects)
{
    // Find a wall
    if (sceneObject.Kind == SceneObjectKind.Wall)
    {
        // Get the quad
        var quads = sceneObject.Quads;
        if (quads.Count > 0)
        {
            // Find a good location for a 1mx1m object  
            System.Numerics.Vector2 location;
            if (quads[0].FindCentermostPlacement(new System.Numerics.Vector2(1.0f, 1.0f), out location))
            {
                // We found one, anchor something to the transform
                // Step 1: Create a new game object for the quad itself as a child of the scene root
                // Step 2: Set the local transform from quads[0].Position and quads[0].Orientation
                // Step 3: Create your hologram and set it as a child of the quad's game object
                // Step 4: Set the hologram's local transform to a translation (location.x, location.y, 0)
            }
        }
    }
}
```

Шаги 1-4 сильно зависят от конкретной платформы или реализации, но темы должны быть похожи. Важно отметить, что четыре просто представляют ограниченную двухмерную плоскость, локализованную в пространстве. Если ваш модуль или платформа знает, где четыре – и в корне объекты находятся относительно четырех, то голограммы будут правильно располагаться в соответствии с реальным миром. 

<!-- 
// TODO: Add sample link when released
For more detailed information please see our samples on quads which show specific implementations.
-->

### <a name="mesh"></a>Сетка

Сетки представляют геометрические представления объектов или сред. Подобно [пространственному сопоставлению](../../design/spatial-mapping.md), индекс сетки и данные вершин, предоставляемые каждой сетке пространственных областей, используют тот же привычный макет, что и буферы вершин и индексов, которые используются для отрисовки сеток треугольников во всех современных API-интерфейсах отрисовки. Позиции вершин предоставляются в системе координат `Scene` . Ниже перечислены конкретные API-интерфейсы, используемые для ссылки на эти данные.

```cs
void GetTriangleIndices(int[] indices);
void GetVertices(System.Numerics.Vector3[] vertices);
```

В следующем коде приведен пример создания списка треугольников из структуры сетки.

```cs
uint[] indices = new uint[mesh.TriangleIndexCount];
System.Numerics.Vector3[] positions = new System.Numerics.Vector3[mesh.VertexCount];

mesh.GetTriangleIndices(indices);
mesh.GetVertexPositions(positions);
```

Буферы индексов и вершин должны быть >= число индексов или вершин, но в противном случае можно произвольно изменять размер, допуская эффективное повторное использование памяти.

### <a name="collidermesh"></a>коллидермеш

Объекты сцены обеспечивают доступ к сетке и данным в виде сетки через сетки и свойства Коллидермешес. Эти сетки всегда будут соответствовать друг другу, то есть индекс и'с свойства "сетки" представляет ту же геометрию, что и индекс и'с свойства Коллидермешес. Если среда выполнения или объект поддерживает сетчатые конфликты, гарантированно получается наименьший многоугольник, приближение с наибольшим порядковым номером, и рекомендуется использовать Коллидермешес везде, где приложение будет использовать конфликты. Если система не поддерживает конфликты, объект сетки, возвращаемый в Коллидермешес, будет таким же, как и сетка, уменьшающая ограничения памяти.

## <a name="developing-with-scene-understanding"></a>Общие сведения о разработке с использованием сцены

На этом этапе вы должны понимать основные строительные блоки сцены, посвященные среде выполнения и пакету SDK. Многие возможности и сложность основаны на шаблонах доступа, взаимодействии с трехмерными платформами и средствах, которые могут быть написаны поверх этих API для выполнения более сложных задач, таких как пространственное планирование, анализ комнаты, навигация, физика и т. д. Мы надеемся, что они записываются в примеры, которые будут надеяться вам в правильном направлении. Если есть примеры или сценарии, которые мы не будем адресовать, сообщите нам, и мы попытаемся попытаться документировать или обменять нужные объекты.

### <a name="where-can-i-get-sample-code"></a>Где можно получить пример кода?

Пример кода для Unity, посвященный примеру, можно найти на странице [образца страницы Unity](https://github.com/sceneunderstanding-microsoft/unitysample) . Это приложение позволит вам взаимодействовать с устройством и визуализировать различные объекты сцены, или же оно позволит загрузить сериализованный монтажный кадр на ПК и позволит вам работать с сценами без устройства.

### <a name="where-can-i-get-sample-scenes"></a>Где можно получить образцы сцен?

Если у вас есть HoloLens2, можно сохранить любую сцену, которая была захвачена, сохранив выходные данные Компутесериализедасинк в файл и десериализовать ее в удобном для вас виде. 

Если у вас нет устройства HoloLens2, но вы хотите играть со сведениями о сцене, вам потребуется скачать предварительно сохраненную сцену. В настоящее время пример использования сцены поставляются с серийными монтажными кадрами, которые можно скачать и использовать для удобства. Их можно найти здесь:

[Пример сцен для понимания сцены](https://github.com/microsoft/MixedReality-SceneUnderstanding-Samples/tree/master/Assets/Resources/SerializedScenesForPCPath)

## <a name="see-also"></a>См. также статью

* [Пространственное сопоставление](../../design/spatial-mapping.md)
* [Интерпретация сцены](../../design/scene-understanding.md)
* [Пример Unity](https://github.com/microsoft/MixedReality-SceneUnderstanding-Samples)