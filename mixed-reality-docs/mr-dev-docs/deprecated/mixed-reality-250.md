---
title: MR-и впечатляющие головные телефоны с высокой доступностью 250
description: Выполните приведенное ниже пошаговое руководство по программированию с помощью Unity, Visual Studio, HoloLens и головных телефонов Windows Mixed Reality, чтобы получить сведения об общем доступе к голограммам между устройствами смешанной реальности.
author: keveleigh
ms.author: kurtie
ms.date: 10/22/2019
ms.topic: article
keywords: холотулкит, микседреалититулкит, микседреалититулкит-Unity, иммерсивное, контроллер движения, совместное использование, контроллер Xbox, сеть, перекрестное устройство
ms.openlocfilehash: 8b6711ab3ee833306742fe938dfa501dc5b4ed0e
ms.sourcegitcommit: d3a3b4f13b3728cfdd4d43035c806c0791d3f2fe
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/20/2021
ms.locfileid: "98580121"
---
# <a name="mr-sharing-250-hololens-and-immersive-headsets"></a>250. Общий доступ в смешанной реальности: HoloLens и иммерсивные гарнитуры

>[!NOTE]
>Руководства Mixed Reality Academy были разработаны для иммерсивных гарнитур HoloLens (1-го поколения) и иммерсивных гарнитур Mixed Reality.  Поэтому мы считаем, что важно оставить эти руководства для разработчиков, которые ищут рекомендации по разработке для этих устройств.  Данные руководства **_не_** будут обновляться с учетом последних наборов инструментов или возможностей взаимодействия для HoloLens 2.  Они будут сохранены для работы на поддерживаемых устройствах. Опубликован [новый цикл руководств](../develop/unity/tutorials/mr-learning-base-01.md) для HoloLens 2.

Благодаря гибкости универсальная платформа Windows (UWP) легко создать приложение, охватывающее несколько устройств. Благодаря этой гибкости мы можем создавать возможности, использующие сильные стороны каждого устройства. В этом учебнике рассматривается базовый общий интерфейс, который работает на впечатляющих головных и HoloLens и Windows Mixed Reality. Это содержимое изначально было доставлено на конференцию Microsoft Build 2017 в Сиэтле, штат Вашингтон.

**В этом учебнике мы выполним следующее:**

* Настройка сети с помощью УНЕТ.
* Делитесь голограммами на устройствах смешанной реальности.
* Установите другое представление приложения в зависимости от того, какое устройство смешанной реальности используется.
* Создавайте общие возможности, когда пользователи HoloLens изменяют впечатляющие гарнитуры с помощью простых головоломок.

## <a name="device-support"></a>Поддержка устройств

<table>
<tr>
<th>Курс</th><th style="width:150px"> <a href="/hololens/hololens1-hardware">HoloLens</a></th><th style="width:150px"> <a href="../discover/immersive-headset-hardware-details.md">Иммерсивные гарнитуры</a></th>
</tr><tr>
<td>250. Общий доступ в смешанной реальности: HoloLens и иммерсивные гарнитуры</td><td style="text-align: center;"> ✔️</td><td style="text-align: center;"> ✔️</td>
</tr>
</table>

## <a name="before-you-start"></a>Прежде чем начать

### <a name="prerequisites"></a>Предварительные условия

* КОМПЬЮТЕР под управлением Windows 10 с [необходимыми средствами разработки](../develop/install-the-tools.md) и [настроенным для поддержки впечатляющих головных телефонов Windows Mixed Reality](/windows/mixed-reality/enthusiast-guide/windows-mixed-reality-minimum-pc-hardware-compatibility-guidelines).
* Контроллер Xbox, работающий с вашим ПК.
* По крайней мере одно устройство HoloLens и одна иммерсивное гарнитура.
* Сеть, допускающая широковещательную передачу по протоколу UDP для обнаружения.

### <a name="project-files"></a>Файлы проекта

* Скачайте [файлы](https://github.com/Microsoft/MixedReality250/archive/master.zip) , необходимые для проекта. Извлеките файлы в легко запоминающееся место.
* Для этого проекта требуется [рекомендуемая версия Unity с поддержкой Windows Mixed Reality](../develop/install-the-tools.md).

>[!NOTE]
>Если вы хотите просмотреть исходный код перед загрузкой, он [доступен на сайте GitHub](https://github.com/Microsoft/MixedReality250).

## <a name="chapter-1---holo-world"></a>Глава 1 — Холо World

>[!VIDEO https://www.youtube.com/embed/IC0rp6rLiEc]

### <a name="objectives"></a>Задачи

Убедитесь, что среда разработки готова к работе с простым проектом.

### <a name="what-we-will-build"></a>Что будет построено

Приложение, которое показывает голограмму на HoloLens или на иммерсивное гарнитуру Windows Mixed Reality.

### <a name="steps"></a>Шаги

* Откройте Unity.
    * Выберите **Open** (Открыть).
    * Перейдите к папке, в которую вы извлекли файлы проекта.
    * Щелкните элемент **Выбор папки**.
    * *В то время как Unity будет в первый раз обрабатывать проект, это займет немного времени.*
* Убедитесь, что Смешанная реальность включена в Unity.
    * Откройте диалоговое окно "параметры сборки" (**Control + Shift + B** или **файл > параметры сборки...**).
    * Выберите **универсальная платформа Windows** а затем выберите **параметр платформа**.
    * Выберите **изменить>параметры проигрывателя**.
    * На панели **инспектора** с правой стороны разверните узел **Параметры XR**.
    * Установите флажок **поддерживается виртуальная реальность** .
    * *Windows Mixed Reality должна быть пакетом SDK виртуальной реальности.*
* Создайте сцену.
    * В **иерархии** щелкните правой кнопкой мыши **Главная камера** и выберите **Удалить**.
    * Из **холотулкит > входные > Prefabs** перетащите **микседреалитикамерапарент** в **иерархию**.
* Добавление голограмм в сцену
    * Из **апппрефабс** перетащите **Скибокс** в **представление сцены**.
    * Из **апппрефабс** перетащите **Диспетчеры** в **иерархию**.
    * Из  области апппрефабс **перетащите область** в **иерархию**.
* Сохранить и собрать
    * Сохраните (либо **Control + S** , либо **Файловая > сохранить сцену**)
    * Так как это новая сцена, ее необходимо присвоить имя. Имя не имеет значения, но мы используем Шаредмикседреалити.
* Экспорт в Visual Studio
    * Откройте меню Сборка (**Control + Shift + B** или **файл > параметры сборки**).
    * Нажмите кнопку **Добавить открытые сцены.**
    * Проверка **проектов C# для Unity**
    * Щелкните **Построить**.
    * В открывшемся окне проводника создайте новую папку с именем **app**.
    * Щелкните папку **приложения** одним щелчком мыши.
    * Нажмите кнопку **выбрать папку.**
    * **Дождитесь завершения сборки**
    * В открывшемся окне проводника перейдите в папку **приложения** .
    * Дважды щелкните **шаредмикседреалити. sln** , чтобы запустить Visual Studio
* Сборка из Visual Studio
    * Использование верхней панели инструментов изменяет целевой объект на **выпуск** и **x86**.
    * Щелкните стрелку рядом с пунктом **локальный компьютер** и выберите **устройство** для развертывания в HoloLens.
    * Щелкните стрелку рядом с полем **устройство** и выберите **локальный компьютер** для развертывания на гарнитуре Mixed Reality.
    * Щелкните **Отладка->начать без отладки** или **Control + F5** , чтобы запустить приложение.

### <a name="digging-into-the-code"></a>Продвигаясь вглубь в код

На панели проект перейдите к **ассетс\холотулкит\инпут\скриптс\утилитиес** и дважды щелкните **MixedRealityCameraManager.CS** , чтобы открыть его.

**Обзор:** MixedRealityCameraManager.cs — это простой сценарий, который корректирует уровень качества и параметры фона на основе устройства. Здесь следует ключевое поле Холографиксеттингс. Исдисплайопакуе, которое позволяет сценарию определить, является ли устройство HoloLens (Исдисплайопакуе возвращает false) или иммерсивное гарнитура (Исдисплайопакуе возвращает true).

### <a name="enjoy-your-progress"></a>Наслаждайтесь ходом выполнения

На этом этапе приложение будет просто визуализировать голограмму. Позже мы добавим взаимодействие к голограмме. Оба устройства будут отображать голограмму одинаково. На иммерсивное головной телефон также будет отображаться фон синего и облака.

## <a name="chapter-2---interaction"></a>Глава 2 — взаимодействие

>[!VIDEO https://www.youtube.com/embed/Lrb1y4sQRvI]

### <a name="objectives"></a>Задачи

Показывает, как обрабатывать входные данные для приложения Windows Mixed Reality.

### <a name="what-we-will-build"></a>Что будет построено

Основываясь на приложении из раздела 1, мы добавим функции, позволяющие пользователю выбрать голограмму и разместить ее на реальной поверхности в HoloLens или в виртуальной таблице на современном гарнитуре.

**Обновитель ввода:** В HoloLens жест выбора — это **касание воздуха**. На впечатляющих гарнитурах мы будем **использовать кнопку на** контроллере Xbox. Дополнительные сведения см. в [обзоре модели взаимодействия](../design/interaction-fundamentals.md).

### <a name="steps"></a>Шаги

* Добавление диспетчера ввода
    * Из **холотулкит > входные > Prefabs** перетащите **InputManager** в **иерархию** как дочерний элемент **руководителей**.
    * Из **холотулкит > входные > Prefabs > курсор** перетащите **курсор** в **иерархию**.
* Добавить пространственное сопоставление
    * Из **холотулкит > спатиалмаппинг > Prefabs** перетащите **спатиалмаппинг** в **иерархию**.
* Добавить виртуальный Плайспаце
    * В **иерархии** разверните узел **микседреалитикамерапарент** SELECT **граница**
    * На панели **инспектора** установите флажок, чтобы включить **границу** .
    * Из **апппрефабс** перетащите **вррум** в **иерархию**.
* Добавить Ворлданчорманажер
    * В **иерархии** выберите **Диспетчеры**.
    * В **инспекторе** щелкните **Добавить компонент**.
    * Введите **Диспетчер привязок мира**.
    * Выберите **Диспетчер универсальных опорных точек** , чтобы добавить его.
* Добавление Таптоплаце к острову
    * В **иерархии** разверните узел **остров**.
    * Выберите **микседреалитиланд**.
    * В **инспекторе** щелкните **Добавить компонент**.
    * Введите **коснитесь, чтобы поместить** и выбрать его.
    * Установите флажок " **родительский элемент" для TAP**.
    * Задайте для **смещения размещения** значение **(0, 0,1, 0)**.
* Сохранить и построить как прежде

### <a name="digging-into-the-code"></a>Продвигаясь вглубь в код

**Сценарий 1 — GamepadInput.cs**

На панели проект перейдите к **ассетс\холотулкит\инпут\скриптс\инпутсаурцес** и дважды щелкните **GamepadInput.CS** , чтобы открыть его. В том же пути на панели проекта также дважды щелкните **InteractionSourceInputSource.CS**.

Обратите внимание, что оба скрипта имеют общий базовый класс Басеинпутсаурце.

Басеинпутсаурце хранит ссылку на InputManager, что позволяет сценарию запускать события. В этом случае событие Инпуткликкед является существенным. Это важно помнить при получении сценария 2, Таптоплаце. В случае с Гамепадинпут мы будем опрашивать кнопку на контроллере, который нужно нажать, а затем вызовут событие Инпуткликкед. В случае с Интерактионсаурцеинпутсаурце мы создаем событие Инпуткликкед в ответ на Таппедевент.

**Сценарий 2 — TapToPlace.cs**

На панели проект перейдите к **ассетс\холотулкит\спатиалмаппинг\скриптс** и дважды щелкните **TapToPlace.CS** , чтобы открыть его.

Первое, что многие разработчики хотят реализовать при создании приложения holographic, — это перемещение голограмм с вводом жестов. Таким образом, мы предоставили тщательное комментирование этого сценария. Для этого руководства стоит выделить несколько моментов.

Во первых, обратите внимание, что Таптоплаце реализует Иинпуткликкхандлер. Иинпуткликкхандлер предоставляет функции, обрабатывающие событие Инпуткликкед, вызванное GamePadInput.cs или InteractionSourceInputSource.cs. Онинпуткликкед вызывается, когда Басеинпутсаурце обнаруживает щелчок, пока объект с Таптоплаце находится в фокусе. Аиртаппинг в HoloLens или нажатии кнопки на контроллере Xbox вызовет событие.

Во-вторых, код выполняется в обновлении, чтобы определить, выполняется ли поиск по поверхности, чтобы можно было поместить игровой объект на поверхность, например таблицу. У увлекательной гарнитуры нет концепции реальных поверхностей, поэтому объект, представляющий верхнюю таблицу (Врум > Таблесинги > Кубу), был помечен с помощью Спатиалмаппинг физика, поэтому приведение лучей в Update будет конфликтовать с виртуальной таблицей сверху.

### <a name="enjoy-your-progress"></a>Наслаждайтесь ходом выполнения

На этот раз можно выбрать остров, чтобы переместить его. В HoloLens можно переместить остров в реальную поверхность. В поувлекательной гарнитуре можно переместить остров в виртуальную таблицу, которую мы добавили.

## <a name="chapter-3---sharing"></a>Глава 3. Совместное использование

>[!VIDEO https://www.youtube.com/embed/1diycJvxfDc]

### <a name="objectives"></a>Задачи

Убедитесь, что сеть настроена правильно и подробные сведения о том, как пространственные привязки являются общими для устройств.

### <a name="what-we-will-build"></a>Что будет построено

Наш проект будет преобразован в проект с несколькими проектами. Мы добавим пользовательский интерфейс и логику для размещения сеансов или подключения к ним. Пользователи HoloLens будут видеть друг друга в сеансе с облаками в своих головах, а у впечатляющих головных пользователей есть облака, расположенные рядом с точкой привязки. Пользователи в иммерсивное гарнитуры увидят пользователей HoloLens по отношению к источнику сцены. Пользователи HoloLens будут видеть голограмму острова в том же месте. Ключевое замечание заключается в том, что пользователи в впечатляющих головных гарнитурах не будут включены в эту главу, но будут вести себя точно так же, как HoloLens, с птицм глазным представлением острова.

### <a name="steps"></a>Шаги

* Удаление островка и Вррум
    * В **иерархии** щелкните элемент **остров** правой кнопкой мыши, выберите пункт **Удалить** .
    * В **иерархии** щелкните правой кнопкой мыши **вррум** выбрать **Удалить** .
* Добавить Усланд
    * Из **апппрефабс** перетащите **усланд** в **иерархию**.
* Из **апппрефабс** перетащите каждую из следующих элементов в **иерархию**:
    * **унетшарингстаже**
    * **унетанчоррут**
    * **уиконтаинер**
    * **дебугпанелбуттон**
* Сохранить и построить как прежде

### <a name="digging-into-the-code"></a>Продвигаясь вглубь в код

На панели проект перейдите к **ассетс\апппрефабс\суппорт\шарингвисунет\скриптс** и дважды щелкните **UnetAnchorManager.CS**. Способность одного HoloLens обмениваться данными отслеживания с другим HoloLens, таким, что оба устройства могут совместно использовать одно и то же пространство, приближается к Magical. Мощь смешанной реальности вступает в активность, когда два или более пользователей могут совместно работать с одними и теми же цифровыми данными.

Вот несколько моментов, которые необходимо указать в этом сценарии:

В функции start Обратите внимание на проверку **исдисплайопакуе**. В этом случае предполагается, что привязка установлена. Это обусловлено тем, что в впечатляющих головных гарнитурах не предоставляется способ импорта или экспорта привязок. Однако если мы выполняем на HoloLens, этот скрипт реализует совместное использование привязок между устройствами. Устройство, запускающее сеанс, создаст привязку для экспорта. Устройство, которое присоединяется к сеансу, запрашивает привязку с устройства, запустившего сеанс.

**Идет**

Когда пользователь создает сеанс, Нетворкдисковеривисанчорс будет вызывать функцию Унетанчорманажерс Креатеанчор. Рассмотрим Креатеанчор Flow.

Начнем с определенного обслуживания, удалив все данные, которые могли быть собраны для предыдущих привязок. Затем проверяется наличие кэшированной привязки для загрузки. Данные привязки имеют значение от 5 до 20 МБ, поэтому повторное использование кэшированных привязок может сэкономить на объеме данных, необходимых для передачи по сети. Мы посмотрим, как это работает чуть позже. Даже если мы повторно используем привязку, необходимо подготовить данные привязки в случае, если новое соединение с клиентом не имеет привязки.

Говоря о готовности данных привязки, класс Ворлданчортрансфербатч предоставляет функциональные возможности для подготовки данных привязки для отправки на другое устройство или приложение, а также функции для импорта данных привязки. Так как мы используем путь экспорта, мы добавим привязку к Ворлданчортрансфербатч и вызываю функцию Експортасинк. Затем Експортасинк вызывает обратный вызов Вритебуффер при формировании данных для экспорта. Когда все данные экспортированы, Експорткомплете будут вызываться. В Вритебуффер мы добавляем фрагмент данных в список, который мы храним для экспорта. В Експорткомплете мы преобразуем список в массив. Также задается переменная Анчорнаме, которая запускает другие устройства для запроса привязки, если они у них нет.

В некоторых случаях привязка не будет экспортироваться или создаст небольшую часть данных, которую мы попробуем снова. Здесь мы просто вызываем Креатеанчор.

Завершающей функцией в пути экспорта является Анчорфаундремотели. Когда другое устройство находит привязку, это устройство будет сообщать узлу, и узел будет использовать его в качестве сигнала о том, что привязка является хорошей привязкой и может быть кэширована.

**Падут**

Когда HoloLens присоединяется к сеансу, ему необходимо импортировать привязку. В функции Update Унетанчорманажер запрос Анчорнаме. При изменении имени привязки начинается процесс импорта. Сначала мы пытаемся загрузить привязку с указанным именем из локального хранилища привязки. Если у нас уже есть, мы можем использовать его, не загружая данные повторно. Если у нас нет, мы вызываем Ваитфоранчор, который начнет загрузку.

По завершении загрузки вызывается NetworkTransmitter_dataReadyEvent. Это подаст циклу обновления вызов Импортасинк с загруженными данными. Импортасинк будет вызывать Импорткомплете по завершении процесса импорта. Если импорт выполнен успешно, привязка будет сохранена в локальном хранилище проигрывателя. PlayerController.cs фактически вызывает Анчорфаундремотели, чтобы сообщить узлу о том, что установлена хорошая привязка.

### <a name="enjoy-your-progress"></a>Наслаждайтесь ходом выполнения

На этот раз пользователь с HoloLens будет размещать сеанс с помощью кнопки **запустить сеанс** в пользовательском интерфейсе. Другие пользователи, как в HoloLens, так и в головной гарнитуре, будут выбирать сеанс, а затем нажать кнопку **присоединить сеанс** в пользовательском интерфейсе. Если у вас есть несколько пользователей с устройствами HoloLens, они будут иметь красные облака в своих головах. Также будет отображаться синий облако для каждой иммерсивного гарнитуры, но синие облака не будут выставляться над гарнитурами, так как гарнитуры не пытаются найти то же пространство координат мира, что и устройства HoloLens.

Эта точка проекта является автономным приложением для управления доступом. Это не делает ничего сложного и может стать базовым. В следующих главах мы начнем создавать интерфейс для людей. Дополнительные рекомендации по проектированию с общим опытом см. здесь.

## <a name="chapter-4---immersion-and-teleporting"></a>Глава 4 — иммерсивное и телеперенос

>[!VIDEO https://www.youtube.com/embed/kUHZ5tCOfvY]

### <a name="objectives"></a>Задачи

Применяйте интерфейс к каждому типу устройства смешанной реальности.

### <a name="what-we-will-build"></a>Что будет построено

Мы будем обновлять приложение, чтобы разместить впечатляющие пользователи гарнитуры по острову с иммерсивное представлением. Пользователи HoloLens по-прежнему будут иметь представление о острове с высоты птичьего полета. Пользователи каждого типа устройств могут видеть других пользователей по мере их появления в мире. Например, увлекательные пользователи с наушниками могут видеть другие аватары на других путях, и они видят пользователей HoloLens как гигантские облака выше. Для пользователей с головной гарнитурой также будет отображаться курсор пользователя HoloLens, если пользователь HoloLens просматривает остров. Пользователи HoloLens увидят аватар по острову, который представляет каждого иммерсивного пользователя гарнитуры.

**Обновленные данные для иммерсивного устройства:**

* Кнопки левого и правого амортизатора на контроллере Xbox поворачивают проигрыватель
* При нажатии кнопки Y на контроллере Xbox будет включен курсор [телепортируйтесь](../discover/navigating-the-windows-mixed-reality-home.md#getting-around-your-home) . Если в курсоре имеется индикатор в виде вращающейся стрелки, то при отпускании кнопки Y вы будете перенесены в расположение курсора.

### <a name="steps"></a>Шаги

* Добавление Микседреалитителепорт в Микседреалитикамерапарент
    * В списке **Иерархия** выберите **усланд**.
    * В **инспекторе** включите **Управление уровнем**.
    * В списке **Иерархия** выберите **микседреалитикамерапарент**.
    * В **инспекторе** щелкните **Добавить компонент**.
    * Введите **Смешанная реальность телепортируйтесь** и выберите ее.

### <a name="digging-into-the-code"></a>Продвигаясь вглубь в код

Впечатляющие пользователи гарнитуры будут подключены к компьютерам с помощью кабеля, но наш остров больше, чем кабель. Чтобы компенсировать, нам нужна возможность перемещать камеру независимо от движения пользователя. Дополнительные сведения о проектировании приложения смешанной реальности (в определенном самодвижении и локомотион) см. на [странице "комфортная](../design/comfort.md) ".

Чтобы описать этот процесс, полезно определить два условия. Во первых, **Долли** будет объектом, который перемещает камеру независимо от пользователя. Дочерний объект Game объекта **Долли** будет **основной камерой**. Основная камера подключена к заголовку пользователя.

На панели проект перейдите к **ассетс\апппрефабс\суппорт\скриптс\гамелогик** и дважды щелкните **MixedRealityTeleport.CS**.

Микседреалитителепорт имеет два задания. Во первых, он обрабатывает поворот с помощью амортизаторов. В функции Update мы будем опрашивать "Буттонуп" на Лефтбумпер и Ригхтбумпер. Жетбуттонуп возвращает значение true только в первом кадре после нажатия кнопки. Если одна из кнопок была вызвана, то мы понимаем, что пользователь должен повернуть.

При повороте мы провыцветание и поворачивайте с помощью простого сценария, именуемого «выцветание». Мы делаем это, чтобы пользователь не мог увидеть неестественное перемещение, что может привести к дискомфорт. Эффект затухания и исчезновения довольно прост. У нас есть черновая масть перед **основной камерой**. При переходе в альфа-значение с 0 на 1. Это постепенно приводит к тому, что черные пикселы из четырех удаляются и скрывают все, что находится за ними. При переходе в обратное значение альфа-канала возвращается к нулю.

При вычислении вращения Обратите внимание, что мы вращающим **Долли** , но вычислим поворот вокруг **основной камеры**. Это важно, так как когда **Основная камера** находится далеко от 0, 0, 0, менее точное вращение вокруг доллиа становится с точки зрения пользователя. На самом деле, если не вращается вокруг положения камеры, пользователь будет перемещаться по дуге вокруг **Долли** , а не при повороте.

Второе задание для Микседреалитителепорт заключается в обработке перемещения **Долли**. Это делается в Сетворлдпоситион. Сетворлдпоситион принимает нужную позицию мира, позицию, где пользователь хочет перЦиеве, что они покрывают. Нам нужно разместить наш **Долли** в этой позиции минус локальное расположение **основной камеры**, так как это смещение будет добавлено в каждый кадр.

Второй скрипт вызывает Сетворлдпоситион. Давайте взглянем на этот сценарий. На панели проект перейдите к **ассетс\апппрефабс\суппорт\скриптс\гамелогик** и дважды щелкните **TeleportScript.CS**.

Этот сценарий является немного более сложным, чем Микседреалитителепорт. Сценарий проверяет наличие кнопки Y на контроллере Xbox, которую необходимо удерживать. Пока кнопка удерживается, отображается курсор телепортируйтесь и сценарий приводит луч к положению пользователя. Если этот луч конфликтует с той поверхностью, которая больше или меньше направлена, поверхность будет считаться хорошей для телепортироваться к, а анимация на курсоре телепортируйтесь будет включена. Если луч не конфликтует с поверхностью, наведя на нее больше или меньше, то анимация курсора будет отключена. Когда кнопка Y выдается, а вычисленная точка луча является допустимой позицией, скрипт вызывает Сетворлдпоситион с положением, пересекающимся с лучом.

### <a name="enjoy-your-progress"></a>Наслаждайтесь ходом выполнения

На этот раз необходимо найти друга.

Опять же, пользователю с HoloLens будет размещен сеанс. Другие пользователи будут присоединяться к сеансу. Приложение поместит первых трех пользователей, чтобы присоединиться к увлекательной гарнитуре по одному из трех путей на самом острове. В этом разделе вы можете изучить остров.

Сведения для уведомления:

1. Вы видите лица в облаках, которые помогают иммерсивное пользователю видеть направление, которое ищет пользователь HoloLens.
2. Аватары на острове имеют горловины, которые поворачиваются. Они не следуют тем, что делает пользователь, в реальности (у нас нет этой информации), но она делает неприятной опыт.
3. Если пользователь HoloLens просматривает остров, то в иммерсивное пользователи могут видеть свой курсор.
4. Облака, представляющие тени, приведенные пользователем HoloLens.

## <a name="chapter-5---finale"></a>Глава 5-заключение

>[!VIDEO https://www.youtube.com/embed/n_HDWJbfpNg]

### <a name="objectives"></a>Задачи

Создайте интерактивный интерфейс совместной работы между двумя типами устройств.

### <a name="what-we-will-build"></a>Что будет построено

Основываясь на главе 4, когда пользователь с впечатляющим головным телефоном приближается к головоломке по острову, пользователи HoloLens получат всплывающую подсказку с Советом головоломки. После того, как все пользователи с головным телефоном получит свои головоломки и появятся на "готовой панели" в Rocket комнате, Rocket запустится.

### <a name="steps"></a>Шаги

* В списке **Иерархия** выберите **усланд**.
* В окне **инспектора** на панели **Управление уровнями** установите флажок **включить совместную работу**.

### <a name="digging-into-the-code"></a>Продвигаясь вглубь в код

Теперь давайте взглянем на LevelControl.cs. Этот сценарий является ядром логики игры и поддерживает состояние игры. Поскольку это многопользовательская игра, использующая УНЕТ, нам нужно понять, как потоки данных, как минимум, достаточно для изменения этого руководства. Более полный обзор УНЕТ см. в документации Unity.

На панели проект перейдите к **ассетс\апппрефабс\суппорт\скриптс\гамелогик** и дважды щелкните **LevelControl.CS**.

Давайте посмотрим, как иммерсивное гарнитура означает, что они готовы к запуску Rocket. Готовность к запуску Rocket передается путем установки одного из трех логических значений в виде списка логических значений, соответствующих трем путям по острову. Логическое значение пути задается, когда пользователь, назначенный контуру, находится поверх коричневой панели внутри Rocket комнаты. Итак, теперь с подробными сведениями.

Мы начнем с функции Update (). Обратите внимание, что имеется функция "Памятка по". Мы использовали это в разработке для тестирования последовательности запуска и сброса Rocket. Он не работает в многопользовательском интерфейсе. Надеюсь, в момент, когда вы усвоить следующую невыполненную работу, вы можете сделать это. После того, как мы пропроверяем, следует ли памятка по, мы проверяем, находится ли локальный игрок в процессе погружения. Мы хотим сосредоточиться на том, как мы нашли, что мы будем на цель. Внутри проверки if (иммерсивного) существует вызов Чеккгоал, который скрывается за логическим значением **енаблеколлаборатион** . Это соответствует флажку, установленному при выполнении шагов, описанных в этой главе. Внутри Енаблеколлаборатион мы видим вызов Чеккгоал ().

Чеккгоал выполняет некоторые математические операции, чтобы узнать, не занимается ли она на панели. Когда мы будем, отладка. log приступил к цели, а затем мы вызываем "Сендатгоалмессаже ()". В Сендатгоалмессаже мы вызываем playerController. Сендатгоал. Чтобы сэкономить время, вот код:

```cs
private void CmdSendAtGoal(int GoalIndex)
{
    levelState.SetGoalIndex(GoalIndex);
}
```

```cs
public void SendAtGoal(int GoalIndex)
{
    if (isLocalPlayer)
    {
        Debug.Log("sending at goal " + GoalIndex);
        CmdSendAtGoal(GoalIndex);
    }
}
```

Обратите внимание, что Сендатгоалмессаже вызывает Кмдсендатгоал, который вызывает Левелстате. Сетгоалиндекс, который возвращается в LevelControl.cs. На первый взгляд это кажется странным. Почему бы не просто вызвать Сетгоалиндекс, а не нестранный маршрут через контроллер проигрывателя? Причина заключается в том, что мы УНЕТ модель данных, которая использует для синхронизации данных. Чтобы предотвратить обмана и пробуксовка, УНЕТ требует, чтобы у каждого объекта был пользователь, обладающий полномочиями на изменение синхронизированных переменных. Кроме того, только узел (пользователь, запустивший сеанс) может изменять данные напрямую. Пользователи, не являющиеся узлами, но обладающие полномочиями, должны отправить команду на узел, который изменит переменную. По умолчанию узел имеет полномочия для всех объектов, за исключением того объекта, порожденного для представления пользователя. В нашем случае у этого объекта есть сценарий playercontroller. Существует способ запросить полномочия для объекта, а затем внести изменения, но мы решили использовать тот факт, что у контроллера игрока есть самостоятельный центр и маршрутизация команд через контроллер проигрывателя.

Сказал другой способ, когда мы обнаружили себя на нашей цели, игроку нужно сообщить ведущему приложению, и узел сообщит всем остальным.

Вернемся к LevelControl.cs, Взгляните на Сетгоалиндекс. Здесь мы назначим значение значения в синклист (Атгоал). Помните, что в контексте узла мы делаем это. Как и команда, RPC — это то, что может выдать узел, что приведет к тому, что все клиенты будут запускать некоторый код. Здесь мы вызываем "Рпкчеккаллгоалс". Каждый клиент будет отдельно проверять, установлены ли все три Атгоалс, и если да, запустите Rocket.

### <a name="enjoy-your-progress"></a>Наслаждайтесь ходом выполнения

Основываясь на предыдущей главе, мы будем запускать сеанс, как и раньше. На этот раз, когда пользователи в иммерсивное гарнитуре появятся в "дверце" на пути, появится всплывающая подсказка, которая может видеть только пользователи HoloLens. Пользователи HoloLens несут ответственность за передачу этой информации пользователям в иммерсивное гарнитуру. Rocket запустится, когда каждый Аватар пойдет на соответствующую коричневую панель в о вулканах. Сцена будет сброшена через 60 секунд, что позволит выполнить ее снова.

## <a name="see-also"></a>См. также раздел

* [213. Ввод в смешанной реальности: контроллеры движения](mixed-reality-213.md)